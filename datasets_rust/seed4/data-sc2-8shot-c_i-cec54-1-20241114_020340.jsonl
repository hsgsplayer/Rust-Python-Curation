{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: asynchronous function programming, function composition, awaiting asynchronous tasks\n\n### Task", "fingerprint": null, "seed": "async fn get_historic_rates() {\n    let exchange = init().await;\n    let req = GetHistoricRatesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        interval: Interval::OneHour,\n        paginator: None,\n    };\n    let resp = exchange.get_historic_rates(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 3, "concepts": ["asynchronous function programming", "function composition", "awaiting asynchronous tasks"], "instruction": "Design a Rust function that takes a list of URLs and returns a list of their contents, in parallel. Each list item is a string containing the URL and its content. The function should handle cases where one or more of the items fails to return a result."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: command-line argument parsing, standard library functions for string manipulation, input validation\n\n### Task", "fingerprint": null, "seed": "fn help() {\n    cargo_fuzz().arg(\"help\").assert().success();\n}", "id": 4, "concepts": ["command-line argument parsing", "standard library functions for string manipulation", "input validation"], "instruction": "Create a Rust function that takes a list of command-line arguments as input and performs operations on them. The list of arguments may contain any number of options and one or more positional options. The function should display the help message for the following options:\n- `--help`: displays the help message\n- `--version`: displays the version number\n- `--units`: displays the list of available size units\n- `--from-unit`: converts a value from a size unit specified by the `--units` option to bytes\n- `--to-unit`: converts a value from bytes to a size unit specified by the `--units` option\n\nEach positional option takes two arguments: a number and a size unit. For example, `10MB` is a positional argument with two arguments: `10` and `MB`. The program should handle the following scenarios:\n- Invalid inputs: report errors for missing required arguments, invalid unit names, and invalid conversion operations\n- Invalid conversions: report errors for values that are negative or exceed the limit for conversions\n- Non-conforming inputs: report errors for invalid positional arguments that are not valid size units or contain invalid characters\n\nIf an invalid option is provided, report an error and exit the program. Ensure that the program exits successfully in all other cases, displaying the appropriate output."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call usage, C function call, Linux specific system calls\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_top_page_table(target: CAddr, table: CAddr) {\n    system_call(SystemCall::TaskSetTopPageTable {\n        request: (target, table),\n    });\n}", "id": 7, "concepts": ["system call usage", "C function call", "Linux specific system calls"], "instruction": "Implement a class that can be used to calculate the number of trailing zeros in a Linux system's `cat /proc/cpuinfo` file. The class should have a method `get_zeros` that returns the number of trailing zeros for the file. The file should be read from a system call and parsed into the class."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: logging, boolean operations on function return values\n\n### Task", "fingerprint": null, "seed": "async fn init() -> Result<Args> {\n\tlet mut log_on = false;\n\n\t#[cfg(feature = \"dev-console\")]\n\tmatch console_subscriber::try_init() {\n\t\tOk(_) => {\n\t\t\twarn!(\"dev-console enabled\");\n\t\t\tlog_on = true;\n\t\t}\n\t\tErr(e) => {\n\t\t\teprintln!(\"Failed to initialise tokio console, falling back to normal logging\\n{e}\")\n\t\t}\n\t}\n\n\tif !log_on && var(\"RUST_LOG\").is_ok() {\n\t\tmatch tracing_subscriber::fmt::try_init() {\n\t\t\tOk(_) => {\n\t\t\t\twarn!(RUST_LOG=%var(\"RUST_LOG\").unwrap(), \"logging configured from RUST_LOG\");\n\t\t\t\tlog_on = true;\n\t\t\t}\n\t\t\tErr(e) => eprintln!(\"Failed to initialise logging with RUST_LOG, falling back\\n{e}\"),\n\t\t}\n\t}\n\n\tlet args = args::get_args();\n\tlet verbosity = args.verbose.unwrap_or(0);\n\n\tif log_on {\n\t\twarn!(\"ignoring logging options from args\");\n\t} else if verbosity > 0 {\n\t\tlet log_file = if let Some(file) = &args.log_file {\n\t\t\tlet is_dir = metadata(&file).await.map_or(false, |info| info.is_dir());\n\t\t\tlet path = if is_dir {\n\t\t\t\tlet filename = format!(\n\t\t\t\t\t\"watchexec.{}.log\",\n\t\t\t\t\tchrono::Utc::now().format(\"%Y-%m-%dT%H-%M-%SZ\")\n\t\t\t\t);\n\t\t\t\tfile.join(filename)\n\t\t\t} else {\n\t\t\t\tfile.to_owned()\n\t\t\t};\n\n\t\t\t// TODO: use tracing-appender instead\n\t\t\tSome(File::create(path).into_diagnostic()?)\n\t\t} else {\n\t\t\tNone\n\t\t};\n\n\t\tlet mut builder = tracing_subscriber::fmt().with_env_filter(match verbosity {\n\t\t\t0 => unreachable!(\"checked by if earlier\"),\n\t\t\t1 => \"warn\",\n\t\t\t2 => \"info\",\n\t\t\t3 => \"debug\",\n\t\t\t_ => \"trace\",\n\t\t});\n\n\t\tif verbosity > 2 {\n\t\t\tuse tracing_subscriber::fmt::format::FmtSpan;\n\t\t\tbuilder = builder.with_span_events(FmtSpan::NEW | FmtSpan::CLOSE);\n\t\t}\n\n\t\tmatch if let Some(writer) = log_file {\n\t\t\tbuilder.json().with_writer(Mutex::new(writer)).try_init()\n\t\t} else if verbosity > 3 {\n\t\t\tbuilder.pretty().try_init()\n\t\t} else {\n\t\t\tbuilder.try_init()\n\t\t} {\n\t\t\tOk(_) => info!(\"logging initialised\"),\n\t\t\tErr(e) => eprintln!(\"Failed to initialise logging, continuing with none\\n{e}\"),\n\t\t}\n\t}\n\n\tOk(args)\n}", "id": 8, "concepts": ["logging", "boolean operations on function return values"], "instruction": "Construct a Rust function `log_errors(func, *args, **kwargs)` that takes a function reference as an argument and returns another function. The returned function should invoke the supplied function with the provided arguments and return the result. If an exception occurs during the function invocation, the function should log an error message with the function name, arguments, and exception type.\n\nThe solution should satisfy the following assertions:\n\n```rust\ndef func(a, b):\n    return a + b\n\nfunc_logger = log_errors(func)\n\nassert_raises(TypeError, func_logger, 1, \"two\")\nassert_raises(TypeError, func_logger, 1.5, 3.5)\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: handling instruction-level operations, conditionally branching execution, flagging fixed-point solutions, breaking out of loops\n\n### Task", "fingerprint": null, "seed": "fn main() -> Result<()> {\n    let inss = parse_instructions()?;\n\n    for (pc, ins) in inss.iter().enumerate() {\n        match ins.op {\n            Operation::Nothing => {\n                // Don't invert zero `nop`s as `jmp +0` results in a loop.\n                if ins.arg != 0 && print_fixed_acc(&inss, Operation::Jump, pc) {\n                    break;\n                }\n            }\n            Operation::Jump => {\n                // Finish as soon as one inversion fixes the code.\n                if print_fixed_acc(&inss, Operation::Nothing, pc) {\n                    break;\n                }\n            }\n            Operation::Accumulate => {}\n        }\n    }\n\n    Ok(())\n}", "id": 9, "concepts": ["handling instruction-level operations", "conditionally branching execution", "flagging fixed-point solutions", "breaking out of loops"], "instruction": "Design a Rust program that takes a list of command-line arguments as input and performs operations on them. You should only allow the following commands:\n\n- `find <word>`: search for the specified word in the list starting from the first element. If it is found, display its index and exit the program. Otherwise, display a message that the word is not found and continue searching.\n- `exit`: exit the program.\n\nIf the program is terminated prematurely, you should print a message to notify the user that the program is terminated."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: file operations for file removal, directory creation, file existence checks\n\n### Task", "fingerprint": null, "seed": "fn build_all() {\n    let project = project(\"build_all\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_b\")\n        .assert()\n        .success();\n\n    // Build to ensure that the build directory is created and\n    // `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n\n    let a_bin = build_dir.join(\"build_all_a\");\n    let b_bin = build_dir.join(\"build_all_b\");\n\n    // Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    // Test that building all fuzz targets does in fact recreate the files.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    assert!(a_bin.is_file());\n    assert!(b_bin.is_file());\n}", "id": 10, "concepts": ["file operations for file removal", "directory creation", "file existence checks"], "instruction": "Write a Rust class named `File` with the following features:\n- Read-only access to the file contents when the file exists.\n- Write-only access to the file contents when the file does not exist.\n- Support for file creation on demand.\n- File deletion support, but only if the file does not have any open handles.\n- File existence check.\n- File creation and deletion on demand."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: pointer arithmetic, alignment calculation, conditional branching\n\n### Task", "fingerprint": null, "seed": "fn align_address(ptr: *const u8, align: usize) -> usize {\n    let addr = ptr as usize;\n    if addr % align != 0 {\n        align - addr % align\n    } else {\n        0\n    }\n}", "id": 11, "concepts": ["pointer arithmetic", "alignment calculation", "conditional branching"], "instruction": "Write a Rust program that takes a pointer to the start of a 32-bit integer array, the number of elements in the array, and a value to search for. The program should iterate over the array and print the starting position of the first occurrence of `value`, or `-1` if the value is not found. Use pointer arithmetic to access the array elements at each iteration."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operators, boolean logic, conditional branching\n\n### Task", "fingerprint": null, "seed": "fn active_entity(entity: Entity, world: &World) -> bool {\n    return world.masks[entity] & VOXEL_PASS_MASK == VOXEL_PASS_MASK;\n}", "id": 12, "concepts": ["bitwise operators", "boolean logic", "conditional branching"], "instruction": "Implement a Rust class `Bitwise` that offers advanced tools for manipulating bits in a numeric value. The class should maintain a numeric value that is initially 0. The class should support bitwise operations such as AND, OR, XOR, and NOT on the value. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `operation:arg`. Here are the detailed formats for each operation, explained through examples:\n- Bitwise AND: `apply_operation(\"and:1001011001\")`\n- Bitwise OR: `apply_operation(\"or:0100101000\")`\n- Bitwise XOR: `apply_operation(\"xor:0100101000\")`\n- Bitwise NOT: `apply_operation(\"not:\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the bits and a list of operations that have been applied to it."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: if-else-if structure, branching, polymorphism, error handling, regular expression\n\n### Task", "fingerprint": null, "seed": "fn build_author_map_(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    let mut walker = repo.revwalk()?;\n\n    if repo.revparse_single(to).is_err() {\n        // If a commit is not found, try fetching it.\n        git(&[\n            \"--git-dir\",\n            repo.path().to_str().unwrap(),\n            \"fetch\",\n            \"origin\",\n            to,\n        ])?;\n    }\n\n    if from == \"\" {\n        let to = repo.revparse_single(to)?.peel_to_commit()?.id();\n        walker.push(to)?;\n    } else {\n        walker.push_range(&format!(\"{}..{}\", from, to))?;\n    }\n\n    let mut author_map = AuthorMap::new();\n    for oid in walker {\n        let oid = oid?;\n        let commit = repo.find_commit(oid)?;\n\n        let mut commit_authors = Vec::new();\n        if !is_rollup_commit(&commit) {\n            // We ignore the author of rollup-merge commits, and account for\n            // that author once by counting the reviewer of all bors merges. For\n            // rollups, we consider that this is the most relevant person, which\n            // is usually the case.\n            //\n            // Otherwise, a single rollup with N PRs attributes N commits to the author of the\n            // rollup, which isn't fair.\n            commit_authors.push(Author::from_sig(commit.author()));\n        }\n        match parse_bors_reviewer(&reviewers, &repo, &commit) {\n            Ok(Some(reviewers)) => commit_authors.extend(reviewers),\n            Ok(None) => {}\n            Err(ErrorContext(msg, e)) => {\n                if e.is::<reviewers::UnknownReviewer>() {\n                    eprintln!(\"Unknown reviewer: {}\", ErrorContext(msg, e));\n                } else {\n                    return Err(ErrorContext(msg, e).into());\n                }\n            }\n        }\n        commit_authors.extend(commit_coauthors(&commit));\n        for author in commit_authors {\n            let author = mailmap.canonicalize(&author);\n            author_map.add(author, oid);\n        }\n    }\n    Ok(author_map)\n}", "id": 13, "concepts": ["if-else-if structure", "branching", "polymorphism", "error handling", "regular expression"], "instruction": "Write a Rust function to check if a given string is valid. A valid string has the following criteria:\n\n- It must start and end with double quotes.\n- It must have at least one word character in between quotes.\n- It must have only one of the following characters: alpha-numeric characters, spaces, commas, and period.\n- It must have only one comma or period between two words.\n\nUse a regular expression to validate the string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: error handling with exceptions, dynamic unit selection, string interpolation, sorting\n\n### Task", "fingerprint": null, "seed": "fn get_versions(repo: &Repository) -> Result<Vec<VersionTag>, Box<dyn std::error::Error>> {\n    let tags = repo\n        .tag_names(None)?\n        .into_iter()\n        .filter_map(|v| v)\n        .map(|v| v.to_owned())\n        .collect::<Vec<_>>();\n    let mut versions = tags\n        .iter()\n        .filter_map(|tag| {\n            Version::parse(&tag)\n                .or_else(|_| Version::parse(&format!(\"{}.0\", tag)))\n                .ok()\n                .map(|v| VersionTag {\n                    name: format!(\"Rust {}\", v),\n                    version: v,\n                    raw_tag: tag.clone(),\n                    commit: repo\n                        .revparse_single(&tag)\n                        .unwrap()\n                        .peel_to_commit()\n                        .unwrap()\n                        .id(),\n                    in_progress: false,\n                })\n        })\n        .collect::<Vec<_>>();\n    versions.sort();\n    Ok(versions)\n}", "id": 14, "concepts": ["error handling with exceptions", "dynamic unit selection", "string interpolation", "sorting"], "instruction": "Implement a Rust class with a method `parse_csv_file(filename)` that reads a comma-separated values (CSV) file and returns a list of dictionaries where each dictionary represents a row in the file and the keys are the column names. The method should handle cases where the file is empty or where an invalid CSV file is provided. Ensure the method leverages error handling to gracefully handle exceptions such as file not found and invalid file format. Additionally, enhance performance by dynamically selecting the appropriate data type for each column based on its CSV data type."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: error handling with exceptions, dynamic memory allocation, SQL statements execution\n\n### Task", "fingerprint": null, "seed": "fn\nchecked_memory_handle\n(\n)\n-\n>\nResult\n<\nConnection\n>\n{\nlet\ndb\n=\nConnection\n:\n:\nopen_in_memory\n(\n)\n?\n;\ndb\n.\nexecute_batch\n(\n\"\nCREATE\nTABLE\nfoo\n(\nb\nBLOB\nt\nTEXT\ni\nINTEGER\nf\nFLOAT\nn\n)\n\"\n)\n?\n;\nOk\n(\ndb\n)\n}", "id": 15, "concepts": ["error handling with exceptions", "dynamic memory allocation", "SQL statements execution"], "instruction": "Write a Rust function `execute_sql` that takes an SQL query as an argument and returns the result as a `Vec<Vec<String>>` or an error message if any errors occur during execution. Utilize dynamic memory allocation to store the query results and ensure proper error handling to manage exceptions that might occur during the execution of the query."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: conditional linking based on feature flags, conditional branching, file system access, file paths, file creation\n\n### Task", "fingerprint": null, "seed": "fn main() {\n\n    #[cfg(feature = \"breakout\")]\n    let memfile_bytes = include_bytes!(\"stm32h743zi_memory.x\");\n    #[cfg(not(feature = \"breakout\"))]\n    let memfile_bytes = include_bytes!(\"stm32h743vi_memory.x\");\n\n    // Put the linker script somewhere the linker can find it\n    let out = &PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n    File::create(out.join(\"memory.x\"))\n        .unwrap()\n        .write_all(memfile_bytes)\n        .unwrap();\n    println!(\"cargo:rustc-link-search={}\", out.display());\n}", "id": 16, "concepts": ["conditional linking based on feature flags", "conditional branching", "file system access", "file paths", "file creation"], "instruction": "Write a Rust function to check if a file exists in the current working directory. If the file exists, return its contents as a string. Otherwise, return a string indicating that the file does not exist. The function should be able to check for existence of any file type, such as text files, binary files, or directories. Each function call should be able to be debugged for its behavior."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: conditional execution, map initialization with entry(), map entry value access, multiple data types conditional branching, map entry key modification\n\n### Task", "fingerprint": null, "seed": "fn process_instructions(instructions: &Vec<Instruction>) -> (HashMap<&str, i32>, i32) {\n    let mut registers: HashMap<&str, i32> = HashMap::new();\n    let mut max = 0;\n\n    for instruction in instructions {\n        let current = *registers.entry(&instruction.condition.register).or_insert(0);\n\n        let condition_satisfied = match instruction.condition.operator {\n            Operator::LessThan           => current <  instruction.condition.value,\n            Operator::LessThanOrEqual    => current <= instruction.condition.value,\n            Operator::GreaterThan        => current >  instruction.condition.value,\n            Operator::GreaterThanOrEqual => current >= instruction.condition.value,\n            Operator::Equal              => current == instruction.condition.value,\n            Operator::NotEqual           => current != instruction.condition.value,\n        };\n\n        if !condition_satisfied {\n            continue;\n        }\n\n        let delta = match instruction.increase {\n            true  => instruction.value,\n            false => -1 * instruction.value,\n        };\n\n        let entry = registers.entry(&instruction.register).or_insert(0);\n        *entry += delta;\n        let new_value = *entry;\n\n        if new_value > max {\n            max = new_value;\n        }\n    }\n\n    (registers, max)\n}", "id": 17, "concepts": ["conditional execution", "map initialization with entry()", "map entry value access", "multiple data types conditional branching", "map entry key modification"], "instruction": "Write a program that initializes a map using a list of key-value pairs as input. This program should ensure that the map's keys are unique and that any duplicate keys are overwritten. The program should also ensure that the map's values are of the same type and that they are either numeric or strings. The program should return a message to the user indicating if the input was valid or not."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: concurrent programming, thread randomization, concurrent write and read operations, multiple data structures, row-based data partitioning, tuple comparison\n\n### Task", "fingerprint": null, "seed": "fn broker(table: &mut Table, ntransfers: u32) {\n\n  let mut rng = thread_rng();\n  let mut ract = Range::new(0, 100);\n  let mut ramt = Range::new(0, 1000);\n  let mut nstale = 0;\n\n  for _ in 0..ntransfers {\n    let a1 = ract.sample(&mut rng);\n    let mut a2 = ract.sample(&mut rng);\n    while a2 == a1 {\n      a2 = ract.sample(&mut rng);\n    }\n    let n = ramt.sample(&mut rng);\n\n    let rt = table.time();\n    let mut vs = [Value::default(); 2];\n    table.read(rt, &[a1, a2], &mut vs);\n    let r1 = Row { k: a1, v: vs[0].v - n };\n    let r2 = Row { k: a2, v: vs[1].v + n };\n    match table.write(rt, &[r1, r2]) {\n      WriteResult::Stale { .. } => nstale += 1,\n      _ => ()\n    }\n  }\n  assert!(nstale < ntransfers / 2);\n}", "id": 18, "concepts": ["concurrent programming", "thread randomization", "concurrent write and read operations", "multiple data structures", "row-based data partitioning", "tuple comparison"], "instruction": "Write a Rust program that satisfies the following specifications:\n\n- It should read a text file containing a list of rows. Each row should contain one or more fields separated by commas.\n- The program should randomly select one or more rows from the dataset. It should ensure that the selected rows are different from each other and from the original dataset.\n- The program should write the selected rows to a new text file. It should write the rows in the original order they are selected.\n\nThe program should be implemented as a main function, with the following high-level specifications:\n\n- It should take as command-line arguments the input and output file paths.\n- The program should use the `file` crate to read the input file and extract the rows as strings.\n- The program should use the `rand` crate to generate a random number for selecting rows.\n- The program should use the `std::fs` library to write the selected rows to the output file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: function composition, function definition with input and function call, function definition with return type, function input validation\n\n### Task", "fingerprint": null, "seed": "fn input(user_message: &str) -> io::Result<String> {\r\n    use std::io::Write;\r\n\r\n    print!(\"{}\", user_message);\r\n\r\n    io::stdout().flush()?;\r\n\r\n    let mut buffer: String = String::new();\r\n    io::stdin().read_line(&mut buffer)?;\r\n\r\n    Ok(buffer.trim_right().to_owned())\r\n}", "id": 19, "concepts": ["function composition", "function definition with input and function call", "function definition with return type", "function input validation"], "instruction": "Write a Rust class `ArithmeticCalculator` that can perform basic arithmetic operations (addition, subtraction, multiplication, division) on two operands. The class should have a method called `compute` that accepts two operands and an operation type (addition, subtraction, multiplication, or division) to compute the result. The method should accept the input and operation type in the form of a string, for example, `add(2, 3)` or `subtract(10, 5)`.\n\nThe class should perform input validation before the operation is executed and return an error message if the operands do not meet the expected types."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: conditional statement, thread sleep with duration, function composition, unbounded channels\n\n### Task", "fingerprint": null, "seed": "fn handle_task(client: &mut Client, main_out_c: Sender<String>) {\n    let (channel_out, channel_in) = unbounded();\n    let task_types = TaskCommandTypes::new();\n\n    // walk over the task queue. For any task_queue.state == 0, handle it.\n    for task in &mut client.task_queue {\n        // all tasks will have at least 1 iteration, but may have more. We also may have a sleep\n        // between iterations\n        let duration = (task.iteration_delay * 1000) as u64;\n        let sleep_duration = time::Duration::from_millis(duration);\n        for _iteration in 0..task.iterations {\n            let task_type = task_types.determine_task_type(task.command_type);\n            if task_type == \"filesystem\" {\n                // start the filesystem thread and go go go\n                let out_c = channel_out.clone();\n                filesystem::handle_filesystem(task, out_c);\n                task.state = 1;\n            }\n            // peek into the channel from our thread to see if there is data\n            // if there is, send it back\n            if let Ok(resp_from_thread) = channel_in.try_recv() {\n                println!(\"handle_task got something: {}\", &resp_from_thread);\n                // should send the task ID back out if successful. Otherwise, an err string\n                main_out_c.send(resp_from_thread).unwrap();\n                task.state = 2;\n            }\n            thread::sleep(sleep_duration);\n        }\n    }\n}", "id": 20, "concepts": ["conditional statement", "thread sleep with duration", "function composition", "unbounded channels"], "instruction": "Write a Rust function that satisfies the following assertions:\n\n```rust\nassert_eq!(\n    find_max_consecutive_length(vec![1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 5]),\n    3,\n);\nassert_eq!(\n    find_max_consecutive_length(vec![1, 2, 3, 4, 4, 5, 6, 6, 1, 1, 1, 1, 1, 1]),\n    3,\n);\nassert_eq!(find_max_consecutive_length(vec![1, 1, 1, 1]), 4);\nassert_eq!(find_max_consecutive_length(vec![1, 1, 2, 2, 3]), 2);\nassert_eq!(find_max_consecutive_length(vec![3, 2, 2, 2, 2, 1]), 1);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: command line argument parsing, process spawning and execution, output checking\n\n### Task", "fingerprint": null, "seed": "fn main() {     \n        std::process::Command::new(\"packfolder.exe\").args(&[\"src/frontend\", \"dupa.rc\", \"-binary\"])\n    .output().expect(\"no i ciul\");\n}", "id": 21, "concepts": ["command line argument parsing", "process spawning and execution", "output checking"], "instruction": "Design a Rust program that takes two command line arguments as input and spawns a process to execute the command. The output of the command should be checked for validity. If found invalid, the program should print the error message and exit with a non-zero exit code. If valid, the program should print the valid output to the console.\n\nEnsure that the program handles cases where the command is not found, or where it takes more than two arguments."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: array initialization, array length, array iteration, boolean array initialization, boolean array iteration, array sorting, filtering array elements\n\n### Task", "fingerprint": null, "seed": "fn array_test() {\n    let lazy_caterer: [u32; 6] = [1, 2, 4, 7, 11, 16];\n    let taxonomy = [\"Animalia\", \"arthropoda\", \"Insecta\"];\n\n    assert_eq!(lazy_caterer[3], 7);\n    assert_eq!(taxonomy.len(), 3);\n\n    let mut sieve = [true; 10000];\n    for i in 2..100 {\n        if sieve[i] {\n            let mut j = i * i;\n            while j < 10000 {\n                sieve[j] = false;\n                j += i;\n            }\n        }\n    }\n\n    assert!(sieve[211]);\n    assert!(!sieve[9876]);\n\n    let mut chaos = [3, 5, 4, 1, 2];\n    chaos.sort();\n    assert_eq!(chaos, [1, 2, 3, 4, 5]);\n}", "id": 22, "concepts": ["array initialization", "array length", "array iteration", "boolean array initialization", "boolean array iteration", "array sorting", "filtering array elements"], "instruction": "Create a Rust function `calculate_avg_indices` that takes two arguments: `a`, an array of numbers, and `target`, an integer value. The function should return the indices of the elements in `a` that are closest to `target`. The indices of the selected elements should be sorted in descending order. If there are multiple closest elements, you can return any of them."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call implementation, enum-based system call interface, function overloading\n\n### Task", "fingerprint": null, "seed": "pub fn retype_task(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeTask {\n        request: (source, target),\n    });\n}", "id": 23, "concepts": ["system call implementation", "enum-based system call interface", "function overloading"], "instruction": "Implement a Rust class `SystemCall` that supports executing system calls through a method of the class. The method should take a system call name as an input argument. From this input, the class should determine the appropriate system call to execute, and execute it. The method should also take a list of arguments as an input, where each element corresponds to a command-line argument to pass to the system call. The class should take care of converting the list into the appropriate form to pass to the system call.\n\nThe class should be implemented with a public enum type that supports all system calls of the operating system. The enum should have all possible system calls as variants, which can be called directly from the class. Additionally, the class should be implemented with a public function `execute_system_call` that takes a system call name as input, executes the system call, and returns the result of the system call. The function should be implemented with a public method `execute_system_call` that takes a system call name as input, executes the system call, and returns the result of the system call. Additionally, the function should take a list of arguments as input, where each element corresponds to a command-line argument to pass to the system call. The function should convert the list into the appropriate form to pass to the system call and execute it."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: character methods, string length, digit extraction, conversion, UTF-8 encoding\n\n### Task", "fingerprint": null, "seed": "fn char_test() {\n    assert_eq!('*'.is_alphabetic(), false);\n    assert_eq!('\u03b2'.is_alphabetic(), true);\n    assert_eq!('8'.to_digit(10), Some(8));\n    assert_eq!('\\u{CA0}'.len_utf8(), 3);\n    assert_eq!(std::char::from_digit(2, 10), Some('2'));\n}", "id": 24, "concepts": ["character methods", "string length", "digit extraction", "conversion", "UTF-8 encoding"], "instruction": "Develop a Rust class `StringParser` that supports parsing a string character by character. The class should encapsulate a string and provide methods for extracting words, digits, and special characters. The class should also support UTF-8 encoding and decoding.\n\nWrite the `__str__` method so that a formatted string is returned when the class is converted to a string. Include error handling so that the class can handle invalid inputs such as a string containing non-ASCII characters."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: testing a single migration, providing a datamodel to the migration, listing migration directories, listing the applied migrations\n\n### Task", "fingerprint": null, "seed": "fn listing_a_single_migration_name_should_work(api: TestApi) {\n    let dm = api.datamodel_with_provider(\n        r#\"\n        model Cat {\n            id Int @id\n            name String\n        }\n    \"#,\n    );\n\n    let migrations_directory = api.create_migrations_directory();\n\n    api.create_migration(\"init\", &dm, &migrations_directory).send_sync();\n\n    api.apply_migrations(&migrations_directory)\n        .send_sync()\n        .assert_applied_migrations(&[\"init\"]);\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[\"init\"]);\n}", "id": 25, "concepts": ["testing a single migration", "providing a datamodel to the migration", "listing migration directories", "listing the applied migrations"], "instruction": "Create a Rust class `MigrationManager` that manages database migrations. The class should support the creation, execution, and undoing of database migrations. The class should be able to manage a collection of migration files written in a YAML file format, where each file represents a single migration. The class should ensure that migrations are executed sequentially and only once per database. Finally, the class should provide a method to list the applied migrations.\n\nThe class should implement two methods, `create_migration(self, migration_file: str)`, and `apply_migrations(self)`, where `migration_file` indicates the directory containing the migration files and the class should ensure that the migrations are executed sequentially. Additionally, `apply_migrations` should undo the previously applied migrations and revert the database back to the original state."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: testing a custom project, implementation of the fuzzing workflow, file handling API, integration of the fuzzing framework\n\n### Task", "fingerprint": null, "seed": "fn add() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n\n    assert!(project.fuzz_cargo_toml().is_file());\n    let cargo_toml = fs::read_to_string(project.fuzz_cargo_toml()).unwrap();\n    let expected_bin_attrs = \"test = false\\ndoc = false\";\n    assert!(cargo_toml.contains(expected_bin_attrs));\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"new_fuzz_target\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}", "id": 26, "concepts": ["testing a custom project", "implementation of the fuzzing workflow", "file handling API", "integration of the fuzzing framework"], "instruction": "Create a Rust program to compare two text files and determine whether they are identical or not. If the files are identical, the program should print \"Files are identical.\" If they are not, the program should print \"Files are different.\" Both files must be located in a valid directory."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: explicit map-based type conversion, explicit match-based type conversion\n\n### Task", "fingerprint": null, "seed": "fn db_scheme_type_mapper(scheme: &str) -> SchemeType {\n    match scheme {\n        \"postgres\" => SchemeType::Relative(5432),\n        \"mysql\" => SchemeType::Relative(3306),\n        _ => SchemeType::NonRelative,\n    }\n}", "id": 27, "concepts": ["explicit map-based type conversion", "explicit match-based type conversion"], "instruction": "Write a Rust function `convert_types` that takes a list of values and converts them to their respective data types. The function should return a list of values with the same length containing the converted types. The function should be generic and should handle any type of value. It should work with different types of data including lists, dictionaries, and tuples."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: I/O on a microcontroller, blocking and non-blocking calls to I/O ports, implementing a finite state machine\n\n### Task", "fingerprint": null, "seed": "fn main() -> ! {\n    let mut robot = init_peripherals(\n        stm32f446::Peripherals::take().unwrap(),\n        cortex_m::Peripherals::take().unwrap(),\n    );\n\n    init_servo(&mut robot);\n\n    let mut reader = TrameReader::new();\n\n    loop {\n        let b = block!(robot.pc_rx.read()).unwrap();\n        reader.step(b);\n        if let Some(trame) = reader.pop_trame() {\n            asm::bkpt();\n        }\n\n        /*\n        let mess = servos[0x05].stat();\n        for b in mess {\n            block!(robot.servo_tx.write(b)).unwrap();\n        }\n\n        robot.delay.delay_ms(70 as u16);\n*/\n        /*\n        if let Ok(byte) = pc_rx.read() {\n            reader.step(byte);\n        }\n        if let Some(trame) = reader.pop_trame() {\n            if let Some(sent) = handle_trame(trame) {\n                let (arr, size): ([u8; 15], usize) = sent.into();\n                for b in arr[0..size].iter() {\n                    block!(pc_tx.write(*b)).unwrap();\n                }\n            }\n        }*/\n    }\n}", "id": 28, "concepts": ["I/O on a microcontroller", "blocking and non-blocking calls to I/O ports", "implementing a finite state machine"], "instruction": "Create a Rust function `read_port_blocking` that reads a single byte of data from a microcontroller's I/O port and returns the value as an unsigned integer. It should use blocking I/O to read the data, where it should stop reading from the port when the port is empty. The function should return `None` if no data is available."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: fuzzing initialization, fuzzing launch, fuzzing target execution, fuzzing target directory structure\n\n### Task", "fingerprint": null, "seed": "fn init() {\n    let project = project(\"init\").build();\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"fuzz_target_1\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}", "id": 29, "concepts": ["fuzzing initialization", "fuzzing launch", "fuzzing target execution", "fuzzing target directory structure"], "instruction": "Create a Rust function that fuzzes a program for a defined period of time. The function should take a program path as an input and perform fuzzing by launching instances of the program in a separate process.\n\nThe function should initialize the fuzzing process by creating a temporary directory to store the fuzzing corpus and fuzzing data within that directory. The function should then launch the program in a separate process with the path to the corpus directory as an argument. Once the program is launched, the function should wait for a period of time specified as an argument to complete. Once the time is up, the function should exit the program.\n\nThe function should return the final directory path of the fuzzing corpus and fuzzing data. This implementation requires initializing a temporary directory to store the fuzzing corpus and fuzzing data within. It also requires launching the program in a separate process with the path to the corpus directory as an argument. In order to accomplish these tasks, the function may involve the use of subprocess.Popen and os.path.join, and the concept of temporary directories may be implemented using tempfile.TemporaryDirectory."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: async/await, composable operator, lattice analysis for network operations, map and set union operators for routing\n\n### Task", "fingerprint": null, "seed": "async fn server(url: &str) -> Result<!, String> {\n\n    let server = TcpServer::bind(url).await.map_err(|e| e.to_string())?;\n    let (op_reads, op_writes) = TcpServerOp::<RequestLatRepr>::new(server.clone())\n        // .debug(\"ingress\")\n        .morphism_closure(|item| item.flatten_keyed::<tag::VEC>())\n        .morphism(Switch)\n        // .debug(\"split\")\n        .switch();\n\n    type ReadsLatRepr = MapUnionRepr<tag::HASH_MAP, String, SetUnionRepr<tag::HASH_SET, SocketAddr>>;\n    let op_reads = op_reads\n        // .debug(\"read\")\n        .lattice_default::<ReadsLatRepr>();\n\n    type WritesLatRepr = MapUnionRepr<tag::HASH_MAP, String, ValueLatRepr>;\n    let op_writes = op_writes\n        // .debug(\"write\")\n        .lattice_default::<WritesLatRepr>();\n\n    let binary_func = HashPartitioned::<String, _>::new(\n        TableProduct::<_, _, _, MapUnionRepr<tag::VEC, _, _>>::new());\n\n    let comp = BinaryOp::new(op_reads, op_writes, binary_func)\n        .morphism_closure(|item| item.transpose::<tag::VEC, tag::VEC>())\n        .comp_tcp_server::<ResponseLatRepr, _>(server);\n\n    comp\n        .run()\n        .await\n        .map_err(|e| format!(\"TcpComp error: {:?}\", e))?;\n}", "id": 30, "concepts": ["async/await", "composable operator", "lattice analysis for network operations", "map and set union operators for routing"], "instruction": "Develop a Rust class `Network` for managing a network of routers, each of which can connect to another. Represent each router with an ID, a name, and a list of IDs or names of other routers that it connects to. The class should support adding and removing routers, connecting to other routers, and finding other routers that are connected to it. Additionally, it should support finding the shortest path between two routers, i.e., the sequence of routers that connects them from one to another.\n\nThe class should be implemented as an asynchronous Python generator, and should use the async/await keywords to simplify the implementation. Additionally, it should incorporate composable operators for routing, such as map and set union operators."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: testing a custom implementation, implementation of sparse memory, crash testing\n\n### Task", "fingerprint": null, "seed": "pub fn test_op_rvc_slli_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_slli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_slli_crash_32\".into()]);\n    assert!(result.is_ok());\n}", "id": 31, "concepts": ["testing a custom implementation", "implementation of sparse memory", "crash testing"], "instruction": "Create a custom implementation of sparse memory for storing and accessing elements in a map or set. The implementation should support the following operations:\n\n- `insert(key, value)`: insert or update a value for a given key\n- `get(key)`: retrieve the value for a given key\n- `delete(key)`: delete the value for a given key\n- `clear()`: delete all key-value pairs\n\nThe implementation should satisfy the following assertions:\n\n```rust\nassert_eq!(sparse_memory.get(0), None);\nsparse_memory.insert(0, 0);\nassert_eq!(sparse_memory.get(0), Some(0));\nsparse_memory.insert(1, 1);\nassert_eq!(sparse_memory.get(0), Some(0));\nassert_eq!(sparse_memory.get(1), Some(1));\nsparse_memory.insert(2, 2);\nassert_eq!(sparse_memory.get(0), Some(0));\nassert_eq!(sparse_memory.get(1), Some(1));\nassert_eq!(sparse_memory.get(2), Some(2));\nsparse_memory.delete(0);\nassert_eq!(sparse_memory.get(0), None);\nassert_eq!(sparse_memory.get(1), Some(1));\nassert_eq!(sparse_memory.get(2), Some(2));\nsparse_memory.insert(5, 5);\nassert_eq!(sparse_memory.get(0), None);\nassert_eq!(sparse_memory.get(1), Some(1));\nassert_eq!(sparse_memory.get(2), Some(2));\nassert_eq!(sparse_memory.get(5), Some(5));\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: logical or in a match expression, error handling with exceptions\n\n### Task", "fingerprint": null, "seed": "pub fn get_home() -> Result<String, ()> {\n    match dirs::home_dir() {\n        None => Ok(String::new()),\n        Some(path) => Ok(path.to_str().unwrap().to_string()),\n    }\n}", "id": 32, "concepts": ["logical or in a match expression", "error handling with exceptions"], "instruction": "Create a Rust function that accepts a string as input and computes the first non-whitespace character in the string. The function should raise an error if the input is empty."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call for debugging, infinite loop to avoid termination\n\n### Task", "fingerprint": null, "seed": "pub fn debug_test_fail() {\n    system_call(SystemCall::DebugTestFail);\n    loop {}\n}", "id": 33, "concepts": ["system call for debugging", "infinite loop to avoid termination"], "instruction": "Create a Rust class that implements a stack data structure. The class should support the following operations:\n\n1. push(value): push an element onto the stack\n2. pop(): remove and return the top element from the stack\n3. is_empty(): check if the stack is empty\n\nThe push operation should not return anything. The pop and is_empty operations should return `None` if the stack is empty."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regex pattern matching, function composition, vector of vector traversal\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    let re_top = Regex::new(r\" {4}|\\[([A-Z])\\]\").unwrap();\n    let re_action = Regex::new(r\"move (\\d+) from (\\d+) to (\\d+)\").unwrap();\n    let mut stacks: Vec<Vec<char>> = Vec::new();\n\n    let mut input = io::stdin().lock().lines()\n        .flat_map(|l| l.ok());\n\n    for line in &mut input {\n        if line.trim().is_empty() { break }\n        for (ix, ch) in match_iter::<char>(&re_top, &line).enumerate() {\n            if let Some(ch) = ch {\n                ensure_size(&mut stacks, ix + 1);\n                stacks[ix].push(ch);\n            }\n        }\n    }\n\n    for stack in &mut stacks {\n        stack.reverse()\n    }\n\n    for line in input {\n        if let Some((num, src, dst)) = match_capture::<Action>(&re_action, &line) {\n            let (src, dst) = get_disjoint(&mut stacks, src - 1, dst - 1);\n            assert!(num <= src.len(), \"Trying to pop {} from {}\", num, src.len());\n            let pos = src.len() - num;\n            dst.extend_from_slice(&src[pos..]);\n            src.truncate(pos);\n        }\n    }\n\n    let letters = stacks.iter().map(|s| s.last().expect(\"Stack is empty\"));\n    println!(\"{}\", letters.collect::<String>());\n}", "id": 34, "concepts": ["regex pattern matching", "function composition", "vector of vector traversal"], "instruction": "Develop a Rust program that reads a file of URLs and outputs the URL to the console. The URL should be valid if it meets the following criteria:\n- Starts with http:// or https://\n- Contains a protocol (http or https)\n- Contains a host\n- Contains a path\n\nThe program should handle invalid URLs gracefully by reporting an error and terminating. Additionally, optimize the program's performance by implementing appropriate data structures and utilizing function composition to compose operations together."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call invocation, function pointer detour\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_instruction_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetInstructionPointer {\n        request: (target, ptr),\n    });\n}", "id": 36, "concepts": ["system call invocation", "function pointer detour"], "instruction": "Write a Rust class that implements a stack data structure. The class should support the following operations:\n\n1. `__init__(self)`\n2. `is_empty(self) -> bool`\n3. `push(self, val: T) -> None`\n4. `pop(self) -> None`\n5. `peek(self) -> T`\n\nThe data structure should be implemented using a `std::Vec` object that is used as a list storage."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: conditional match statement, Option unwrap, default arguments, error handling, logging\n\n### Task", "fingerprint": null, "seed": "pub fn parse_opts() -> Result<CliStatus, Error> {\n    let opt = Opt::from_args();\n    log::debug!(\"Cli opts are: {:?}\", opt);\n\n    match opt.cmd {\n        Command::Generate => {\n            generate_empty_config().context(\"Failed to generate config\")?;\n            log::info!(\"config.yml generated\");\n            Ok(CliStatus::Exit)\n        }\n        Command::Run {\n            config,\n            twil_sid,\n            twil_token,\n            twil_from,\n        } => {\n            if twil_sid.is_none() || twil_token.is_none() || twil_from.is_none() {\n                bail!(\"TWIL_ACCOUNT_SID, TWIL_AUTH_TOKEN & TWIL_FROM env variables must be set, or passed via --twil-sid, --twil-token & --twil-from\");\n            }\n            let twil_sid = twil_sid.unwrap();\n            let twil_token = twil_token.unwrap();\n            let twil_from = twil_from.unwrap();\n\n            let app_config = AppConfig::new(config, twil_sid, twil_token, twil_from)\n                .context(\"Failed to get config\")?;\n\n            Ok(CliStatus::Continue(app_config))\n        }\n    }\n}", "id": 38, "concepts": ["conditional match statement", "Option unwrap", "default arguments", "error handling", "logging"], "instruction": "Write a Rust function that performs a linear search with a specified target. If the target is found, the function should return the index of the first occurrence. If not, the function should return `-1`. Handle both cases gracefully, such as handling the case where the target cannot be found in the list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: JSON parsing with serde, iterating over timelines, creation of a struct with custom methods, optional return of a function\n\n### Task", "fingerprint": null, "seed": "pub fn parse(raw: &str) -> Option<game::Game> {\n    let game_raw: GameRaw = serde_json::from_str(raw).ok()?;\n\n    let even_initial_timelines = game_raw\n        .timelines\n        .iter()\n        .any(|tl| tl.index == -0.5 || tl.index == 0.5);\n\n    let min_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .min_by_key(|x| (*x) as isize)?;\n    let max_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .max_by_key(|x| (*x) as isize)?;\n\n    let timeline_width = ((-min_timeline).min(max_timeline) + 1.0).round();\n    let active_timelines = game_raw.timelines\n        .iter()\n        .filter(|tl| tl.index.abs() <= timeline_width);\n    let present = active_timelines\n        .map(|tl| tl.begins_at + (tl.states.len() as isize) - 1)\n        .min()?;\n\n    let mut res = game::Game::new(game_raw.width, game_raw.height);\n\n    res.info.present = present;\n    res.info.min_timeline = de_l(min_timeline, even_initial_timelines);\n    res.info.max_timeline = de_l(max_timeline, even_initial_timelines);\n    res.info.active_player = game_raw.active_player;\n    res.info.even_initial_timelines = even_initial_timelines;\n\n    for tl in game_raw.timelines.into_iter() {\n        res.timelines.insert(\n            de_l(tl.index, even_initial_timelines),\n            de_timeline(tl, even_initial_timelines),\n        );\n    }\n\n    Some(res)\n}", "id": 39, "concepts": ["JSON parsing with serde", "iterating over timelines", "creation of a struct with custom methods", "optional return of a function"], "instruction": "Create a Rust program that performs a Twitter search with a keyword and then prints out the results in CSV format. The program should implement five methods:\n- `get_user_timeline`: given a Twitter user, return a list of the most recent 20 tweets from the user\n- `get_tweet_text`: given a tweet, return the text of the tweet\n- `print_user_timeline`: given a list of tweets, print the text of each tweet in CSV format\n- `search`: given a keyword, return a list of the most recent 20 tweets with that keyword\n- `print_search_results`: given a list of tweets, print the text of each tweet in CSV format\n\nAlso, the program should extract the information out of the JSON response (assume the format of the array is always the same), and print the text of the tweet in CSV format (e.g., `time,user,tweet`). To ensure the program has robust error handling, create a function to process the JSON string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: conditional assertion, conditional function execution, error handling with error type validation\n\n### Task", "fingerprint": null, "seed": "fn assert_memory_load_bytes<R: Rng, M: Memory>(\n    rng: &mut R,\n    memory: &mut M,\n    buffer_size: usize,\n    addr: u64,\n) {\n    let mut buffer_store = Vec::<u8>::new();\n    buffer_store.resize(buffer_size, 0);\n    rng.fill(buffer_store.as_mut_slice());\n\n    memory\n        .store_bytes(addr, &buffer_store.as_slice())\n        .expect(\"store bytes failed\");\n\n    let buffer_load = memory\n        .load_bytes(addr, buffer_store.len() as u64)\n        .expect(\"load bytes failed\")\n        .to_vec();\n\n    assert!(buffer_load.cmp(&buffer_store).is_eq());\n\n    // length out of bound\n    let outofbound_size = if buffer_store.is_empty() {\n        memory.memory_size() + 1\n    } else {\n        buffer_store.len() + memory.memory_size()\n    };\n    let ret = memory.load_bytes(addr, outofbound_size as u64);\n    assert!(ret.is_err());\n    assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n\n    // address out of bound\n    let ret = memory.load_bytes(\n        addr + memory.memory_size() as u64 + 1,\n        buffer_store.len() as u64,\n    );\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok())\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n\n    // addr + size is overflow\n    let ret = memory.load_bytes(addr + (0xFFFFFFFFFFFFFF - addr), buffer_store.len() as u64);\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok());\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n}", "id": 40, "concepts": ["conditional assertion", "conditional function execution", "error handling with error type validation"], "instruction": "Implement a Rust function `get_division_result(a: i32, b: i32)` that calculates the quotient of `a` divided by `b` without using division. You should handle errors gracefully, such as division by zero, and the function should return the result value of the division."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: hash table modification, hash table iteration, advanced time measurement, floating-point precision control\n\n### Task", "fingerprint": null, "seed": "fn main() {\n\n  let nhits = 20;\n  let ntrials = 2000;\n  let nnanos = 60 * 1000 * 1000 * 1000;\n  let ntransfers = 1000;\n  let nbrokers = 8;\n  let tolerance = 0.05;\n  let ops = (ntransfers * nbrokers) as f64;\n  let million = (1000 * 1000) as f64;\n\n  let mut sum = 0.0;\n\n  let mut hits = 0;\n  let mut trial = 0;\n  let limit = time::precise_time_ns() + nnanos;\n  while hits < nhits && trial < ntrials && time::precise_time_ns() < limit {\n    let mut table = HashMapOfTreeMap::new();\n    let start = time::precise_time_ns();\n    for _ in 0..nbrokers {\n      broker(&mut table, ntransfers);\n    }\n    let end = time::precise_time_ns();\n    let ns = (end - start) as f64;\n    let x = ops / ns * million;\n    sum += x;\n    let n = (trial + 1) as f64;\n    let mean = sum / n;\n    let dev = (x - mean).abs() / mean;\n    if dev <= tolerance {\n      println!(\"{:5} {:8.2} ops/ms ({:8.2})\", trial, x, mean);\n      hits += 1;\n    }\n    trial += 1;\n  }\n}", "id": 41, "concepts": ["hash table modification", "hash table iteration", "advanced time measurement", "floating-point precision control"], "instruction": "Design a Rust program that performs a series of hash table operations on a random list of integers. The program should provide adequate logging and error handling to ensure the correct functioning of the hash table. The program should also take the time required to perform these operations and the memory usage of the hash table to report its efficiency."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file system I/O with path manipulation, error handling, return tuple\n\n### Task", "fingerprint": null, "seed": "fn read_input_configurations(confs: Vec<PathBuf>) -> (Vec<ComponentEntry>, Vec<ComponentEntry>) {\n    let mut configurations = Vec::new();\n\n    for path in confs {\n        match read_configuration(&path) {\n            Ok(conf) => configurations.push(conf),\n            Err(err) => eprintln!(\"{}\", err),\n        }\n    }\n\n    eprint!(\"\\n\");\n\n    let current_dir = current_dir().unwrap_or(PathBuf::new());\n    let entries = configurations\n        .iter()\n        .map(|conf| ReadConf {\n            conf: None,\n            path: current_dir.join(&conf.path),\n            backup_conf: None,\n            description: conf.description.clone(),\n            volume_type: conf.volume_type.clone(),\n        })\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    let components = configurations\n        .into_iter()\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    (components, entries)\n}", "id": 42, "concepts": ["file system I/O with path manipulation", "error handling", "return tuple"], "instruction": "Create a Rust function `get_file_path_extension` that takes a file path as an argument, and returns the extension of the file as a string. The function should handle a variety of file paths, including absolute, relative, and Windows paths. It should also handle cases where no extension is present, or where the file path is invalid."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: file I/O in Rust, parsing a custom binary format, raw buffer parsing, image decoding, image rendering\n\n### Task", "fingerprint": null, "seed": "fn main() \n{\n    let args: Vec<String> = std::env::args().collect();\n\n    if args.len() < 2 {\n        eprintln!(\"Syntax: {} <filename>\", args[0]);\n        return;\n    }\n\n    let path    = Path::new(&args[1]);\n    let display = path.display();\n\n    let mut file = match File::open(&path)    {\n        Err(why) => panic!(\"Could not open file: {} (Reason: {})\", \n            display, why.description()),\n        Ok(file) => file\n    };\n\n    // read the full file into memory. panic on failure\n    let mut raw_file = Vec::new();\n    file.read_to_end(&mut raw_file).unwrap();\n\n    // construct a cursor so we can seek in the raw buffer\n    let mut cursor = Cursor::new(raw_file);\n    let mut image  = match decode_ppm_image(&mut cursor) {\n        Ok (img) => img,\n        Err(why) => panic!(\"Could not parse PPM file - Desc: {}\", why.description()),\n    };\n\n    show_image(&image);\n}", "id": 43, "concepts": ["file I/O in Rust", "parsing a custom binary format", "raw buffer parsing", "image decoding", "image rendering"], "instruction": "Create a Rust function that reads in a binary file of a specific format (see below) and renders the image into an HTML canvas. The function should accept a path to the binary file to read, a width, and a height. The function should return a tuple containing the the width and height of the image, a string containing the HTML canvas code, and a string containing the CSS code. The output should be valid HTML5 code with a canvas element and CSS style information for the image.\n\nThe binary file has the following format:\n\n- 4 byte header specifying the width and height of the image. The file is padded to a multiple of 4 bytes.\n- 8 byte header specifying the image format (e.g., 'P2', 'P3'). The file is padded to a multiple of 4 bytes.\n- N byte raw RGB data for the image.\n\nThe RGB data should be interpreted as a list of tuples of `3` integers in the range `[0, 255]` representing the red, green, and blue values for each pixel, respectively.\n\nFor example, for an image with width `3` and height `2`, the image data would be stored in the following format:\n\n- 0x00000000: 0x00000003 0x00000002\n- 0x00000004: 0x00000002 0x00000003\n- 0x00000008: 0x00000003 0x00000002\n- 0x0000000C: 0x00000002 0x00000001\n- 0x00000010: 0x00000003 0x00000002\n- 0x00000014: 0x00000000 0x00000000\n\nThe function should accept the width and height of the image as arguments. It should construct a canvas element based on the width and height and render the image into the canvas element. The function should return a tuple containing the width and height, the HTML5 code for the canvas element, and the CSS code for the image."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: file system modification, file input/output, fuzz testing, command line parsing, command line argument handling\n\n### Task", "fingerprint": null, "seed": "fn build_stripping_dead_code() {\n    let project = project(\"build_strip\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_strip_a\")\n        .assert()\n        .success();\n\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"--strip-dead-code\")\n        .arg(\"--dev\")\n        .assert()\n        .success();\n\n    let build_dir = project.fuzz_build_dir().join(\"debug\");\n\n    let a_bin = build_dir.join(\"build_strip_a\");\n    assert!(a_bin.is_file(), \"Not a file: {}\", a_bin.display());\n}", "id": 44, "concepts": ["file system modification", "file input/output", "fuzz testing", "command line parsing", "command line argument handling"], "instruction": "Develop a Rust program that performs file system manipulations on a file. The program should be able to read from and write to files. It should be able to create and delete files, change the file extension, move and rename files, and read and write to files. It should also be able to recursively list the contents of a directory. Utilize fuzz testing to generate random inputs and test the program against them. Use command line arguments and parameters to read the inputs."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: parsing strings, string matching, list comprehension, iterative list extension\n\n### Task", "fingerprint": null, "seed": "fn initialize(lines: &Vec<String>) -> Vec<Day> {\n    let regex = Regex::new(r\"(\\d\\d-\\d\\d) ((?:23|00):\\d\\d)\\] (Guard #(\\d*)|wakes|falls)\").expect(\"Building Regex failed\");\n    let mut events = lines.iter().map(|l| GuardEvent::from_line(l, &regex)).collect::<Vec<GuardEvent>>();\n    events.sort_by(|GuardEvent {date: date1, minute: minute1, ..}, GuardEvent {date: date2, minute: minute2, ..}| {\n        date1.cmp(date2).then(minute1.cmp(minute2))\n    });\n\n    let mut days = Vec::new();\n    let mut events_iter = events.iter();\n    let mut event_option = events_iter.next();\n    while event_option.is_some() {\n        let event = event_option.unwrap();\n        assert_eq!(event.action, BeginsShift);\n        let mut current_day = Day::new(event.guard_id.unwrap());\n        let mut is_awake = true;\n        event_option = events_iter.next();\n        for minute in 0..60 {\n            if event_option.map_or(false, |e| e.action != BeginsShift && e.minute == minute) {\n                is_awake = !is_awake;\n                event_option = events_iter.next();\n            }\n            current_day.set_next_minute(is_awake);\n        }\n        days.push(current_day);\n    }\n    days\n}", "id": 45, "concepts": ["parsing strings", "string matching", "list comprehension", "iterative list extension"], "instruction": "Create a Rust function that extracts all of the unique words from a text (no punctuation) and returns them in a list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: memory store creation, memory store interface, advanced assertion checking, return value testing\n\n### Task", "fingerprint": null, "seed": "pub fn test_memory_store_empty_bytes() {\n    assert_memory_store_empty_bytes(&mut FlatMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut SparseMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut WXorXMemory::<FlatMemory<u64>>::default());\n    #[cfg(has_asm)]\n    assert_memory_store_empty_bytes(&mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000));\n}", "id": 46, "concepts": ["memory store creation", "memory store interface", "advanced assertion checking", "return value testing"], "instruction": "Write a Rust class to implement a simple advanced memory store, which can be instantiated with a default value for `capacity` and each value can be referenced by its integer key. The class must implement two methods: `set` and `get` and support both positive and negative integers.\n\nThe `set` method assigns a new value to a key, where the key is either positive or negative, and `get` returns the value associated with the key. Both methods should be O(1) time complexity.\n\nAdditionally, `set` and `get` should raise an error if the key is not between `[-capacity, capacity]` (inclusive).\n\nFinally, write assertions to test the class's interface."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file system manipulation, file input/output, fuzzing with coverage\n\n### Task", "fingerprint": null, "seed": "fn run_with_coverage() {\n    let target = \"with_coverage\";\n\n    let project = project(\"run_with_coverage\")\n        .with_fuzz()\n        .fuzz_target(\n            target,\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    println!(\"{:?}\", data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(target)\n        .arg(\"--\")\n        .arg(\"-runs=100\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 100 runs\"))\n        .success();\n\n    project\n        .cargo_fuzz()\n        .arg(\"coverage\")\n        .arg(target)\n        .assert()\n        .stderr(predicate::str::contains(\"Coverage data merged and saved\"))\n        .success();\n\n    let profdata_file = project.fuzz_coverage_dir(target).join(\"coverage.profdata\");\n    assert!(profdata_file.exists(), \"Coverage data file not generated\");\n}", "id": 47, "concepts": ["file system manipulation", "file input/output", "fuzzing with coverage"], "instruction": "Write a Rust function called `list_all_files` that takes the path to a directory as an argument. The function should recursively search the directory and list all files in the directory, its subdirectories, and return the list. In order to avoid infinite recursion, implement an explicit stack to track the files that are being processed."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: null pointer constant, null pointer dereference, constant function, return value cast to `u8`\n\n### Task", "fingerprint": null, "seed": "const fn null_ble_gatt_svc_def() -> ble_gatt_svc_def {\n    return ble_gatt_svc_def {\n        type_: BLE_GATT_SVC_TYPE_END as u8,\n        uuid: ptr::null(),\n        includes: ptr::null_mut(),\n        characteristics: ptr::null(),\n    };\n}", "id": 48, "concepts": ["null pointer constant", "null pointer dereference", "constant function", "return value cast to `u8`"], "instruction": "Write a Rust function to return the ASCII value of a character in an unsafe manner. Use constant functions for `is_digit` and `to_digit` to keep the code simple, and avoid potential undefined behavior. The function should accept a character `c` and return an unsigned 8-bit integer `u8` representing the ASCII value of the character, or -1 if the input is not a valid digit."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: geometry, vector slicing, vector indexing, vector normal distribution, branching, parent-child relationships between tiles\n\n### Task", "fingerprint": null, "seed": "pub fn main() {\n    let opts = TileOptions {\n        parent_x: 108,\n        parent_y: 54,\n        width: 10,\n        height: 10,\n        max_value: 10.0,\n        min_value: 0.0,\n        mean: 5.0,\n        std_dev: 2.0,\n    };\n    let t = NormalDistTile::new(opts);\n    println!(\" {:?}\", t.subtiles);\n    println!(\"{}\", t.get(0, 0));\n    println!(\"{}\", t.get(1, 0));\n    println!(\"{}\", t.get(2, 0));\n    println!(\"{}\", t.get(3, 0));\n\n    println!(\"{}\", t.get(0, 5));\n    println!(\"{}\", t.get(1, 5));\n    println!(\"{}\", t.get(2, 5));\n    println!(\"{}\", t.get(3, 5));\n\n    println!(\"{}\", t.get((t.width - 4) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 3) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 2) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 1) as u8, (t.height - 1) as u8));\n}", "id": 49, "concepts": ["geometry", "vector slicing", "vector indexing", "vector normal distribution", "branching", "parent-child relationships between tiles"], "instruction": "Write a Rust function to generate a pseudo-random color palette of length `n` from a given input `palette` of colors. You might choose to implement your own sampling algorithm, or use a library like `rand` to generate random samples."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: command-line argument parsing, runtime error handling, result type, branching, asynchronous programming, async functions\n\n### Task", "fingerprint": null, "seed": "pub async fn run() -> Result<()> {\n\tlet args = init().await?;\n\tdebug!(?args, \"arguments\");\n\n\tif args.manual {\n\t\trun_manpage(args).await\n\t} else if let Some(shell) = args.completions {\n\t\trun_completions(shell).await\n\t} else {\n\t\trun_watchexec(args).await\n\t}\n}", "id": 50, "concepts": ["command-line argument parsing", "runtime error handling", "result type", "branching", "asynchronous programming", "async functions"], "instruction": "Write a Rust program to classify a string as an IP address, an IPv4 address, or an IPv6 address. The program should take a string as input and print the relevant class of address to the console. The program should handle erroneous input and runtime errors gracefully."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: command-line argument parsing, mocking external dependencies, test case minimization, minigithub.com\n\n### Task", "fingerprint": null, "seed": "fn run_without_sanitizer_with_crash() {\n    let project = project(\"run_without_sanitizer_with_crash\")\n        .with_fuzz()\n        .fuzz_target(\n            \"yes_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    run_without_sanitizer_with_crash::fail_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"yes_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .arg(\"-sanitizer=none\")\n        .env(\"RUST_BACKTRACE\", \"1\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"panicked at 'I'm afraid of number 7'\")\n                .and(predicate::str::contains(\"ERROR: libFuzzer: deadly signal\"))\n                .and(predicate::str::contains(\"run_without_sanitizer_with_crash::fail_fuzzing\"))\n                .and(predicate::str::contains(\n                    \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\\n                     \\n\\\n                     Failing input:\\n\\\n                     \\n\\\n                     \\tfuzz/artifacts/yes_crash/crash-\"\n                ))\n                .and(predicate::str::contains(\"Output of `std::fmt::Debug`:\"))\n                .and(predicate::str::contains(\n                    \"Reproduce with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz run yes_crash fuzz/artifacts/yes_crash/crash-\"\n                ))\n                .and(predicate::str::contains(\n                    \"Minimize test case with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz tmin yes_crash fuzz/artifacts/yes_crash/crash-\"\n                )),\n        )\n        .failure();\n}", "id": 51, "concepts": ["command-line argument parsing", "mocking external dependencies", "test case minimization", "minigithub.com"], "instruction": "Write a Rust function called `list_all_commits` that takes the name of a GitHub repository as an argument and returns a list of all commits made to the repository in chronological order. The function should retrieve the repository's commits from https://api.github.com/repos/{owner}/{repo}/commits and return the results in a list of Commit objects, where each object represents a commit that includes the commit's SHA, author, date, and message.\n\nThe function should handle potential failures such as HTTP requests, invalid arguments, and empty response data. The function should also support multiple GitHub repositories as arguments."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: explicit error handling, generic error handling, error wrapping, error context stringification, parent error handling\n\n### Task", "fingerprint": null, "seed": "fn build_author_map(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    match build_author_map_(repo, reviewers, mailmap, from, to) {\n        Ok(o) => Ok(o),\n        Err(err) => Err(ErrorContext(\n            format!(\n                \"build_author_map(repo={}, from={:?}, to={:?})\",\n                repo.path().display(),\n                from,\n                to\n            ),\n            err,\n        ))?,\n    }\n}", "id": 52, "concepts": ["explicit error handling", "generic error handling", "error wrapping", "error context stringification", "parent error handling"], "instruction": "Write a Rust function to classify a string as an IP address in IPv4 format (e.g., `192.168.1.1`), IPv6 format (e.g., `fd00:a516:7c1b:17cd:6d81:2137:bd2a:2c5b`), or neither. The function should return an enumeration value (`Ipv4`, `Ipv6`, or `Neither`) or throw an error (`InvalidIpv4Address`, `InvalidIpv6Address`). Handle both cases of invalid addresses in different ways, including preconditions and error handling."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: explicit memory alignment, buffer creation, buffer usage, buffer mapping, dynamic buffer size\n\n### Task", "fingerprint": null, "seed": "fn create_mesh_buffer_verts(\n    chunk: &Chunk,\n    device: &wgpu::Device,\n    queue: &wgpu::Queue,\n) -> MeshBufferVerts {\n    // Calculate total length of buffer e.g. a full chunk of different voxels. This way a new buffer only has to be created when the voxel capacity is changed.\n\n    let verts = Mesh::verts(chunk);\n    let vert_len = verts.len();\n\n    let single_cube_verts = Mesh::cube_verts().len();\n    let single_cube_color_verts = (single_cube_verts / 3) * std::mem::size_of::<PaletteIndexType>(); // One PaletteIndexType per 3 verts\n\n    let max_voxels = {\n        let (x, y, z) = chunk.capacity();\n        x * y * z\n    };\n\n    let max_buf_size =\n        (single_cube_verts + single_cube_color_verts) * max_voxels * std::mem::size_of::<f32>();\n\n    let buffer = device.create_buffer(&wgpu::BufferDescriptor {\n        label: None,\n        mapped_at_creation: false,\n        size: max_buf_size as u64,\n        usage: wgpu::BufferUsage::VERTEX | wgpu::BufferUsage::COPY_DST,\n    });\n\n    if vert_len > 0 {\n        queue.write_buffer(&buffer, 0, bytemuck::cast_slice(&verts));\n    }\n\n    MeshBufferVerts {\n        buffer,\n        vert_len,\n        max_capacity: chunk.capacity(),\n    }\n}", "id": 53, "concepts": ["explicit memory alignment", "buffer creation", "buffer usage", "buffer mapping", "dynamic buffer size"], "instruction": "Write a Rust function called `create_dynamic_buffer` that creates a dynamic buffer of type `u8` using a C-style `extern \"C\" fn` callback function. The function should take a callback function as input and return a pointer to the created buffer. The callback function should accept a pointer to an `i32` as an argument, and the function should return a slice of `u8` of size `*i32` to be stored in the buffer. The buffer should be created with the correct alignment and size, and the returned pointer should be mapped using the `mmap` system call."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file creation, file writing, file reading, error handling\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_write(file_path: &str, contents: &str) -> Result<(), String> {\n    let mut file = File::create(file_path).map_err(|e| e.to_string())?;\n    file.write_all(contents.as_bytes())\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}", "id": 54, "concepts": ["file creation", "file writing", "file reading", "error handling"], "instruction": "Implement a Rust program that reads a text file and writes its content to another file. The program should create a new file for the output if it does not exist. The file should be written in binary format. If the file exists, the content should be appended to the end of the file. The program should handle exceptions and error messages appropriately."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: explicit channel read, channel send implementation, explicit channel take, channel receive implementation, explicit channel write\n\n### Task", "fingerprint": null, "seed": "pub fn channel_take<T: Any + Clone>(target: CAddr) -> T {\n    let (result, payload) = system_call_take_payload(SystemCall::ChannelTake {\n        request: target,\n        response: None\n    });\n    match result {\n        SystemCall::ChannelTake {\n            request: _,\n            response: Some(ChannelMessage::Payload),\n        } => {\n            return payload;\n        },\n        _ => panic!(),\n    };\n}", "id": 56, "concepts": ["explicit channel read", "channel send implementation", "explicit channel take", "channel receive implementation", "explicit channel write"], "instruction": "Implement a Rust program that reads a set of numbers from the command line and sends these numbers to another program. The other program should read the numbers from a channel and print their sum. Both programs should run concurrently."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: string conversion, command line parsing, process spawning, process termination\n\n### Task", "fingerprint": null, "seed": "fn git(args: &[&str]) -> Result<String, Box<dyn std::error::Error>> {\n    let mut cmd = Command::new(\"git\");\n    cmd.args(args);\n    cmd.stdout(Stdio::piped());\n    let out = cmd.spawn();\n    let mut out = match out {\n        Ok(v) => v,\n        Err(err) => {\n            panic!(\"Failed to spawn command `{:?}`: {:?}\", cmd, err);\n        }\n    };\n\n    let status = out.wait().expect(\"waited\");\n\n    if !status.success() {\n        eprintln!(\"failed to run `git {:?}`: {:?}\", args, status);\n        return Err(std::io::Error::from(std::io::ErrorKind::Other).into());\n    }\n\n    let mut stdout = Vec::new();\n    out.stdout.unwrap().read_to_end(&mut stdout).unwrap();\n    Ok(String::from_utf8_lossy(&stdout).into_owned())\n}", "id": 57, "concepts": ["string conversion", "command line parsing", "process spawning", "process termination"], "instruction": "Implement a Rust function that parses a command line string and returns a string representation of a Python shell. The command line parser should read input from the user and process the tokens according to the [Python Command Line Specification](https://www.python.org/dev/peps/pep-0363/). The process spawner should be able to spawn new processes within the shell's scope, and the process terminator should be able to kill the spawned process.\n\nFor example, given a command line input `python`, the function should spawn a Python process and return a string that looks like `[Python 3.8.10 (default, May 20 2021, 13:25:51) \n[Clang 10.0.0 (clang-1000.11.45.5)]\nType 'help', 'copyright', 'credits' or 'license' for more information.\n>>>`"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: repository traversal, git history traversal, git commit graph traversal, memoization\n\n### Task", "fingerprint": null, "seed": "fn generate_thanks() -> Result<BTreeMap<VersionTag, AuthorMap>, Box<dyn std::error::Error>> {\n    let path = update_repo(\"https://github.com/rust-lang/rust.git\")?;\n    let repo = git2::Repository::open(&path)?;\n    let mailmap = mailmap_from_repo(&repo)?;\n    let reviewers = Reviewers::new()?;\n\n    let mut versions = get_versions(&repo)?;\n    let last_full_stable = versions\n        .iter()\n        .rfind(|v| v.raw_tag.ends_with(\".0\"))\n        .unwrap()\n        .version\n        .clone();\n\n    versions.push(VersionTag {\n        name: String::from(\"Beta\"),\n        version: {\n            let mut last = last_full_stable.clone();\n            last.minor += 1;\n            last\n        },\n        raw_tag: String::from(\"beta\"),\n        commit: repo\n            .revparse_single(\"beta\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n    versions.push(VersionTag {\n        name: String::from(\"Master\"),\n        version: {\n            // master is plus 1 minor versions off of beta, which we just pushed\n            let mut last = last_full_stable.clone();\n            last.minor += 2;\n            last\n        },\n        raw_tag: String::from(\"master\"),\n        commit: repo\n            .revparse_single(\"master\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n\n    let mut version_map = BTreeMap::new();\n\n    let mut cache = HashMap::new();\n\n    for (idx, version) in versions.iter().enumerate() {\n        let previous = if let Some(v) = idx.checked_sub(1).map(|idx| &versions[idx]) {\n            v\n        } else {\n            let author_map = build_author_map(&repo, &reviewers, &mailmap, \"\", &version.raw_tag)?;\n            version_map.insert(version.clone(), author_map);\n            continue;\n        };\n\n        eprintln!(\"Processing {:?} to {:?}\", previous, version);\n\n        cache.insert(\n            version,\n            up_to_release(&repo, &reviewers, &mailmap, &version)?,\n        );\n        let previous = match cache.remove(&previous) {\n            Some(v) => v,\n            None => up_to_release(&repo, &reviewers, &mailmap, &previous)?,\n        };\n        let current = cache.get(&version).unwrap();\n\n        // Remove commits reachable from the previous release.\n        let only_current = current.difference(&previous);\n        version_map.insert(version.clone(), only_current);\n    }\n\n    Ok(version_map)\n}", "id": 58, "concepts": ["repository traversal", "git history traversal", "git commit graph traversal", "memoization"], "instruction": "Implement a Rust function that reads a Git project and outputs the commit graph. The graph represents the relationships between commits in a project. The output should be a dictionary with each commit as a key and the list of its parent commits as a value. The graph should be constructed based on the commit history and not empirically. Demonstrate the function by printing the graph of the `hello-rust` project."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterative bubble sort, comparison of elements in a list, swapping of elements for sorting\n\n### Task", "fingerprint": null, "seed": "pub fn bubble_sort<T: PartialOrd + Debug>(v: &mut [T]) {\n    for p in 0..v.len() {\n        // println!(\"{:?}\", v);\n        let mut sorted = true;\n        for i in 0..(v.len()-1) - p{\n            if v[i] > v[i+1] {\n                v.swap(i, i+1);\n                sorted = false;\n            }\n        }\n        if sorted {\n            return;\n        }\n    }\n}", "id": 59, "concepts": ["iterative bubble sort", "comparison of elements in a list", "swapping of elements for sorting"], "instruction": "Implement a Rust function to sort a list of integers from smallest to largest. Employ a bubble sort algorithm to achieve this."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: mocking syscalls through return values, conditional assertion checking, conditional error handling for syscalls, mocking syscalls through return values\n\n### Task", "fingerprint": null, "seed": "pub fn test_outofcycles_in_syscall() {\n    let buffer = fs::read(\"tests/programs/syscall64\").unwrap().into();\n    let core_machine = DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, 20);\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .instruction_cycle_func(Box::new(constant_cycles))\n        .syscall(Box::new(OutOfCyclesSyscall {}))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"syscall\".into()])\n        .unwrap();\n    let result = machine.run();\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), Error::CyclesExceeded);\n    assert_eq!(machine.cycles(), 108);\n    assert_eq!(machine.registers()[A0], 39);\n}", "id": 62, "concepts": ["mocking syscalls through return values", "conditional assertion checking", "conditional error handling for syscalls", "mocking syscalls through return values"], "instruction": "Implement a Rust function to check whether an input string is a valid email address. A valid email address contains a user name, a domain name, and a top-level domain (TLD). A valid user name should be a string of letters, numbers, and underscores, with a length between 3 and 15. A valid domain name contains strings of letters and numbers, and each domain name can consist of multiple domain names separated by a period. A valid TLD consists of letters and should be three characters or less. The main use of email addresses is to communicate with people. Make sure the function can handle all possible corner cases, including invalid input and an empty string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: string parsing, text file parsing, hash tables, sorting, vector iteration\n\n### Task", "fingerprint": null, "seed": "pub fn star1(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let (&sleepiest_guard_id, sleepiest_guard_days) = guard_map.iter()\n        .max_by_key(|(_, v)| v.iter()\n            .map(|day| 60 - day.minutes_awake)\n            .sum::<i32>()\n    ).unwrap();\n    let mut sleepiest_guard_awake_by_minutes = vec![0; 60];\n    for day in sleepiest_guard_days {\n        // println!(\"Day: {:?}\", day);\n        for minute in 0..60 {\n            sleepiest_guard_awake_by_minutes[minute] += i32::from(day.minutes[minute]);\n        }\n    }\n    let (max_minute, _) = sleepiest_guard_awake_by_minutes.iter().enumerate().min_by_key(|(_, times)| *times).unwrap();\n\n    println!(\"Min minute: {}, max guard: {}\", max_minute, sleepiest_guard_id);\n\n    (sleepiest_guard_id * max_minute as i32).to_string()\n}", "id": 63, "concepts": ["string parsing", "text file parsing", "hash tables", "sorting", "vector iteration"], "instruction": "Write a Rust class called `StringAnalyzer` that implements the following features:\n- keep track of a set of strings for analysis\n- provide a method to parse a text file containing a list of strings and store the strings in the internal list\n- provide a method to print the strings in the list\n- provide a method to sort the strings in the list alphabetically\n- provide a method to print the strings in the sorted order\n\nThe class should support the `str` type as the element type of the internal list. The `StringAnalyzer` class should support the `input_from_file` method to retrieve the data from a file, and the `print_strings` method should print the strings in the list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call wrapper, function call pattern, return value handling\n\n### Task", "fingerprint": null, "seed": "pub fn retype_raw_page_free(source: CAddr) -> CAddr {\n    let result = system_call(SystemCall::RetypeRawPageFree {\n        request: source,\n        response: None\n    });\n    match result {\n        SystemCall::RetypeRawPageFree {\n            response, ..\n        } => { return response.unwrap(); },\n        _ => panic!(),\n    };\n}", "id": 65, "concepts": ["system call wrapper", "function call pattern", "return value handling"], "instruction": "Write a Rust function called `system_call` that takes a string representing a system call command as a parameter. The function should execute this command and return the output as a string. If an error occurs while executing the command, it should handle the error by returning an empty string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file parsing, file reading with line number checking, dictionary lookup based on key, conditional branching\n\n### Task", "fingerprint": null, "seed": "fn parseFromFile(file: &File) {\r\n    let mut reader = BufReader::new(file);\r\n    let mut buf = String::from(\"\");\r\n    let line_index = 0;\r\n    let mut models: Vec<Model> = Vec::new();\r\n    let mut lights: Vec<Model> = Vec::new();\r\n    while (reader.read_line(&mut buf) != 0) {\r\n        if lien_index == 0 {\r\n            if line == 'm' {\r\n                //now we read the model data\r\n                reader.read_line(&mut buf);\r\n                let model_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut model_index = 0;\r\n                while model_index < model_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n            if line == 'l' {\r\n                reader.read_line(&mut buf);\r\n                let light_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut light_index = 0;\r\n                while light_index < light_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}", "id": 66, "concepts": ["file parsing", "file reading with line number checking", "dictionary lookup based on key", "conditional branching"], "instruction": "Write a Rust program that reads a text file and outputs the line number of each occurrence of a given search term. The program should support multiple search terms."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: error handling with match, option pattern matching, error handling with try! macro, error handling with Result enum\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    if let Err(err) = Config::new().and_then(|conf| ui::user_menu(conf)) {\n        eprintln!(\"{}\", err);\n        process::exit(1);\n    }\n}", "id": 67, "concepts": ["error handling with match", "option pattern matching", "error handling with try! macro", "error handling with Result enum"], "instruction": "Create a Rust class called `SumAccumulator` that maintains the total sum of numeric values passed to the constructor. The class should support five methods:\n- `add(self, num: i64)`: for adding a single numeric value to the total sum\n- `take(self)`: for returning the current total sum and resetting the internal sum to zero\n- `get(self)`: for returning the current total sum\n- `is_empty(self)`: for testing whether the total sum is zero\n- `add_all(self, nums: Vec<i64>)`: for adding multiple numeric values to the total sum\n\nThe class should provide robust error handling for all the methods, particularly to validate numeric inputs and to ensure the internal state is not modified when an invalid operation is attempted."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async/await, HTTP request, error handling\n\n### Task", "fingerprint": null, "seed": "async fn get_price_ticker() {\n    let exchange = init().await;\n    let req = GetPriceTickerRequest {\n        market_pair: \"eth_btc\".to_string(),\n    };\n    let resp = exchange.get_price_ticker(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 68, "concepts": ["async/await", "HTTP request", "error handling"], "instruction": "Write a Rust function called `fetch_stocks` that uses `async/await` syntax to fetch a list of stock quote information asynchronously from a publicly accessible web service. The function should take a list of stock symbols for input, making asynchronous HTTP requests to the Yahoo! Finance API for each symbol. The function should return a vector of stocks with the following properties:\n\n- `symbol`: The stock symbol for the stock.\n- `price`: The current price of the stock.\n- `change`: The change in price since the previous day.\n- `change_percentage`: The percentage change in price since the previous day.\n- `error`: An optional error message, if an error occurred during the request.\n\nThe function should handle any potential errors and return a vector of stocks containing all the stock information or an error message in the event of any errors."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: struct declaration with a copy attribute, struct access, println formatting\n\n### Task", "fingerprint": null, "seed": "fn copy_test() {\n    {\n        /*\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number); // error\n        */\n\n        #[derive(Copy, Clone)]\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number);\n\n        /*\n        #[derive(Copy, Clone)]\n        struct StringLabel {\n            name: String,\n        }\n        */\n    }\n}", "id": 69, "concepts": ["struct declaration with a copy attribute", "struct access", "println formatting"], "instruction": "Write a Rust function that takes an integer n as input and returns the list of all primes smaller than n. The returned list should only include the integer 2 when n=2 is passed.\n\nThe function should return a list of integers in increasing order.\n\nThe function should use a nested loop to find all the primes in the range [2, n]. For each integer i from 2 to n, the loop should check if i is prime by looping from 2 to i-1 (inclusive).\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(get_primes(10), &[2, 3, 5, 7]);\nassert_eq!(get_primes(100), &[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\nassert_eq!(get_primes(1), &[]);\nassert_eq!(get_primes(2), &[2]);\nassert_eq!(get_primes(3), &[2, 3]);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: float comparison, float division with infinity, integer floor, negative sign check\n\n### Task", "fingerprint": null, "seed": "fn float_test() {\n    assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.);\n    assert_eq!((-1.01f64).floor(), -2.0);\n    assert!((-1. / std::f32::INFINITY).is_sign_negative());\n}", "id": 70, "concepts": ["float comparison", "float division with infinity", "integer floor", "negative sign check"], "instruction": "Create a Rust class called `Range` that represents a half-open interval that includes all numbers from a lower bound but excludes the upper bound. The class should expose two public methods `contains` and `intersection`. The `contains` method accepts a float `x` and checks if `x` falls within the range. The `intersection` method takes another `Range` object as an argument and returns a new `Range` object that is the intersection of the two `Range` objects.\n\nThe class should handle negative bounds and `NaN` values correctly. It should also handle the case when the upper bound is `NaN` and the lower bound is not."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: print as string, println with arguments\n\n### Task", "fingerprint": null, "seed": "fn print_uint(x:uint) {\n\tprintln!(\"{}\",x);\n}", "id": 71, "concepts": ["print as string", "println with arguments"], "instruction": "Create a Rust class called `Sum` that has a single instance variable `value` with default value 0. The class should support the following methods:\n\n- `add(n)`: Increment `value` by `n`.\n- `remove(n)`: Decrement `value` by `n`.\n- `reset()`: Reset `value` to 0.\n- `print()`: Print the current value of `value` as a string.\n- `print_with_new_line()`: Print the current value of `value` as a string, followed by a newline."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: ownership rules, reference counting, mutable references, lifetimes, static variables, macros\n\n### Task", "fingerprint": null, "seed": "fn reference_test() {\n    use std::collections::HashMap;\n    type Table = HashMap<String, Vec<String>>;\n    let mut table = Table::new();\n    table.insert(\n        \"Gesualdo\".to_string(),\n        vec![\n            \"many madrigals\".to_string(),\n            \"Tenebrae Responsoria\".to_string(),\n        ],\n    );\n    table.insert(\n        \"Caravaggio\".to_string(),\n        vec![\n            \"The Musicians\".to_string(),\n            \"The Calling of St. Matthew\".to_string(),\n        ],\n    );\n    table.insert(\n        \"Cellini\".to_string(),\n        vec![\n            \"Perseus with the head of Medusa\".to_string(),\n            \"a salt cellar\".to_string(),\n        ],\n    );\n\n    fn show(table: Table) {\n        for (artist, works) in table {\n            println!(\"works by {}\", artist);\n            for work in works {\n                println!(\"  {}\", work);\n            }\n        }\n    }\n    fn show_with_ref(table: &Table) {\n        for (artist, works) in table {\n            println!(\"works by {}\", artist);\n            for work in works {\n                println!(\"  {}\", work);\n            }\n        }\n    }\n\n    fn sort_works(table: &mut Table) {\n        for (_artist, works) in table {\n            works.sort();\n        }\n    }\n    show_with_ref(&table);\n    assert_eq!(table[\"Gesualdo\"][0], \"many madrigals\"); // OK\n    sort_works(&mut table);\n    assert_eq!(table[\"Gesualdo\"][1], \"many madrigals\"); // OK\n    show(table);\n    // assert_eq!(table[\"Cellini\"][0], \"a salt cellar\"); // error, use of moved value\n\n    // implicitily borrows\n    struct Anime {\n        name: &'static str,\n        bechdel_pass: bool,\n    };\n    let aria = Anime {\n        name: \"Aria: The Animation\",\n        bechdel_pass: true,\n    };\n    let anime_ref = &aria;\n    assert_eq!(anime_ref.name, \"Aria: The Animation\");\n    assert_eq!((*anime_ref).name, \"Aria: The Animation\");\n    assert_eq!((*anime_ref).bechdel_pass, true);\n\n    let mut v = vec![1973, 1968];\n    v.sort();\n    (&mut v).sort();\n\n    let mut x = 10;\n    let mut y = 20;\n    let mut r = &x;\n    let b = true;\n\n    if b {\n        r = &y;\n    }\n\n    assert!(*r == 20);\n\n    struct Point {\n        x: i32,\n        y: i32,\n    }\n    let point = Point { x: 1000, y: 729 };\n    let r: &Point = &point;\n    let rr: &&Point = &r;\n    let rrr: &&&Point = &rr;\n    assert_eq!(rrr.x, 1000);\n    assert_eq!(rrr.y, 729);\n\n    x = 10;\n    y = 10;\n\n    let rx = &x;\n    let ry = &y;\n\n    let rrx = &rx;\n    let rry = &ry;\n    // assert!(rrx <= rry);\n    assert!(rrx == rry);\n    assert!(!std::ptr::eq(rrx, rry));\n    fn factorial(n: usize) -> usize {\n        (1..n + 1).fold(1, |a, b| a * b)\n    }\n    let f = &factorial(6);\n    assert_eq!(f + &1009, 1729);\n\n    {\n        let r;\n        {\n            let x = 1;\n            r = &x;\n            assert_eq!(*r, 1); // OK\n        }\n        // assert_eq!(*r, 1); // error;\n    }\n\n    static mut STASH: &i32 = &128;\n    // fn test_func(p: &i32) { // error\n    // fn test_func<'a>(p: &'a &i32) { // error too, this is the same as the above definition\n    fn test_func(p: &'static i32) {\n        // OK\n        unsafe {\n            STASH = p;\n        }\n    }\n\n    static WORTH_POINTING_AT: i32 = 1000;\n    test_func(&WORTH_POINTING_AT);\n    unsafe {\n        assert_eq!(STASH, &1000);\n    }\n    fn smallest(v: &[i32]) -> &i32 {\n        let mut s = &v[0];\n        for r in &v[1..] {\n            if *r < *s {\n                s = r;\n            }\n        }\n        s\n    }\n    {\n        let parabola = [9, 4, 1, 0, 1, 4, 9];\n        let s = smallest(&parabola);\n        assert_eq!(*s, 0);\n    }\n\n    /*\n    struct S {\n        r: &i32,\n    }\n\n    let s;\n    {\n        let x = 10;\n        s = S { r: &x };\n    }\n    */\n    // assert_eq!(*s, 10); // error\n\n    /*\n    struct S<'a, 'b> {\n        x: &'a i32,\n        y: &'b i32,\n    }\n\n    // fn sum_r_xy<'a, 'b, 'c>(r: &'a &i32, s: S<'b, 'c>) -> i32 {\n    fn sum_r_xy(r: &i32, s: S) -> i32 {\n        r + s.x + s.y\n    }\n    // fn first_third<'a>(point: &'a &[i32; 3]) -> (&'a i32, &'a i32) {\n    fn first_third(point: &[i32; 3]) -> (&i32, &i32) {\n        (&point[0], &point[2])\n    }\n\n    struct StringTable {\n        elements: Vec<String>,\n    }\n\n    impl StringTable {\n        // fn find_by_prefix<'a, 'b>(&'a self, prefix: &'b str) -> Option<&'a String> {\n        fn find_by_prefix(&self, prefix: &str) -> Option<&String> {\n            for i in 0..self.elements.len() {\n                if self.elements[i].starts_with(prefix) {\n                    return Some(&self.elements[i]);\n                }\n            }\n            None\n        }\n    }\n    */\n\n    {\n        /*\n        let v = vec![4, 8, 19, 27, 34, 10];\n        let r = &v;\n        let aside = v;\n        r[0]; // error\n        */\n        let v = vec![4, 8, 19, 27, 34, 10];\n        {\n            let r = &v;\n            r[0];\n        }\n        let aside = v;\n        assert_eq!(aside[0], 4);\n    }\n    {\n        fn extend(vec: &mut Vec<f64>, slice: &[f64]) {\n            for elt in slice {\n                vec.push(*elt);\n            }\n        }\n        let mut wave = Vec::new();\n        let head = vec![0.0, 1.0];\n        let tail = [0.0, -1.0];\n\n        extend(&mut wave, &head);\n        extend(&mut wave, &tail);\n\n        assert_eq!(wave, vec![0.0, 1.0, 0.0, -1.0]);\n\n        // extend(&mut wave, &wave); // error\n    }\n    {\n        let mut x = 10;\n        {\n            let r1 = &x;\n            let r2 = &x;\n            assert_eq!(r1, r2);\n            // x += 10; // error, it is borrowed\n        }\n        x += 10;\n        assert_eq!(x, 20);\n\n        // let m = &mut x; // error, it is also borrowed as immutable\n\n        let mut y = 20;\n        let m1 = &mut y;\n        // let m2 = &mut y; // error, cannot borrow as mutable more than once\n        // let z = y; // error, cannot use 'y' because it was mutably borrowed\n        assert_eq!(&20, m1);\n\n        {\n            let mut w = (107, 109);\n            w.0 = 108;\n            let r = &w;\n            let r0 = &r.0;\n            // let m1 = &mut r.1; // error: can't reborrow shared as mutable\n\n            assert_eq!(r0, &108);\n            assert_eq!(w, (108, 109));\n        }\n    }\n}", "id": 72, "concepts": ["ownership rules", "reference counting", "mutable references", "lifetimes", "static variables", "macros"], "instruction": "Create a Rust function called `count_chars` that takes a string argument `text` and a character argument `char`. The function should result in a dictionary that stores the number of occurrences of each character in `text`, excluding occurrences that are not equal to `char`. The function should return a tuple containing the dictionary and a boolean value indicating whether the character exists in `text`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: misaligned jump, memory initialization, program run\n\n### Task", "fingerprint": null, "seed": "pub fn test_misaligned_jump64() {\n    let buffer = fs::read(\"tests/programs/misaligned_jump64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"misaligned_jump64\".into()]);\n    assert!(result.is_ok());\n}", "id": 73, "concepts": ["misaligned jump", "memory initialization", "program run"], "instruction": "Design a Rust class that implements a controlled flow of a program based on defined jump labels. The class should be able to set the program counter to any known jump label, and then automatically execute the program until it reaches the end, or until an execution error is raised. Design the class so that a misaligned jump will cause an error to be thrown indicating the program is not ready to run, and a memory initialization of a misaligned address will cause a corresponding error."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: parsing program binary data, program execution via default machine, program load and execution to completion, memory out of bound errors\n\n### Task", "fingerprint": null, "seed": "pub fn test_flat_crash_64() {\n    let buffer = fs::read(\"tests/programs/flat_crash_64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, FlatMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    let result = machine.load_program(&buffer, &vec![\"flat_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}", "id": 74, "concepts": ["parsing program binary data", "program execution via default machine", "program load and execution to completion", "memory out of bound errors"], "instruction": "Design a Rust program that implements a virtual machine for a simple programming language with the following rules:\n- A program consists of a series of instructions\n- An instruction consists of a mnemonic (e.g., `push`, `pop`, `add`, etc.)\n- An instruction may optionally include a numeric parameter, which is an integer literal\n- An instruction may optionally include a string parameter, which is a sequence of alphanumeric characters\n\nThe virtual machine should support the following instructions:\n- Push: push the integer value corresponding to the parameter onto the machine's stack\n- Pop: pop an integer value from the machine's stack\n- Add: pop two values from the machine's stack, add them, and push the result back onto the stack\n- Sub: pop two values from the machine's stack, subtract the second number from the first, and push the result back onto the stack\n- Mul: pop two values from the machine's stack, multiply them, and push the result back onto the stack\n- Div: pop two values from the machine's stack, divide the first number by the second, and push the result back onto the stack\n- Mod: pop two values from the machine's stack, compute the remainder of the first number divided by the second, and push the result back onto the stack\n- Not: pop a value from the machine's stack, push the negation of the value back onto the stack\n- Set: pop a string value from the machine's stack, and push the character corresponding to the first character of the string back onto the stack\n- Get: pop a value from the machine's stack, push the character corresponding to the ASCII value back onto the stack\n- Jmp: pop a value from the machine's stack, execute the program from the first instruction with an index equal to the value\n- JmpF: pop two values from the machine's stack, execute the program from the first instruction with an index equal to the first value if the second value is non-zero\n- JmpT: pop two values from the machine's stack, execute the program from the first instruction with an index equal to the first value if the second value is zero\n\nFollow the two-stage parsing rules:\n- The first stage of parsing should locate the end of each instruction, removing comments and whitespace.\n- The second stage of parsing should locate the end of the program, assuming that the instructions are valid.\n\nThe virtual machine should start execution at the first instruction in the program and print the stack after each instruction is completed. If an invalid instruction is encountered, the virtual machine should print an error message and terminate execution."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation, file reading, list comprehension\n\n### Task", "fingerprint": null, "seed": "pub fn test_op_rvc_srli_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_srli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srli_crash_32\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 75, "concepts": ["string manipulation", "file reading", "list comprehension"], "instruction": "Design a Rust function that outputs a list of words from a given text file that are longer than a given minimum length. The function should also result in a file named 'output.txt' with the list of words written to it. The function should provide clear error handling and logging to manage exceptions that might occur during the processing of the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: fuzzing with RustFuzz, reading file content, multiple file input for fuzzing, input validation and assertion\n\n### Task", "fingerprint": null, "seed": "fn run_a_few_inputs() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_few\");\n\n    let project = project(\"run_a_few_inputs\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_few\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() != 4);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"pass-0\"), \"\")\n        .file(corpus.join(\"pass-1\"), \"1\")\n        .file(corpus.join(\"pass-2\"), \"12\")\n        .file(corpus.join(\"pass-3\"), \"123\")\n        .file(corpus.join(\"fail\"), \"fail\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_few\")\n        .arg(corpus.join(\"pass-0\"))\n        .arg(corpus.join(\"pass-1\"))\n        .arg(corpus.join(\"pass-2\"))\n        .arg(corpus.join(\"pass-3\"))\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Running 4 inputs 1 time(s) each.\").and(\n                predicate::str::contains(\"Running: fuzz/corpus/run_few/pass\"),\n            ),\n        )\n        .success();\n}", "id": 76, "concepts": ["fuzzing with RustFuzz", "reading file content", "multiple file input for fuzzing", "input validation and assertion"], "instruction": "Design a Rust program that outputs a list of a specified number of unique random words from a given text file. The program should handle cases where the text file is not found or is empty."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: hashmap of hashmap, stale write handling\n\n### Task", "fingerprint": null, "seed": "fn a_table_should_reject_a_stale_write() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }]);\n  assert_eq!(table.write(0, &[Row { k: 0, v: 2 }]), WriteResult::Stale { cond: 0, max: 1 });\n  let mut vs = [Value::default(); 1];\n  table.read (1, &[0], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }]);\n}", "id": 77, "concepts": ["hashmap of hashmap", "stale write handling"], "instruction": "Design a Rust class that implements a hash map with a hash function, where the values in the map are strings. The class should provide a method `get_value(key)` that retrieves the value associated with the given key, or None if the key is not present. The class also provides a method `set_value(key, value)` that assigns the given key and value to the map, replacing any existing value associated with the key.\n\nThe implementation should handle stale writes properly, where stale writes are writes that are no longer valid due to the hash collision, and the class should also provide a method `remove_value(key)` that removes the value associated with the given key from the map, if it is present."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: database interaction, functional programming, list comprehension\n\n### Task", "fingerprint": null, "seed": "fn\ntest_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nv1234\n=\nvec\n!\n[\n1u8\n2\n3\n4\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nv1234\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nv1234\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 78, "concepts": ["database interaction", "functional programming", "list comprehension"], "instruction": "Design a Rust class called `Database` that supports basic operations of a relational database. The `Database` class should be able to execute SQL queries, and return the results as a list of lists. The `Database` class must provide methods such as `create_table`, `insert_row`, `select_all`, `select_where`, and `execute_query`.\n\nThe `Database` class should be implemented using functional programming techniques, such as list comprehension and higher-order functions. This makes it easier to extend the class to support more complex database operations."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call interface, task setting buffer via system call\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_buffer(target: CAddr, buffer: CAddr) {\n    system_call(SystemCall::TaskSetBuffer {\n        request: (target, buffer),\n    });\n}", "id": 79, "concepts": ["system call interface", "task setting buffer via system call"], "instruction": "Write a Rust function that takes a list of tasks, each of which is described by a tuple of the form (name, memory, cpu_time, io_time). The function should return the list of task names that are eligible for execution based on the available resource thresholds."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: nested conditional destructuring, named tuple destructuring, optional value handling and type conversion, error handling, string concatenation\n\n### Task", "fingerprint": null, "seed": "fn\ntest_option\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\nSome\n(\n\"\nhello\nworld\n!\n\"\n)\n;\nlet\nb\n=\nSome\n(\nvec\n!\n[\n1u8\n2\n3\n4\n]\n)\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\ns\n]\n)\n?\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nb\n]\n)\n?\n;\nlet\nmut\nstmt\n=\ndb\n.\nprepare\n(\n\"\nSELECT\nt\nb\nFROM\nfoo\nORDER\nBY\nROWID\nASC\n\"\n)\n?\n;\nlet\nmut\nrows\n=\nstmt\n.\nquery\n(\n[\n]\n)\n?\n;\n{\nlet\nrow1\n=\nrows\n.\nnext\n(\n)\n?\n.\nunwrap\n(\n)\n;\nlet\ns1\n:\nOption\n<\nString\n>\n=\nrow1\n.\nget_unwrap\n(\n0\n)\n;\nlet\nb1\n:\nOption\n<\nVec\n<\nu8\n>\n>\n=\nrow1\n.\nget_unwrap\n(\n1\n)\n;\nassert_eq\n!\n(\ns\n.\nunwrap\n(\n)\ns1\n.\nunwrap\n(\n)\n)\n;\nassert\n!\n(\nb1\n.\nis_none\n(\n)\n)\n;\n}\n{\nlet\nrow2\n=\nrows\n.\nnext\n(\n)\n?\n.\nunwrap\n(\n)\n;\nlet\ns2\n:\nOption\n<\nString\n>\n=\nrow2\n.\nget_unwrap\n(\n0\n)\n;\nlet\nb2\n:\nOption\n<\nVec\n<\nu8\n>\n>\n=\nrow2\n.\nget_unwrap\n(\n1\n)\n;\nassert\n!\n(\ns2\n.\nis_none\n(\n)\n)\n;\nassert_eq\n!\n(\nb\nb2\n)\n;\n}\nOk\n(\n(\n)\n)\n}", "id": 80, "concepts": ["nested conditional destructuring", "named tuple destructuring", "optional value handling and type conversion", "error handling", "string concatenation"], "instruction": "Create a Rust program that prompts the user to enter two positive integers `a` and `b`. The program should then determine whether `a` is divisible by `b`, and, if so, print the quotient and remainder. If `b` is 0, the program should print an error message stating that the divisor cannot be 0."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: gtk::TreeViewColumn, gtk::TreeViewColumn::pack_start, gtk::CellRendererText, gtk::CellRendererText::add_attribute\n\n### Task", "fingerprint": null, "seed": "fn append_text_column(tree: &mut gtk::TreeView) {\n    let column = gtk::TreeViewColumn::new().unwrap();\n    let cell = gtk::CellRendererText::new().unwrap();\n\n    column.pack_start(&cell, true);\n    column.add_attribute(&cell, \"text\", 0);\n    tree.append_column(&column);\n}", "id": 81, "concepts": ["gtk::TreeViewColumn", "gtk::TreeViewColumn::pack_start", "gtk::CellRendererText", "gtk::CellRendererText::add_attribute"], "instruction": "Develop a Rust class `GtkText` that allows users to create and manage text widgets in a GTK+ window. The class should incorporate a text entry area and a text output area, with the text output area utilizing the TreeView widget. The class should allow users to set the maximum length of the text in the text entry area, and the text output area should display a list of lines of text. Each line of text should be displayed in a TreeView widget cell using the `CellRendererText` widget. To set the text, users should use the `update_text` method, which should update the displayed text in the text output area to the input text provided."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file system manipulation with SYSFS, unsafe code for external dependency\n\n### Task", "fingerprint": null, "seed": "pub fn write_board(board_name: String, contents: String) -> Result<(), String> {\n    let mut configurator = Configurator::new();\n    unsafe {\n        configurator.set_working_folder(WORKING_FOLDER.clone());\n    }\n    configurator.write_board(board_name, contents)\n}", "id": 82, "concepts": ["file system manipulation with SYSFS", "unsafe code for external dependency"], "instruction": "Create a Rust class that simulates a file system under `/sys/` on Linux. The class should encapsulate all the required SYSFS file paths to manage files and directories under `/sys/`. Manage the file as a file with an associated name and `bytes`. The class should expose the following methods:\n\n- `create_file`\n- `create_directory`\n- `delete_file`\n- `delete_directory`\n- `rename_file`\n- `rename_directory`\n- `read_file`\n- `read_directory`"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file system manipulation with std::path, command execution with cargo-fuzz, directory creation with fs::create_dir, file creation with fs::create_file, file reading with fs::read, file writing with fs::write, file deletion with fs::remove_file\n\n### Task", "fingerprint": null, "seed": "fn init_finds_parent_project() {\n    let project = project(\"init_finds_parent_project\").build();\n    project\n        .cargo_fuzz()\n        .current_dir(project.root().join(\"src\"))\n        .arg(\"init\")\n        .assert()\n        .success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n}", "id": 83, "concepts": ["file system manipulation with std::path", "command execution with cargo-fuzz", "directory creation with fs::create_dir", "file creation with fs::create_file", "file reading with fs::read", "file writing with fs::write", "file deletion with fs::remove_file"], "instruction": "Develop a Rust program that simulates a file system traversal, reading and writing to files, and creating and deleting files and directories. The program should accept user input to specify the path to the root directory and the file system operations to be performed. The program should print the file system after each operation."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: channel receive from a raw pointer, unsafe code, type mismatches, panic at runtime\n\n### Task", "fingerprint": null, "seed": "pub fn channel_take_raw(target: CAddr) -> u64 {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Raw(v) => return v,\n        _ => panic!(),\n    };\n}", "id": 86, "concepts": ["channel receive from a raw pointer", "unsafe code", "type mismatches", "panic at runtime"], "instruction": "Develop a Rust function `merge_sorted_arrays` that takes two sorted arrays `a` and `b` as arguments and returns a new array that is the sorted combination of the two inputs. The function should be implemented in an unsafe fashion using `unsafe` code, which allows the Rust compiler to perform certain checks to ensure the code is correct while eliminating the possibility of memory safety issues.\n\nImplement the function so that it panics if the two input arrays are of different lengths or if there is an error in the merging process."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: channel receive from a tuple, control flow in a function, panic, handling channel messages\n\n### Task", "fingerprint": null, "seed": "pub fn channel_take_cap(target: CAddr) -> CAddr {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Cap(v) => return v.unwrap(),\n        _ => panic!(),\n    };\n}", "id": 87, "concepts": ["channel receive from a tuple", "control flow in a function", "panic", "handling channel messages"], "instruction": "Implement a Rust class that simulates a 1D world with multiple types of creatures that move around and interact with each other. The class should have a method `simulate_world()` that runs a simulation of the world with specified parameters. The `simulate_world()` method should spawn three actors: a `Plankton` actor, a `Fish` actor, and a `Bacteria` actor. Each actor runs in its own thread and has its own independent state. The `simulate_world()` method should run until the world has no more `Plankton`, `Fish`, or `Bacteria` actors.\n\nAssume the following state of the world at the beginning of the simulation is represented by a `World` object with four `Creature` objects (each `Creature` has a `name` and `state`).\n```py\nworld = World(\n    [\n        Creature('Plankton', 'green'),\n        Creature('Bacteria', 'brown'),\n        Creature('Fish', 'red'),\n        Creature('Fish', 'blue')\n    ]\n)\n```\nThe `World` class is defined as follows:\n```py\nstruct World {\n    world: Vec<Creature>,\n    channels: {\n        Plankton: (Sender<()>, Receiver<()>),\n        Fish: (Sender<()>, Receiver<()>),\n        Bacteria: (Sender<()>, Receiver<()>)\n    }\n}\n```\nThe `Creature` class is defined as follows:\n```py\nstruct Creature {\n    name: String,\n    state: String,\n}\n```\nThe `simulate_world()` method should run for a specified amount of time (to simulate the world) and output the state of the world after every 2 seconds. For example, the output of the above world at the beginning of the simulation should be:\n```py\nPlankton green\nBacteria brown\nFish red\nFish blue\n```\nThe output of the world at the end of the simulation should be:\n```py\nPlankton green\nBacteria brown\nFish red\nFish blue\n```\nThe `simulate_world()` method also should handle the following scenarios:\n- a `Plankton` actor enters the world\n- a `Fish` actor enters the world\n- a `Bacteria` actor enters the world\n- a `Plankton` actor generates `Egg` and sends it to the `Fish` actor\n- a `Fish` actor generates `Fruit` and sends it to the `Plankton` actor\n- a `Bacteria` actor generates `Fruit` and sends it to the `Plankton` actor\n- a `Fish` actor generates `Fruit` and sends it to the `Bacteria` actor\n- a `Bacteria` actor generates `Egg` and sends it to the `Fish` actor"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: asynchronous programming with Tokio, asynchronous function execution, asynchronous HTTP requests\n\n### Task", "fingerprint": null, "seed": "async fn get_historic_trades() {\n    let exchange = init().await;\n    let req = GetHistoricTradesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        paginator: Some(Paginator {\n            limit: Some(100),\n            ..Default::default()\n        }),\n    };\n    let resp = exchange.get_historic_trades(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 88, "concepts": ["asynchronous programming with Tokio", "asynchronous function execution", "asynchronous HTTP requests"], "instruction": "Create a Rust function that makes asynchronous HTTP requests to external APIs and combines their responses. It should use the Tokio asynchronous runtime to execute concurrent requests, raise errors for failed requests, and return a single vector of responses. The function should contain one asynchronous function called `fetch_data`, which accepts a vector of URLs and returns a `Future` result of a vector of HTTP responses. The function should also contain a function called `combine_responses`, which receives an iterator of HTTP responses and combines them into a single vector of responses."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: asynchronous programming with async/await, futures and await, creating an asynchronous function\n\n### Task", "fingerprint": null, "seed": "async fn order_book() {\n    let exchange = init().await;\n    let req = OrderBookRequest {\n        market_pair: \"eth_btc\".to_string(),\n    };\n    let resp = exchange.order_book(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 89, "concepts": ["asynchronous programming with async/await", "futures and await", "creating an asynchronous function"], "instruction": "Develop a Rust function `async_find_nth_prime(n)` that returns the nth prime number, where n is a positive integer. The function should be asynchronous and utilize async/await for handling the delay, and futures for managing the asynchronous execution. The function should also utilize await in the main function to wait for the asynchronous result before returning."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: runtime error testing, comparison with `Option::Some`, memory access validation\n\n### Task", "fingerprint": null, "seed": "pub fn test_wxorx_crash_64() {\n    let buffer = fs::read(\"tests/programs/wxorx_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"wxorx_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}", "id": 90, "concepts": ["runtime error testing", "comparison with `Option::Some`", "memory access validation"], "instruction": "Create a Rust function `throw_runtime_error` that should throw a runtime error if called with an argument that does not satisfy the condition `x > 0`. The function should take a `i32` and return a `Result`, where the error condition can be expressed as `Err(String::from(\"Invalid value\"))`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: message passing and inter-process communication, message passing over system calls, payload transfer\n\n### Task", "fingerprint": null, "seed": "pub fn channel_put<T: Any + Clone>(target: CAddr, value: T) {\n    system_call_put_payload(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Payload)\n    }, value);\n}", "id": 91, "concepts": ["message passing and inter-process communication", "message passing over system calls", "payload transfer"], "instruction": "Create a Rust function that creates a message of a fixed size, given an input of bytes. The message should consist of a header containing the message size followed by the payload. The header should be padded with zeros to ensure a constant message size. The payload should be truncated to the size of the message."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file I/O, file parsing, decoding of binary data structures, error handling\n\n### Task", "fingerprint": null, "seed": "fn decode_ppm_image(cursor: &mut Cursor<Vec<u8>>) -> Result<Image, Box<std::error::Error>> {\n    let mut image = Image { \n        width : 0,\n        height: 0,\n        pixels: vec![]\n    };\n\n    // read header\n    let mut c: [u8; 2] = [0; 2];\n    cursor.read(&mut c)?;\n    match &c {\n        b\"P6\" => { },\n          _   => { bail!(\"error\") }\n    }\n    \n    let w  = read_num(cursor)?;\n    let h  = read_num(cursor)?;\n    let cr = read_num(cursor)?;\n\n    print!(\"width: {}, height: {}, color range: {}\\n\", w, h, cr);\n\n\t// TODO: Parse the image here\n\n    let mut pxls:Vec<Vec<Pixel>> = vec![];\n\n    let mut buff: [u8; 1] = [0];\n    loop{\n        cursor.read(&mut buff)?;\n        match &buff {\n            b\" \" | b\"\\t\" | b\"\\n\" => {},\n              _                  => { cursor.seek(std::io::SeekFrom::Current(-1)); break; }\n        };\n    };\n\n    for x in 0..h {\n        let mut row: Vec<Pixel> = vec!();\n        for y in 0..w {\n            let mut mv: Vec<u8> = vec![];\n            for mut z in 0..3 {\n                mv.push(cursor.read_u8()?);\n            }\n\n            let px = Pixel {\n                R: mv[0] as u32,\n                G: mv[1] as u32,\n                B: mv[2] as u32\n            };\n            row.push(px);\n        }\n        pxls.insert(0, row);\n    }\n\n    image = Image {\n        width : w,\n        height: h,\n        pixels: pxls\n    };\n\n    Ok(image)\n}", "id": 92, "concepts": ["file I/O", "file parsing", "decoding of binary data structures", "error handling"], "instruction": "Create a Rust function that extracts information from a binary file. This function should accept a filename and return a string containing the first 16 bytes of the file as a hexidecimal string, separated by spaces, and the first 8 bytes of the file as a base64 string, separated by spaces.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(extract_bin_info(\"file.bin\"), \"53 61 6d 70 6c 65 20 44 4f 43 6f 64 65 20 43 48\");\nassert_eq!(extract_bin_info(\"file.bin\"), \"S a m p l e D O C o d e C H\");\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call dispatch, comparison with raw values, system call convention\n\n### Task", "fingerprint": null, "seed": "pub fn channel_put_raw(target: CAddr, value: u64) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Raw(value))\n    });\n}", "id": 93, "concepts": ["system call dispatch", "comparison with raw values", "system call convention"], "instruction": "Implement a Rust function `call_syscall` that calls a system call. It should accept three arguments: `syscall`, a string containing the name of the syscall, `args`, a list of arguments to the syscall, and `expected_return`, a string containing the expected return value of the syscall. The function should report an error and return `None` if the expected return value is not matched. Consider the syscall naming convention and input validation."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: URL parser and parsing, MySQL driver URL parsing, Postgres driver URL parsing\n\n### Task", "fingerprint": null, "seed": "pub fn get_driver(url: &str) -> MigrateResult<Box<Driver>> {\n    // Mysql driver does not allow to connect using a url so we need to parse it\n    let mut parser = UrlParser::new();\n    parser.scheme_type_mapper(db_scheme_type_mapper);\n    let parsed = parser.parse(url).unwrap();\n\n    match parsed.scheme.as_ref() {\n        \"postgres\" => postgres::Postgres::new(url).map(|d| Box::new(d) as Box<Driver>),\n        \"mysql\" => mysql::Mysql::new(parsed).map(|d| Box::new(d) as Box<Driver>),\n        _ => Err(invalid_url(url))\n    }\n}", "id": 94, "concepts": ["URL parser and parsing", "MySQL driver URL parsing", "Postgres driver URL parsing"], "instruction": "Create a program that parses a URL. The program should output the parsed URL components as JSON. The program should also support parsing URLs from a MySQL or Postgres database using a corresponding driver."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: thread spawning, environment variable checking, thread joining\n\n### Task", "fingerprint": null, "seed": "fn main() {\n  let mut prod_env = \"\".to_string();\n\n  let ws_server_thread = thread::Builder::new().name(\"ws_server\".to_string()).spawn(move || {\n      println!(\"Starting websocket server..\");\n      listen(\"127.0.0.1:3012\", |out| { Server { out: out } }).unwrap()\n  }).unwrap();\n\n  thread::sleep(time::Duration::from_millis(1000));\n  match env::var(\"PROD_ENV\".to_string()) {\n      Ok(val) => prod_env = val,\n      Err(e) => println!(\"Operating in dev mode due to: {}\", e),\n  }\n\n  if prod_env != \"\" {\n    let app_router_thread = thread::Builder::new().name(\"app_router\".to_string()).spawn(move || {\n        let mut app_router = Nickel::new();\n        println!(\"Starting app router..\");\n        app_router.mount(\"/controller/\", StaticFilesHandler::new(\"app/controller/\"));\n        app_router.mount(\"/display/\", StaticFilesHandler::new(\"app/display/\"));\n        app_router.listen(\"127.0.0.1:6767\").unwrap();\n    }).unwrap();\n    let _ = app_router_thread.join();\n  }\n\n  let _ = ws_server_thread.join();\n  println!(\"Server closing down..\");\n}", "id": 95, "concepts": ["thread spawning", "environment variable checking", "thread joining"], "instruction": "Develop a Rust program that creates two threads: a parent thread and a child thread. The parent thread should wait for the child thread to finish before exiting. The child thread should print a message to indicate its entry into the parent thread. The parent thread should print a message indicating its exit from the child thread. The child thread should randomly block for a random period of time between 1 and 5 seconds. The parent thread should allow the child thread to run for an additional 5 seconds before printing a final message to indicate its exit."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: cargo command usage, comparison with string, assertion of file existence\n\n### Task", "fingerprint": null, "seed": "fn init_twice() {\n    let project = project(\"init_twice\").build();\n\n    // First init should succeed and make all the things.\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n\n    // Second init should fail.\n    project\n        .cargo_fuzz()\n        .arg(\"init\")\n        .assert()\n        .stderr(predicates::str::contains(\"File exists (os error 17)\").and(\n            predicates::str::contains(format!(\n                \"failed to create directory {}\",\n                project.fuzz_dir().display()\n            )),\n        ))\n        .failure();\n}", "id": 96, "concepts": ["cargo command usage", "comparison with string", "assertion of file existence"], "instruction": "Develop a Rust function that searches for a file whose name is the same as the first command-line argument. If the file is found, the function should read its contents into a string and return that string. Otherwise, the function should raise an error."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: type-erased system call, function composition, syntax of system call\n\n### Task", "fingerprint": null, "seed": "fn system_call_take_payload<T: Any + Clone>(message: SystemCall) -> (SystemCall, T) {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        system_call_raw();\n\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &*payload_addr;\n        assert!(buffer.payload_length != 0 && buffer.payload_length == size_of::<T>());\n\n        (buffer.call.take().unwrap(), payload_data.clone())\n    }\n}", "id": 97, "concepts": ["type-erased system call", "function composition", "syntax of system call"], "instruction": "Develop a Rust program that implements an untrusted system call, the `get_random` function. This function should be a wrapper around the system call `getrandom` that takes a buffer and a length as input and returns the number of bytes successfully read into the buffer. This program should use the `getrandom` system call to read a random number of bytes from `/dev/urandom` and check whether the number of bytes read was less than the length provided by the user.\n\nUtilize Rust's type system to avoid errors due to the use of a wrong type for the parameter `buffer` of the function `get_random`. This function should use the function `rand` provided by the `rand` crate to generate a random number of bytes.\n\nSolve the problem without any external resources."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call, C-like function call convention, syntax of system call\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_inactive(target: CAddr) {\n    system_call(SystemCall::TaskSetInactive {\n        request: target\n    });\n}", "id": 98, "concepts": ["system call", "C-like function call convention", "syntax of system call"], "instruction": "Design a Rust program that prints the current time of the system the program runs on. The program should call a C function named `print_current_time` that uses the system call `time` from the standard library. The function should return the current time in seconds."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: type comparison, precondition checking, function definition and syntax\n\n### Task", "fingerprint": null, "seed": "fn debug_check_layout(layout: Layout) {\n    debug_assert!(layout.size() <= LARGEST_POWER_OF_TWO);\n    debug_assert!(layout.size() > 0);\n}", "id": 99, "concepts": ["type comparison", "precondition checking", "function definition and syntax"], "instruction": "Design a Rust function `is_valid_ipv4_address(address)` that determines if an input string is a valid IPv4 address (e.g., \"192.0.0.1\" or \"192.168.3.11\"). The function should return true if the address is valid, otherwise false.\n\nThe input string should follow the following format:\n\n- The address can contain one or more sets of 1-3 digits, separated by dots.\n- Each set of digits should be within the range 0 <= digit <= 255.\n- Leading zeros are allowed, but not required.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert!(is_valid_ipv4_address(\"192.0.0.1\"));\nassert!(is_valid_ipv4_address(\"192.168.3.11\"));\nassert!(!is_valid_ipv4_address(\"192.0.0.1.1\"));\nassert!(!is_valid_ipv4_address(\"192.168.3.11.1\"));\nassert!(!is_valid_ipv4_address(\"192.0.0\"));\nassert!(!is_valid_ipv4_address(\"192.0.0.100\"));\nassert!(!is_valid_ipv4_address(\"192.0.0.0\"));\nassert!(!is_valid_ipv4_address(\"192.0.0.256\"));\nassert!(!is_valid_ipv4_address(\"192.0.0.256.1\"));\nassert!(!is_valid_ipv4_address(\"192.0.0.256.1.1.1\"));\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: quicksort algorithm, partitioning, function recursion, logging of intermediate results\n\n### Task", "fingerprint": null, "seed": "pub fn quick_sort<T: PartialOrd + Debug>(v: &mut [T]) {\n    if v.len() <= 1 {\n        return;\n    }\n    let p = pivot(v);\n    println!(\"{:?}\", v);\n    let (a, b) = v.split_at_mut(p);\n    quick_sort(a);\n    quick_sort(&mut b[1..]);\n}", "id": 100, "concepts": ["quicksort algorithm", "partitioning", "function recursion", "logging of intermediate results"], "instruction": "Design a Rust program that implements the quicksort algorithm."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call, C-like parameter passing, memory mapping of buffers\n\n### Task", "fingerprint": null, "seed": "pub fn map_raw_page_free(vaddr: usize, untyped: CAddr, toplevel_table: CAddr, page: CAddr) {\n    system_call(SystemCall::MapRawPageFree {\n        untyped: untyped,\n        toplevel_table: toplevel_table,\n        request: (vaddr, page),\n    });\n}", "id": 101, "concepts": ["system call", "C-like parameter passing", "memory mapping of buffers"], "instruction": "Design a Rust function that takes an input string and outputs two integers: the number of occurrences of 's' in the string and the number of occurrences of 't' in the string. Utilize system calls to read from and write to the standard input and output streams."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: cli output, shell completion, async function definition, syntax of clap\n\n### Task", "fingerprint": null, "seed": "async fn run_completions(shell: ShellCompletion) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing completions\");\n\n\tfn generate(generator: impl Generator) {\n\t\tlet mut cmd = Args::command();\n\t\tclap_complete::generate(generator, &mut cmd, \"watchexec\", &mut std::io::stdout());\n\t}\n\n\tmatch shell {\n\t\tShellCompletion::Bash => generate(Shell::Bash),\n\t\tShellCompletion::Elvish => generate(Shell::Elvish),\n\t\tShellCompletion::Fish => generate(Shell::Fish),\n\t\tShellCompletion::Nu => generate(clap_complete_nushell::Nushell),\n\t\tShellCompletion::Powershell => generate(Shell::PowerShell),\n\t\tShellCompletion::Zsh => generate(Shell::Zsh),\n\t}\n\n\tOk(())\n}", "id": 102, "concepts": ["cli output", "shell completion", "async function definition", "syntax of clap"], "instruction": "Develop a Rust CLI program that computes the fibonacci numbers for the given numbers of terms. The CLI should accept two integer arguments from the command line. The first is the number of terms to compute and the second is the number of terms to skip before displaying the output. The CLI should output the computed fibonacci numbers in a comma separated list. The program should use proper error handling to raise an error if the number of terms to skip is greater than the number of terms to compute."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over a collection, dictionary construction, file writing, error handling with exceptions\n\n### Task", "fingerprint": null, "seed": "fn run() -> Result<(), Box<dyn std::error::Error>> {\n    let by_version = generate_thanks()?;\n\n    let mut all_time = by_version.values().next().unwrap().clone();\n    for map in by_version.values().skip(1) {\n        all_time.extend(map.clone());\n    }\n\n    site::render(by_version, all_time)?;\n\n    Ok(())\n}", "id": 103, "concepts": ["iterating over a collection", "dictionary construction", "file writing", "error handling with exceptions"], "instruction": "Develop a Rust program that reads a text file and outputs two new files, one for the unique words and another for the word counts. The output files should be saved in the current folder as `{input_file_name}_words.txt` and `{input_file_name}_counts.txt` respectively.\n\nFor example, given the following text file:\n\n```\nhello world hello world\nhello world hello world\n```\n\nOutput two files, both in the same folder with the following content:\n\n```\nworld 6\nhello 3\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: hash map, hash map lookup, function composition, syntax of map and array literals\n\n### Task", "fingerprint": null, "seed": "fn a_table_should_read_what_was_put() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }]);\n  let mut vs = [Value::default(); 1];\n  table.read (1, &[0], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }]);\n}", "id": 104, "concepts": ["hash map", "hash map lookup", "function composition", "syntax of map and array literals"], "instruction": "Write a Rust function `check_anagrams` that takes two strings as inputs and returns `True` if the strings are anagrams of each other, and `False` otherwise. An anagram of a string is a string formed by rearranging the letters of another string. The string lengths should be the same in both strings.\n\nFor example, given the strings `\"listen\"` and `\"silent\"` as inputs, the function should return `True`. Implement the function using a hash map to store character frequencies in each string, then iterate over the second string and check if the character frequencies in the second string can be derived from the first string by swapping some of the characters."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: integer division and modulo, type casting, conditional execution with parentheses\n\n### Task", "fingerprint": null, "seed": "fn de_l(raw: f32, even: bool) -> i32 {\n    if even && raw < 0.0 {\n        (raw.ceil() - 1.0) as i32\n    } else {\n        raw.floor() as i32\n    }\n}", "id": 105, "concepts": ["integer division and modulo", "type casting", "conditional execution with parentheses"], "instruction": "Develop a Rust program `check_divisibility()` that accepts two positive integers as inputs and determines if the second integer is divisible by the first integer. The program should handle invalid inputs gracefully, such as division by zero, input type conversion errors, or negative input integers. Additionally, ensure the program is efficient in terms of execution time."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: object-oriented programming, polymorphism and inheritance, mutation with immutable references, resource management with Rc\n\n### Task", "fingerprint": null, "seed": "fn rc_test() {\n    use std::rc::Rc;\n\n    let s: Rc<String> = Rc::new(\"shirataki\".to_string());\n    let t: Rc<String> = s.clone();\n    let u: Rc<String> = s.clone();\n\n    assert!(s.contains(\"shira\"));\n    assert_eq!(t.find(\"taki\"), Some(5));\n    println!(\"{} are quite chewy, almost bouncy, but lack flavor\", u);\n\n    // s.push_str(\" noodles\"); // error\n}", "id": 106, "concepts": ["object-oriented programming", "polymorphism and inheritance", "mutation with immutable references", "resource management with Rc"], "instruction": "Develop a Rust program that accepts an input file and prints its contents to the console using a custom implementation of the iterator trait. The program should be able to handle unusual file formats such as a CSV or JSON file. The iterator should be constructed using a composition of multiple iterators. For example, if the input file is in JSON format, the iterator should be able to print the key-value pairs of the file as (key, value) pairs."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: named arguments in cli parsing, creating a unique fuzz directory, rust-lang/rust-fuzz cli usage\n\n### Task", "fingerprint": null, "seed": "fn run_with_different_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\n        \"project_likes_to_move_it\",\n        Some(\"dir_likes_to_move_it_move_it\"),\n    );\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"you_like_to_move_it\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|_data: &[u8]| {\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"you_like_to_move_it\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 2 runs\"))\n        .success();\n}", "id": 107, "concepts": ["named arguments in cli parsing", "creating a unique fuzz directory", "rust-lang/rust-fuzz cli usage"], "instruction": "Develop a Rust program that accepts an input file path and target directory to generate fuzz inputs for the `cargo-fuzz` tool. The program should check whether the target directory exists, and if not, create a unique directory with a timestamp prefix. Then check if the input file exists, and if not, use the `cargo-fuzz` tool to fuzz the program."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file reading and access, error handling, function decomposition with results\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_read(file_path: &str) -> Result<String, String> {\n    let mut file = File::open(file_path).map_err(|e| e.to_string())?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)\n        .map_err(|e| e.to_string())?;\n    Ok(contents)\n}", "id": 108, "concepts": ["file reading and access", "error handling", "function decomposition with results"], "instruction": "Develop a Rust class `FileParser` that reads and accesses data from a CSV file. The class should accept a file path as input and initialize the internal state.\n\nThe class should expose the following methods for reading and accessing the data:\n- `get_all_data_as_dict(self)`: Returns a list of dictionaries, where each dictionary represents a row of the CSV file.\n- `get_all_data_as_records(self)`: Returns a list of records, where each record is a tuple of values in a row of the CSV file.\n- `get_column_names(self)`: Returns a list of column names from the first row of the CSV file.\n- `get_column_data_as_dict(self, col_name)`: Returns a list of dictionaries, where each dictionary represents a row of the CSV file, and only includes the values of the specified column.\n- `get_column_data_as_records(self, col_name)`: Returns a list of records, where each record is a tuple of values in a row of the CSV file, and only includes the values of the specified column.\n- `get_row_data_as_dict(self, row_num)`: Returns a dictionary representing a row of the CSV file at a specified index, with column names as keys.\n- `get_row_data_as_records(self, row_num)`: Returns a tuple of values in a row of the CSV file at a specified index.\n\nNote that the methods should handle cases where the input file is missing or otherwise inaccessible, or where the specified column name does not exist in the CSV file. Additionally, implement error handling and logging to manage exceptions that might occur during the processing of the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: match, pattern matching, polymorphism and inheritance, tree traversal\n\n### Task", "fingerprint": null, "seed": "fn map_message(tok: IRCToken) -> Result<IRCToken, ~str> {\n    // Sequence(~[Sequence(~[Sequence(~[Unparsed(~\":\"), PrefixT(irc::Prefix{nick: ~\"tiffany\", user: ~\"lymia\", host: ~\"hugs\"}), Ignored])]), Unparsed(~\"PRIVMSG\"), Sequence(~[Params(~[~\"##codelab\", ~\"hi\"])])])\n    match tok {\n        Sequence([Sequence([Sequence([Unparsed(~\":\"), PrefixT(prefix), Ignored])]), Unparsed(cmd), Sequence([Params(params)])]) =>\n            Ok(MessageT(Message {prefix: Some(prefix), command: cmd, params: params})),\n        Sequence([Sequence([]), Unparsed(cmd), Sequence([Params(params)])]) => \n            Ok(MessageT(Message {prefix: None, command: cmd, params: params})),\n        _ => Err(fmt!(\"Malformed message: %?\", tok))\n    }\n}", "id": 110, "concepts": ["match", "pattern matching", "polymorphism and inheritance", "tree traversal"], "instruction": "Design a Rust program to implement a function to convert an expression tree to an equivalent arithmetic expression.\nThe expression tree is a hierarchical structure that represents an arithmetic expression in a tree-like structure with nodes representing operators and leaves representing operands. The nodes of the expression tree can be binary, unary, or n-ary in terms of their arity.\n\nThe function should take a reference to the root of an expression tree constructed using the following structure:\n\n```rust\nenum Expr {\n    Add(Box<Expr>, Box<Expr>),\n    Sub(Box<Expr>, Box<Expr>),\n    Mul(Box<Expr>, Box<Expr>),\n    Div(Box<Expr>, Box<Expr>),\n    Pow(Box<Expr>, Box<Expr>),\n    Neg(Box<Expr>),\n    Num(f64),\n}\n```\n\nThe function should return an equivalent arithmetic expression represented as a String, with each operator enclosed in parentheses and the operands in order. For example, the function should convert the following expression tree to the equivalent arithmetic expression:\n\n```rust\nlet tree = Expr::Mul(\n    Box::new(Expr::Div(\n        Box::new(Expr::Neg(Box::new(Expr::Num(-5.0)))),\n        Box::new(Expr::Num(2.0)),\n    )),\n    Box::new(Expr::Neg(Box::new(Expr::Num(-2.0)))),\n);\n```\n\nto the following arithmetic expression:\n\n```\n( -5.0 / 2.0 ) * -2.0\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: ownership, ownership transfer, polymorphism and inheritance, mutation with forbid\n\n### Task", "fingerprint": null, "seed": "fn ownership_test() {\n    let mut v = Vec::new();\n    for i in 101..106 {\n        v.push(i.to_string());\n    }\n\n    let fifth = v.pop().unwrap();\n    assert_eq!(fifth, \"105\");\n\n    let second = v.swap_remove(1);\n    assert_eq!(second, \"102\");\n\n    let third = std::mem::replace(&mut v[2], \"substitute\".to_string());\n    assert_eq!(third, \"103\");\n\n    assert_eq!(v, vec![\"101\", \"104\", \"substitute\"]);\n\n    struct Person {\n        name: Option<String>,\n        birth: Option<i32>,\n    };\n\n    let mut composers = Vec::new();\n    composers.push(Person {\n        name: Some(\"Palestrina\".to_string()),\n        birth: Some(1525),\n    });\n\n    // let first_name = composers[0].name // error\n\n    let first_name = std::mem::replace(&mut composers[0].name, None);\n    assert_eq!(first_name, Some(\"Palestrina\".to_string()));\n    assert_eq!(composers[0].name, None);\n    let birth = composers[0].birth.take();\n    assert_eq!(birth, Some(1525));\n    assert_eq!(composers[0].birth, None);\n}", "id": 112, "concepts": ["ownership", "ownership transfer", "polymorphism and inheritance", "mutation with forbid"], "instruction": "Design a Rust function `check_inheritance` that determines whether a class inherits from a specific base class. The function should take two arguments: a `child_class`, and `base_class`, both of type `String` representing the fully-qualified names of the classes. The function should return a boolean value indicating whether the `child_class` inherits from the `base_class`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: simple if-else statement, return type and return value, println! macro\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    println!(\"Common letters in the box ids: {}\",\n             match find_common_id() {\n                 Some(s) => s,\n                 None => \"NA\".to_string()\n             });\n}", "id": 113, "concepts": ["simple if-else statement", "return type and return value", "println! macro"], "instruction": "Write a program that reads a single-line input with parentheses and correctly outputs the corresponding balanced braces for the input string. The program should satisfy the following assertions:\n\n```rust\nassert_eq!(balanced_braces(\"()\"), \"()\");\nassert_eq!(balanced_braces(\"(()(()))\"), \"(()(()))\");\nassert_eq!(balanced_braces(\"(((())(()))(\"), \"((())(()))(\");\nassert_eq!(balanced_braces(\"(({[(())]})\"), \"(({[(())]})\");\nassert_eq!(balanced_braces(\")({[(())]})\"), \")({[(())]})\");\n```\n/languages/python/solutions/decoding-compressed-data/README.md\n# Decoding Huffman-compressed data\n\nThe `huffman_decompress` function takes two arguments:\n\n- `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data\n- `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character)\n\nThe function should return the original uncompressed data as `bytes`.\n\nDefine the `HuffmanNode` class yourself as a general tree structure with a `children` list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, object instantiation, method invocation, return value processing\n\n### Task", "fingerprint": null, "seed": "pub fn force_reset() -> Result<(), ()> {\n    let mut configurator = Configurator::new();\n    configurator.force_reset();\n    Ok(())\n}", "id": 114, "concepts": ["object-oriented programming", "object instantiation", "method invocation", "return value processing"], "instruction": "Create a Rust function that retrieves and parses a JSON payload from a RESTful API resource. The function should return a dictionary of parsed keys and values, or raise an exception if the call is unsuccessful or the response has an invalid format.\n\nThe function should attempt to parse the response as both a JSON object and a JSON array, and then return the result with the maximum number of parsed elements. If the result cannot be parsed as either a JSON object or array, the function should return an empty dictionary.\n\nFor example, the function should pass the following assertions:\n```rust\nassert_eq!(parse_json_payload(\"{\\\"a\\\": 1, \\\"b\\\": 2}\").unwrap(), {\"a\": 1, \"b\": 2});\nassert_eq!(parse_json_payload(\"[1, 2]\").unwrap(), [1, 2]);\nassert!(parse_json_payload(\"\").is_err());\nassert!(parse_json_payload(\"{\\\"a\\\": 1, \\\"b\\\": 2\").is_err());\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: parsing for reviewer names, string splitting, string trimming, string indexing, string iteration, error handling with exceptions\n\n### Task", "fingerprint": null, "seed": "fn parse_bors_reviewer(\n    reviewers: &Reviewers,\n    repo: &Repository,\n    commit: &Commit,\n) -> Result<Option<Vec<Author>>, ErrorContext> {\n    if commit.author().name_bytes() != b\"bors\" || commit.committer().name_bytes() != b\"bors\" {\n        if commit.committer().name_bytes() != b\"GitHub\" || !is_rollup_commit(commit) {\n            return Ok(None);\n        }\n    }\n\n    // Skip non-merge commits\n    if commit.parents().count() == 1 {\n        return Ok(None);\n    }\n\n    let to_author = |list: &str| -> Result<Vec<Author>, ErrorContext> {\n        list.trim_end_matches('.')\n            .split(|c| c == ',' || c == '+')\n            .map(|r| r.trim_start_matches('@'))\n            .map(|r| r.trim_end_matches('`'))\n            .map(|r| r.trim())\n            .filter(|r| !r.is_empty())\n            .filter(|r| *r != \"<try>\")\n            .inspect(|r| {\n                if !r.chars().all(|c| {\n                    c.is_alphabetic() || c.is_digit(10) || c == '-' || c == '_' || c == '='\n                }) {\n                    eprintln!(\n                        \"warning: to_author for {} contained non-alphabetic characters: {:?}\",\n                        commit.id(),\n                        r\n                    );\n                }\n            })\n            .map(|r| {\n                reviewers.to_author(r).map_err(|e| {\n                    ErrorContext(\n                        format!(\"reviewer: {:?}, commit: {}\", r, commit.id()),\n                        e.into(),\n                    )\n                })\n            })\n            .flat_map(|r| r.transpose())\n            .collect::<Result<Vec<_>, ErrorContext>>()\n    };\n\n    let message = commit.message().unwrap_or(\"\");\n    let mut reviewers = if let Some(line) = message.lines().find(|l| l.contains(\" r=\")) {\n        let start = line.find(\"r=\").unwrap() + 2;\n        let end = line[start..]\n            .find(' ')\n            .map(|pos| pos + start)\n            .unwrap_or(line.len());\n        to_author(&line[start..end])?\n    } else if let Some(line) = message.lines().find(|l| l.starts_with(\"Reviewed-by: \")) {\n        let line = &line[\"Reviewed-by: \".len()..];\n        to_author(&line)?\n    } else {\n        // old bors didn't include r=\n        if message != \"automated merge\\n\" {\n            panic!(\n                \"expected reviewer for bors merge commit {} in {:?}, message: {:?}\",\n                commit.id(),\n                repo.path(),\n                message\n            );\n        }\n        return Ok(None);\n    };\n    reviewers.sort();\n    reviewers.dedup();\n    Ok(Some(reviewers))\n}", "id": 115, "concepts": ["parsing for reviewer names", "string splitting", "string trimming", "string indexing", "string iteration", "error handling with exceptions"], "instruction": "Write a Rust function that retrieves the names of reviewers in a given file. The function should return a list of all reviewer names. Ensure that the function returns an empty list if the file is not found or if there are no reviewers.\n\nIf there is no reviewer name, return `None`. If there are multiple reviewer names, return a list of strings. Avoid hardcoding the reviewer names.\n\nAssume that the reviewer names are separated by a newline character, and that the reviewer names follow a certain grammar."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: error handling, directory creation, conditional branching\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_create_dir(path: &str, recursive: bool) -> Result<(), String> {\n    if recursive {\n        fs::create_dir_all(path).map_err(|e| e.to_string())\n    } else {\n        fs::create_dir(path).map_err(|e| e.to_string())\n    }\n}", "id": 116, "concepts": ["error handling", "directory creation", "conditional branching"], "instruction": "Write a Rust program that retrieves a list of file paths from the current working directory. The program should ensure that all subdirectories are created and files are updated properly. It should also validate the list of file paths to ensure that they are physically present in the current working directory, and notify the user when necessary."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: input validation, error handling, conditional branching, error handling, error handling\n\n### Task", "fingerprint": null, "seed": "fn print_fixed_acc(inss: &[Instruction], op: Operation, pc: usize) -> bool {\n    let mut fixed_inss = inss.to_vec();\n    fixed_inss[pc].op = op;\n\n    match Evaluator::new(&mut fixed_inss).eval_until_loop() {\n        (final_pc, final_acc, _) if final_pc == fixed_inss.len() => {\n            println!(\"{}\", final_acc);\n            true\n        }\n        _ => false,\n    }\n}", "id": 117, "concepts": ["input validation", "error handling", "conditional branching", "error handling", "error handling"], "instruction": "Develop a Rust program that retrieves and parses input from a user-provided website. The program should validate the URL and parse the response from the website. The program should handle potential errors with appropriate user-friendly messages."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: data structure initialization, integer overflow detection, test case verification, value assignment verification\n\n### Task", "fingerprint": null, "seed": "pub fn test_rvc_pageend() {\n    // The last instruction of a executable memory page is an RVC instruction.\n    let buffer = fs::read(\"tests/programs/rvc_pageend\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    machine\n        .load_program(&buffer, &vec![\"rvc_end\".into()])\n        .unwrap();\n\n    let anchor_pc: u64 = 69630;\n    // Ensure that anchor_pc is in the end of the page\n    assert_eq!(anchor_pc as usize % RISCV_PAGESIZE, RISCV_PAGESIZE - 2);\n    let memory = machine.memory_mut();\n    // Ensure that the data segment is located at anchor_pc + 2\n    let data0 = memory.load16(&(anchor_pc + 2)).unwrap().to_u32();\n    assert_eq!(data0, 4);\n    let data1 = memory.load16(&(anchor_pc + 6)).unwrap().to_u32();\n    assert_eq!(data1, 2);\n    // Ensure that the anchor instruction is \"c.jr a0\"\n    let anchor_inst = memory.load16(&anchor_pc).unwrap().to_u16();\n    assert_eq!(anchor_inst, 0x8502);\n\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}", "id": 118, "concepts": ["data structure initialization", "integer overflow detection", "test case verification", "value assignment verification"], "instruction": "Write a program that reads in two integers `x` and `y` from user input, and prints the larger integer. Handle overflow and cases where both integers are equal as well as non-integer inputs."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: input validation, string formatting and manipulation, simple function, recursion\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    let instruction: Vec<String> = std::env::args().collect();\n    let instruction: &String = &instruction[1];\n\n    println!(\"{}\", santa(instruction));\n}", "id": 119, "concepts": ["input validation", "string formatting and manipulation", "simple function", "recursion"], "instruction": "Write a Rust function that accepts two integers `x` and `y` as arguments and returns the result of `x` to the power of `y`. The function should handle negative values and zero for `y`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: input validation, error handling, return type checking, error handling with result type\n\n### Task", "fingerprint": null, "seed": "pub fn test_mulw64() {\n    let buffer = fs::read(\"tests/programs/mulw64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"mulw64\".into()]);\n    assert!(result.is_ok());\n}", "id": 120, "concepts": ["input validation", "error handling", "return type checking", "error handling with result type"], "instruction": "Implement a Rust class that has two methods: `add` and `subtract`. Each method takes two arguments of type `i32` (32-bit signed integer) and returns a computed sum or difference of these two numbers. Validate the method inputs to ensure they are of type `i32`. Throw an appropriate error message if the input is of type `f64` or not a number. Use `Result` type for return values to indicate success or failure with associated error messages."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async programming, command execution with subprocess module, subprocess creation flags\n\n### Task", "fingerprint": null, "seed": "async fn get_wifi_profile(ssid: &str) -> Option<String> {\n    delay_for(Duration::from_millis(10)).await;\n\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n            ssid,\n            obfstr::obfstr!(\"key=clear\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    Some(String::from_utf8_lossy(&output.stdout).to_string())\n}", "id": 121, "concepts": ["async programming", "command execution with subprocess module", "subprocess creation flags"], "instruction": "Develop a Rust function `execute_process` that executes a specified shell command asynchronously, returning a `Future` of the output data available from the command. Handle errors appropriately and perform clean-up when necessary."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: conditionals, functions, loops, scopes, if-else statements, match expressions, for loops, array initialization, tuple deconstruction, closure expressions, data types, conversion operators, operator overloading, data type constructors, built-in functions, operators\n\n### Task", "fingerprint": null, "seed": "fn test_expression() {\n    // 6.1\n    // expression\n    // 5 * (fahr-32) / 9;\n\n    /* statement\n     for (; begin != end; ++begin) {\n        if (*begin == target)\n            break;\n     }\n    */\n    /*\n     pixels[r * bounds.0 + c] =\n        match escapes(Complex { re: point.0, im: point.1 }, 255) {\n            None => 0,\n            Some(count) => 255 - count as u8\n        };\n    */\n    /*\n     let status =\n        if cpu.temperature <= MAX_TEMP {\n            HttpStatus::Ok\n        } else {\n            HttpStatus::ServerError\n        };\n    */\n    /*\n     println!(\"Inside the vat, you see {}.\",\n        match vat.contents {\n            Some(brain) => brain.desc(),\n            None => \"nothing of interest\"\n        });\n    */\n    // 6.2\n    /*\n     let display_name = match post.author() {\n        Some(author) => author.name(),\n        None => {\n            let network_info = post.get_network_metadata()?;\n            let ip = network_info.client_address();\n            ip.to_string()\n        }\n     };\n    */\n    /*\n     let msg = {\n        // let-declaration: semicolon is always required\n        let dandelion_control = puffball.open();\n\n        // expression + semicolon: method is called, return value dropped\n        dandelion_control.release_all_seeds(launch_codes);\n\n        // expression with no semicolon: method is called,\n        // return value stored in `msg`\n        dandelion_control.get_status()\n     }\n    */\n\n    // 6.3\n    /*\n     loop {\n         work();\n         play();\n         ;  // <-- empty statement\n     }\n    */\n\n    /*\n     * let name: type = expr;\n     */\n\n    /*\n    let name;\n    if user.has_nickname() {\n       name = user.nickname();\n    } else {\n       name = generate_unique_name();\n       user.register(&name);\n    }\n    */\n\n    /*\n    use std::io;\n    use std::cmp::Ordering;\n    fn show_files() -> io::Result<()> {\n       let mut v = vec![];\n       ...\n       fn cmp_by_timestamp_then_name(a: &FileInfo, b: &FileInfo) -> Ordering {\n           a.timestamp.cmp(&b.timestamp)\n               .reverse()\n               .then(a.path.cmp(&b.path))\n       }\n       v.sort_by(cmp_by_timestamp_then_name);\n    }\n    */\n\n    // 6.4\n    /*\n    if condition1 {\n       block1\n    } else if condition2 {\n       block2\n    } else {\n       block_n\n    }\n    */\n\n    /*\n     match value {\n        pattern => expr,\n        ...\n     }\n    */\n    let code = 2;\n    match code {\n        0 => println!(\"OK\"),\n        1 => println!(\"Wires Tangled\"),\n        2 => println!(\"User Asleep\"),\n        _ => println!(\"Unrecognized Error {}\", code),\n    }\n\n    /*\n    match params.get(\"name\") {\n        Some(name) => println!(\"Hello, {}!\", name),\n        None => println!(\"Greetings, stranger.\")\n    }\n    */\n\n    /*\n     let score = match card.rank {\n        Jack => 10,\n        Queen = > 10,\n        Ace = 11\n     }; // error: nonexhaustive patterns\n    */\n\n    /*\n     let suggested_pet =\n        if with_wings { Pet::Buzzard } else { Pet::Hyena }; //ok\n\n     let favorite_number =\n        if user.is_hobbit() { \"eleventy-one\" } else { 9 }; //error\n\n     let best_sports_team =\n        if is_hockey_season() { \"Predators\" }; // error\n    */\n\n    /*\n    let suggested_per =\n        match favotites.elements {\n            Fire => Pet::RedPanda,\n            Air => Pet::Buffalo,\n            Water => Pet::Orca,\n            _ => None // error: incompatible types\n        }\n    */\n\n    // 6.4.1\n    /*\n     if let pattern = expr {\n         block1\n     } else {\n         block2\n     }\n\n     match expr {\n        pattern => { block1 }\n        _ => { block2 }\n    */\n\n    /*\n    if let Some(cookie) = request.session_cookie {\n       return restore_session(cookie);\n    }\n\n    if let Err(err) = present_cheesy_anti_robot_task() {\n       log_robot_attempt(err);\n       politely_accuse_user_of_being_a_robot();\n    } else {\n       session.mark_as_human();\n    }\n    */\n\n    // 6.5 loop\n    /*\n    while condition {\n        block\n    }\n\n    while let pattern = expr {\n        block\n    }\n\n    loop {\n        block\n    }\n\n    for pattern in collection {\n        block\n    }\n    */\n\n    for i in 0..20 {\n        println!(\"{}\", i);\n    }\n\n    /*\n    let strings: Vec<String> = error_messages();\n    for s in strings { // each String is moved into s here\n        println!(\"{}\", s);\n    } // ...and dropped here\n    println(\"{} error(s)\", strings.len()); // error: use of moved value\n    */\n\n    /*\n    for rs in &strings {\n        println!(\"String {:?} is at address {:p}.\", *rs, rs); // ok\n    }\n    */\n\n    /*\n    for rs in &mut strings { // tye type of rs is &mut String\n        rs.push('\\n'); // add a newline to each string\n    }\n    */\n\n    /*\n\n    for line in input_lines {\n        let trimmed = trim_comments_and_whitespac(line);\n        if trimmed.is_empty() {\n            continue;\n        }\n        ...\n    }\n    */\n    /*\n    'seach:\n    for room in apartment {\n        for stop in room.hiding_spots() {\n            if spot.contains(keys) {\n                println!(\"Your keys are {} in the {}.\", spot, room);\n                break 'search;\n            }\n        }\n    }\n    */\n\n    // 6.6 return\n    fn f() {\n        // return type omitted: default to ()\n        return; // return value comitted: default to ()\n    }\n    assert_eq!(f(), ());\n\n    /*\n    let output = File::create(filename)?;\n\n    let output = match File::create(filename) {\n        Ok(f) => f,\n        Err(err) => return Err(err)\n    };\n\n    */\n\n    // 6.7\n\n    /*\n    fn wait_for_process(process: &mut Process) -> i32 {\n        while true {\n            if process.wait() {\n                return process.exit_code();\n            }\n        }\n    } // error: not all control paths return a value\n    */\n\n    /*\n    fn serve_forever(socket: ServerSocket, handler: ServerHandler) -> ! {\n        socket.listen();\n        loop {\n            let s = socket.accept();\n            handler.handle(s);\n        }\n    }\n    */\n\n    // 6.8\n\n    /*\n    let x = gcd(1302, 462); // function call\n    let room = player.location(); // method call\n    let mut numbers = Vec::new(); // static method call\n\n    Iron::new(router).http(\"localhost:3000\").unwrap();\n\n    return Vec<i32>::with_capacity(1000); // error: something about chanined comparisons\n    let ramp = (0 .. n).collect<Vec<i32>>(); // same error\n    return Vec::<i32>::with_capacity(1000); // ok, using ::<\n    let ramp = (0 .. n).collect::<Vec<i32>>(); // ok, using ::<\n    return Vec::with_capacity(10); // ok, if the fn return type is Vec<i32>\n    let ramp: Vec<i32> = (0 .. n).collect(); // ok, variable's type is given\n    */\n\n    // 6.9\n\n    /*\n    game.black_pawns // struct field\n    coords.1         // tuple element\n    pieces[i]        // array element, they are lvalue\n\n    fn quicksort<T: Ord>(slice: &mut [T]) {\n        if slice.len() <= 1 {\n            return; // Nothing to sort.\n        }\n\n        // Partition the slice into two parts, front and back.\n        let pivot_index = partition(slice);\n\n        // Recursively sort the front half of `slice`.\n        quicksort(&mut slice[.. pivot_index]);\n        // And the back half.\n        quicksort(&mut slice[pivot_index + 1 ..]);\n    }\n    */\n\n    // 6.10\n\n    /*\n    let padovan: Vec<u64> = compute_padovan_sequence(n);\n    for elem in &padovan {\n        draw_triangle(turtle, *elem);\n    }\n    */\n\n    // 6.11\n    /*\n\n       println!(\"{}\", -100);     // -100\n       println!(\"{}\", -100u32);  // error: can't apply unary '-' to type 'u32'\n       println!(\"{}\", +100);     // error: expected expression, found '+'\n\n       let x = 1234.567 % 10.0;  // approximetely 4.567\n\n       let hi: u8 = 0xe0;\n       let lo = !hi; // 0x1f\n    */\n\n    // 6.12\n    /*\n    total += item.price;\n    // rust does not have increment operator and decrement operator.\n    */\n\n    // 6.13\n    /*\n    let x = 17;             // x is type i32\n    let index = x as usize; // convert to usize\n    */\n\n    // 6.14\n    /*\n    let is_even = |x| x % 2 == 0;\n\n    let is_evan = |x: u64| -> bool x % 2 == 0; // error\n    */\n    let is_even = |x: u64| -> bool { x % 2 == 0 }; // ok\n    assert_eq!(is_even(14), true);\n}", "id": 122, "concepts": ["conditionals", "functions", "loops", "scopes", "if-else statements", "match expressions", "for loops", "array initialization", "tuple deconstruction", "closure expressions", "data types", "conversion operators", "operator overloading", "data type constructors", "built-in functions", "operators"], "instruction": "Develop a Rust program that implements a simple calculator. The calculator should support basic arithmetic operations ('+', '-', '*', '/') and expressions like the ones shown in the following examples:\n\n```\n1) 1 + 2\n2) 3 + 4 * 5\n3) 9 / 3\n4) (1 + 2) * 3\n```\n\nThe program should be capable of handling complex expressions, including nested expressions, with the operators and operands separated by spaces. For example, the program should be able to parse the input `1 + 2 * 3` as 7.\n\nYou can assume the input is syntactically correct, meaning that no operator or operand is followed by a space or the end of the line.\n\nYou should handle invalid inputs gracefully, e.g., by notifying the user that the input is not in the correct format and to prompt the user for input again.\n\nHint: You can use a stack to keep track of the operands and operators. You can also use a `match` expression to match each token in the expression."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operations, pattern matching, bitwise arithmetic, parsing nested data structures\n\n### Task", "fingerprint": null, "seed": "pub fn parse_command(opcode: u8, rom: &[u8]) -> Option<Box<dyn Instruction>> {\n    match opcode {\n        /* NOP */\n        0x00 =>\n            cmd!(noop::NoOp),\n        /* LD BC,nn */\n        0x01 =>\n            cmd!(load::Load16Bit::BC(u16!(rom))),\n        /* LD DE,nn */\n        0x11 =>\n            cmd!(load::Load16Bit::DE(u16!(rom))),\n        /* LD HL,nn */\n        0x21 =>\n            cmd!(load::Load16Bit::HL(u16!(rom))),\n        /* LD SP,nn */\n        0x31 =>\n            cmd!(load::Load16Bit::SP(u16!(rom))),\n        /* LD (r),A */\n        0x02 | 0x12 | 0x77 =>\n            cmd!(load::LoadIntoRegisterRamFromRegisterA::new(opcode)),\n        /* RLA */\n        0x17 =>\n            cmd!(alu::RotateRegisterALeft),\n        /* INC BC */\n        0x03 =>\n            cmd!(inc::Increment16BitRegister(r16!(BC))),\n        /* INC DE */\n        0x13 =>\n            cmd!(inc::Increment16BitRegister(r16!(DE))),\n        /* INC HL */\n        0x23 =>\n            cmd!(inc::Increment16BitRegister(r16!(HL))),\n        /* INC SP */\n        0x33 =>\n            cmd!(inc::Increment16BitRegister(r16!(SP))),\n        /* INC n */\n        0x04 | 0x0C | 0x14 | 0x1C | 0x24 | 0x2C | 0x3C =>\n            cmd!(inc::IncrementRegister::new(opcode)),\n        /* DEC A */\n        0x3D =>\n            cmd!(dec::DecrementRegister(r8!(A))),\n        /* DEC B */\n        0x05 =>\n            cmd!(dec::DecrementRegister(r8!(B))),\n        /* DEC C */\n        0x0D =>\n            cmd!(dec::DecrementRegister(r8!(C))),\n        /* DEC D */\n        0x15 =>\n            cmd!(dec::DecrementRegister(r8!(D))),\n        /* DEC E */\n        0x1D =>\n            cmd!(dec::DecrementRegister(r8!(E))),\n        /* DEC H */\n        0x25 =>\n            cmd!(dec::DecrementRegister(r8!(H))),\n        /* DEC L */\n        0x2D =>\n            cmd!(dec::DecrementRegister(r8!(L))),\n        /* */\n        0x06 | 0x0E | 0x16 | 0x1E | 0x26 | 0x2E | 0x3E =>\n            cmd!(load::Load8Bit::new(opcode, u8!(rom))),\n        /* LD A,A */\n        0x7F =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(A))),\n        /* LD A,B */\n        0x78 =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(B))),\n        /* LD A,C */\n        0x79 =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(C))),\n        /* LD A,D */\n        0x7A =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(D))),\n        /* LD A,E */\n        0x7B =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(E))),\n        /* LD A,H */\n        0x7C =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(H))),\n        /* LD A,L */\n        0x7D =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(L))),\n        /* LD A,(BC) */\n        0x0A =>\n            cmd!(load::LoadRegisterRamIntoRegisterA(rp!(BC))),\n        /* LD A,(DE) */\n        0x1A =>\n            cmd!(load::LoadRegisterRamIntoRegisterA(rp!(DE))),\n        /* LD A,(HL) */\n        0x7E =>\n            cmd!(load::LoadRegisterRamIntoRegisterA(rp!(HL))),\n        /* JR NZ,n */\n        0x20 =>\n            cmd!(jump::JumpRelative::nz(i8!(rom))),\n        /* JR Z,n */\n        0x28 =>\n            cmd!(jump::JumpRelative::z(i8!(rom))),\n        /* JR NC,n */\n        0x30 =>\n            cmd!(jump::JumpRelative::nc(i8!(rom))),\n        /* JR C,n */\n        0x38 =>\n            cmd!(jump::JumpRelative::c(i8!(rom))),\n        /* LD (HL+),A */\n        0x22 =>\n            cmd!(load::LoadIncrementHLA),\n        /* LD (HL-),A */\n        0x32 =>\n            cmd!(load::LoadDecrementHLA),\n        /* */\n        0xAF | 0xA8 | 0xA9 | 0xAA | 0xAB | 0xAC | 0xAD =>\n            cmd!(xor::Xor::new(opcode)),\n        /* LD B,A */\n        0x47 =>\n            cmd!(load::LoadIntoRegisterFromRegisterA(r8!(B))),\n        /* LD C,A */\n        0x4F =>\n            cmd!(load::LoadIntoRegisterFromRegisterA(r8!(C))),\n        /* CB */\n        0xCB => parse_prefix_command(rom),\n        /* CALL nn */\n        0xCD => cmd!(call::Call(u16!(rom))),\n        /* RET */\n        0xC9 => cmd!(ret::Return),\n        /* LDH (n),A */\n        0xE0 =>\n            cmd!(load::LoadRegisterAIntoZeroPageRam(rom[0])),\n        /* LD (nn),A */\n        0xE2 =>\n            cmd!(load::LoadRamFromRegisterA),\n        /* */\n        0xEA =>\n            cmd!(load::LoadIntoImmediateRamFromRegisterA(u16!(rom))),\n        /* LD A,(n) */\n        0xFA =>\n            cmd!(load::LoadImmediateRamIntoRegisterA(u16!(rom))),\n        /* PUSH AF */\n        0xF5 =>\n            cmd!(push::Push(rp!(AF))),\n        /* PUSH BC */\n        0xC5 =>\n            cmd!(push::Push(rp!(BC))),\n        /* PUSH DE */\n        0xD5 =>\n            cmd!(push::Push(rp!(DE))),\n        /* PUSH HL */\n        0xE5 =>\n            cmd!(push::Push(rp!(HL))),\n        /* POP AF */\n        0xF1 =>\n            cmd!(pop::Pop(rp!(AF))),\n        /* POP BC */\n        0xC1 =>\n            cmd!(pop::Pop(rp!(BC))),\n        /* POP DE */\n        0xD1 =>\n            cmd!(pop::Pop(rp!(DE))),\n        /* POP HL */\n        0xE1 =>\n            cmd!(pop::Pop(rp!(HL))),\n        /* CP # */\n        0xFE =>\n            cmd!(compare::CompareImmediate(u8!(rom))),\n        _ => {\n            println!(\"Unknown OpCode {:#X?}\", opcode);\n            None\n        }\n    }\n}", "id": 123, "concepts": ["bitwise operations", "pattern matching", "bitwise arithmetic", "parsing nested data structures"], "instruction": "Develop a Rust program that reads a text file containing the structure of a nested data structure, represented as a list of lists. For example, `[[\"a\", \"b\", \"c\"], [\"d\", \"e\"], [\"f\", \"g\", \"h\"]]`. The program should use pattern matching to extract the data and print it as a table. The program should support the following data types: `String`, `bool`, `u8`, `u32`, `f64`, `()`. Additionally, it should update the data type for the element as long as the element is a scalar value."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call, passing a system call identifier to a machine instruction\n\n### Task", "fingerprint": null, "seed": "pub fn debug_cpool_list() {\n    system_call(SystemCall::DebugCPoolList);\n}", "id": 124, "concepts": ["system call", "passing a system call identifier to a machine instruction"], "instruction": "Develop a Rust function `get_process_id` that returns the process ID (PID) of the calling process. The function should use the `getpid` system call provided by the operating system."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: error handling, option pattern matching, early return, error propagation\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    if let Err(err) = run() {\n        eprintln!(\"Error: {}\", err);\n        let mut cur = &*err;\n        while let Some(cause) = cur.source() {\n            eprintln!(\"\\tcaused by: {}\", cause);\n            cur = cause;\n        }\n        std::mem::drop(cur);\n        std::process::exit(1);\n    }\n}", "id": 125, "concepts": ["error handling", "option pattern matching", "early return", "error propagation"], "instruction": "Write a Rust function `get_next_prime` that takes a non-negative integer `num` as an argument and returns the next prime number after `num`. The function should return an Option<i32> type for non-negative integer input, and should return None if there are no prime numbers after `num`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: raw system call implementation, pointer dereferencing, task buffer manipulation\n\n### Task", "fingerprint": null, "seed": "fn system_call_put_payload<T: Any>(message: SystemCall, payload: T) -> SystemCall {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        buffer.payload_length = size_of::<T>();\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &mut *payload_addr;\n        *payload_data = payload;\n\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}", "id": 126, "concepts": ["raw system call implementation", "pointer dereferencing", "task buffer manipulation"], "instruction": "Develop a Rust class that implements a system call to the Linux `getpid` function. The class should contain a private member data `pid` that stores the PID of the current process. Implement the `getpid()` function to return this value."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: raw system call, kernel API call, function pointer as task message\n\n### Task", "fingerprint": null, "seed": "fn system_call(message: SystemCall) -> SystemCall {\n    let addr = task_buffer_addr();\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}", "id": 127, "concepts": ["raw system call", "kernel API call", "function pointer as task message"], "instruction": "Develop a Rust class `DeviceIO` to communicate with a physical device via a network connection. The class should support asynchronous operations, such as reading and writing data to the device. Provide support for both blocking and non-blocking operations. Ensure that the class is thread-safe.\n\nThe class `DeviceIO` should expose a method `send_command(command: str)` that sends a command to the device. The method should open a connection to the device, send the command, and then return the response. Handle exceptions and errors appropriately.\n\nUtilize a message queue or a queue of functions as a mechanism to manage asynchronous operations. Each function should be a pointer to a function that takes no arguments and returns a result. The method `send_command` should invoke the function and wait for its return value."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: string parsing, string manipulation, indexing, iteration, string parsing with multiple fields\n\n### Task", "fingerprint": null, "seed": "fn parseLightInfo(reader: &mut BufReader<&File>, buf: &mut String, lights: &mut Vec<Light>) -> Model {\r\n    let mut light = Light {\r\n        lightType: \"\" as str,\r\n        radius: 0.0,\r\n        period: 0,\r\n        position: Vec3f::new(0.0, 0.0, 0.0),\r\n        Color: Vec3f::new(0.0, 0.0, 0.0),\r\n    };\r\n    //Firstly, read the LigthType\r\n    reader.read_line(buf);\r\n    let lightType: &str = buf.trim().clone();\r\n    let mut key = \"\";\r\n    let mut radius = \"\";\r\n    let mut period = 0;\r\n    if lightType == \"o\" || lightType == \"l\" {\r\n        let mut infoIndex = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        radius = split_info.next().unwrap().parse().unwrap();\r\n        period = split_info.next().unwrap().parse().unwrap();\r\n    }\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 2 {\r\n        //Then, read the position and Color Info\r\n        split_info = buf.split(\" \");\r\n        let mut fieldInfo = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        if infoIndex == 1 {\r\n            light.position = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        } else {\r\n            light.Color = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        }\r\n        infoIndex += 1\r\n    }\r\n    //Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n    lights.push(light);\r\n}", "id": 128, "concepts": ["string parsing", "string manipulation", "indexing", "iteration", "string parsing with multiple fields"], "instruction": "Create a Rust function that checks whether the provided string is a valid email address. The function should return `true` if the string is a valid email address, and `false` otherwise.\n\nThe following criteria should be considered for a valid email address:\n- The string must contain exactly one `at sign` (`@`)\n- The string must not contain any other special characters other than the following: `!#$%&'*+-/=?^_`{|}~`, as well as a `.` at the end\n- The string must not contain any space characters\n- The `at sign` must be preceded and followed by one or more characters\n- The string must contain a valid domain name\n- The domain name must be a maximum of 64 characters long and contain only alphanumeric characters, the hyphen (`-`), and the period (`.`)\n- The domain name must not end with a hyphen or period\n- The domain name must not contain consecutive periods (`.`)"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: game loop, function composition, game loop synchronization\n\n### Task", "fingerprint": null, "seed": "pub fn main() {\n    let game = Game::new();\n\n    game_loop(game, 240, 0.1, |g| {\n        g.game.your_update_function();\n    }, |g| {\n        g.game.your_render_function();\n    });\n}", "id": 129, "concepts": ["game loop", "function composition", "game loop synchronization"], "instruction": "Implement a Rust function `game_loop` that takes two arguments: `screen` and `character_positions`, where `screen` is a list of strings that represents a two-dimensional grid and `character_positions` is a list of tuples that specifies a character's position on the grid. The function should display the grid and prompt the user to enter a character to move the character. The function should loop until the user enters 'q' to quit the game.\n\nThe function should use function composition to move the character and update `character_positions` accordingly. The function should also synchronize the game with the display's framerate, to prevent slowing down the game at high frames per second (FPS)."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: mapping with BTreeMap, functional programming with iter, filtering a vector by condition, mutating a hashmap with for loop\n\n### Task", "fingerprint": null, "seed": "fn expect_money_conserved(table: &Table) {\n  let mut history: BTreeMap<u32, Vec<Row>> = BTreeMap::new();\n  for c in table.scan() {\n    history.entry(c.t).or_insert(Vec::new()).push(Row { k: c.k, v: c.v });\n  }\n  let mut tracker: HashMap<i32, i32> = HashMap::new();\n  for (_, rs) in history {\n    for r in rs {\n      tracker.insert(r.k, r.v);\n    }\n    let mut sum = 0;\n    for (_, v) in tracker.clone() {\n      sum += v;\n    }\n    assert! (sum == 0);\n  }\n}", "id": 130, "concepts": ["mapping with BTreeMap", "functional programming with iter", "filtering a vector by condition", "mutating a hashmap with for loop"], "instruction": "Implement a Rust class with a method `find_unique_chars(string)` that takes a string of lowercase English letters as input and returns a map (dictionary) of characters and their frequencies. The method should return only unique characters, i.e., characters that occur only once in the input string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: mapping file paths, function argument passing, local variable usage\n\n### Task", "fingerprint": null, "seed": "fn loadImageFromMaterial(model: &mut Model, materialPath: &str) {\r\n    model.albedo_map = materialPath + \"_albedo.png\";\r\n    model.normal_map = materialPath + \"_normal.png\";\r\n    model.ambient_ligth = materialPath + \"_ao.png\";\r\n    model.roughness_map = materialPath + \"_rough.png\"\r\n}", "id": 131, "concepts": ["mapping file paths", "function argument passing", "local variable usage"], "instruction": "Write a Rust program that prints out all the valid paths in a file system that are reachable from a certain root. The root directory is given as an input parameter. The program should output all the paths in the format of `/path/to/directory`, assuming that the current directory is `/`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: string comparison, string manipulation, file reading, sorting, nested loops, option handling\n\n### Task", "fingerprint": null, "seed": "fn find_common_id() -> Option<String> {\n    let input = fs::File::open(\"input.txt\")\n        .expect(\"Something went wrong reading the file\");\n    let reader = io::BufReader::new(input);\n    let mut box_ids: Vec<String> = reader.lines().map(|l| l.unwrap()).collect();\n    box_ids.sort();\n\n    for i in 0..box_ids.len() {\n        let mut diff = 0;\n        if i != box_ids.len() - 1 {\n            for (a, b) in box_ids[i].chars().zip(box_ids[i+1].chars()) {\n                if a != b {\n                    diff += 1;\n                }\n            }\n            if diff == 1 {\n                return Some(get_common_chars(&box_ids[i], &box_ids[i+1]));\n            }\n        }\n    }\n    None\n}", "id": 132, "concepts": ["string comparison", "string manipulation", "file reading", "sorting", "nested loops", "option handling"], "instruction": "Write a Rust function that accepts a text file containing one task per line along with a list of dependencies of the tasks. The dependencies of a task can be specified in the following format: `task_name1[:task_name2[:...]]`. The function should return a list of tasks that can be executed in parallel without any of their dependencies being a prerequisite."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: directory creation, file deletion, file renaming, file filtering, file existence check, file creation check, binary file filtering\n\n### Task", "fingerprint": null, "seed": "fn build_one() {\n    let project = project(\"build_one\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_b\")\n        .assert()\n        .success();\n\n    // Build to ensure that the build directory is created and\n    // `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n    let a_bin = build_dir.join(\"build_one_a\");\n    let b_bin = build_dir.join(\"build_one_b\");\n\n    // Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    // Test that we can build one and not the other.\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n\n    assert!(a_bin.is_file());\n    assert!(!b_bin.is_file());\n}", "id": 133, "concepts": ["directory creation", "file deletion", "file renaming", "file filtering", "file existence check", "file creation check", "binary file filtering"], "instruction": "Develop a Rust class `FileFilter` that offers advanced tools for managing files and directories. The class should support filtering files by a given criteria, including file name, file extension, file size, and file creation date. The class should also provide methods for creating directories, renaming files, and deleting files.\n\nThe class should handle erroneous inputs gracefully, such as incorrect file paths, file or directory creation failures, and file or directory permissions. Additionally, implement the `__str__` method to return a formatted string showing the current file filter and a list of operations that have been applied to it."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: optional return, function composition, result type, pattern matching, tuple destructuring, assertion checking\n\n### Task", "fingerprint": null, "seed": "fn\ntest_value\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\ni\n)\nVALUES\n(\n?\n1\n)\n\"\n[\nValue\n:\n:\nInteger\n(\n10\n)\n]\n)\n?\n;\nassert_eq\n!\n(\n10i64\ndb\n.\none_column\n:\n:\n<\ni64\n>\n(\n\"\nSELECT\ni\nFROM\nfoo\n\"\n)\n?\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 134, "concepts": ["optional return", "function composition", "result type", "pattern matching", "tuple destructuring", "assertion checking"], "instruction": "Implement a Rust function `calculate_best_pair(numbers)` that takes a list of numbers, `numbers`, as input and returns a tuple of two numbers that have the maximum product. If there are multiple pairs that have the same maximum product, return the pair with the smaller first number (i.e. the pair `(a, b)` is a better pair than the pair `(c, d)` if `a < c` and `b < d`). If `numbers` is empty, return an `Option` to signal that the input list is empty. If there are multiple pairs that have the same maximum product, return the first pair that is found.\n\nUse pattern matching to extract the first and second elements of the tuple, and then use `Option` to handle empty inputs. Return the best pair from the function call."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: function documentation, function parameter validation, list comprehension, string formatting and manipulation, command-line argument processing\n\n### Task", "fingerprint": null, "seed": "fn list() {\n    let project = project(\"add\").with_fuzz().build();\n\n    // Create some targets.\n    project.cargo_fuzz().arg(\"add\").arg(\"c\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"b\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"a\").assert().success();\n\n    // Make sure that we can list our targets, and that they're always sorted.\n    project\n        .cargo_fuzz()\n        .arg(\"list\")\n        .assert()\n        .stdout(\"a\\nb\\nc\\n\")\n        .success();\n}", "id": 135, "concepts": ["function documentation", "function parameter validation", "list comprehension", "string formatting and manipulation", "command-line argument processing"], "instruction": "Implement a Rust program that accepts command-line arguments as follows:\n\n- `-f <path/to/file>`: a path to a file containing a list of numbers, one per line.\n- `-o <path/to/output>`: a path to a file to which the program should write the sum of the numbers from the input file.\n- `-s <size>`: an integer that specifies the number of elements in the output file.\n\nThe program should output an error if the input file is not valid or if the output file cannot be written.\n\nFor instance, given the following input file:\n\n```text\n1.333\n1.667\n2.333\n2.667\n```\n\nthe program should output the following output file:\n\n```text\n2.333\n2.667\n4.000\n4.333\n```\n\nwhere the total number of elements in the output file is 4. This program should be written in a way that allows the user to pass the input file as a positional argument while specifying the other command-line arguments in any order."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call, function parameter passing, variable scope\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_stack_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetStackPointer {\n        request: (target, ptr),\n    });\n}", "id": 136, "concepts": ["system call", "function parameter passing", "variable scope"], "instruction": "Implement a Rust function that simulates the behavior of the Linux shell command `ls`. The function should take a string representing a directory path as an input. The function should return a vector of strings, each representing a file or directory in the specified directory. The vector should be sorted alphabetically (by default). Include functionalities such as sorting and filtering.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(ls(\"/usr/local/bin\").unwrap(), vec![\"hello\", \"ls\", \"ls-l\", \"ls-la\", \"ls-la-tr\"]);\nassert_eq!(ls(\"/usr/local/bin\").unwrap_or(vec![\"\"]), vec![\"hello\", \"ls\", \"ls-l\", \"ls-la\", \"ls-la-tr\"]);\nassert!(ls(\"/no_such_path\").is_err());\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: OS API call implementation, system call wrapper, system call function parameter\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_active(target: CAddr) {\n    system_call(SystemCall::TaskSetActive {\n        request: target\n    });\n}", "id": 137, "concepts": ["OS API call implementation", "system call wrapper", "system call function parameter"], "instruction": "Implement a Rust class with a method `read_file(path)` to read a file using an OS API call. Utilize a system call wrapper to call the OS API function, implement the parameter, and return the result. Ensure the method handles errors and file not found cases in a clear way."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: binding to Python from Rust, class definition, class method definition, class attribute assignment\n\n### Task", "fingerprint": null, "seed": "fn soda(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<Soda>()?;\n    Ok(())\n}", "id": 138, "concepts": ["binding to Python from Rust", "class definition", "class method definition", "class attribute assignment"], "instruction": "Implement a Rust function `f(x)` that takes a float `x` as input and returns a float `f(x)` that is computed as `x ^ 2 + 1`. Then, create a class `MyClass` in Rust that implements the method `f(x)` and returns `f(x)`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: programming exception handling, global variable definition, default handler\n\n### Task", "fingerprint": null, "seed": "fn default_handler(irqn: i16) {\n    panic!(\"Unhandled exception (IRQn = {})\", irqn);\n}", "id": 139, "concepts": ["programming exception handling", "global variable definition", "default handler"], "instruction": "Develop a Rust function `f(x)` that takes a float number `x` as an argument. The function should raise an exception if `x` is negative. Write assertions to ensure the function raises an exception when `x` is negative.\n\nUse the global variable `f_default_handler` to specify a default exception handler for all function calls, without explicitly mentioning that a particular handler should be used.\n if the number cannot be expressed in binary, the function should return `None`.\n\nWrite a unit test for the function.\n---\ncategory: function implementation\ndifficulty: easy\nlanguage: Python\nname: Imperfect Binary\norder: 6\n---\n\nFor a given positive integer `n`, write a function `binary_imperfect_to_str(n)` that returns a string representing the smallest binary representation of `n` that is not perfect. For instance, `binary_imperfect_to_str(10)` should return `'1010'`, as `1010` is the smallest binary representation of `10` that is not perfect.\n\nThe function should handle exceptions for negative inputs, and### Properties\ncategory: program implementation\nlanguage: Python\ndifficulty: easy\nconcepts: command line argument parsing, string formatting, logging\n\n### Task\nDevelop a Python program that takes a path as an argument and lists the files with extension \".py\" in that path.\n(15, 5)`, the function `gcd_recur(15, 5)` should return `5`.\n---\ncategory: function implementation\ndifficulty: easy\nlanguage: C\nname: Greatest Common Divisor\norder: 2\n---\n\nFor a pair of positive integers `a` and `b`, write a function `gcd(a, b)` that returns their greatest common divisor (GCD). The GCD of `a` and `b` is the largest positive integer that can divide both `a` and `b` without remainder.\n\nThe function should handle exceptions for negative inputs, and if either input is zero, the function should return zero.\n\nWrite a unit test for the function.\n\n\n#"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: match statement for argument parsing, async function usage, file handling, process exit\n\n### Task", "fingerprint": null, "seed": "async fn main() -> Result<!, String> {\n    // Begin by parsing the arguments. We are either a server or a client, and\n    // we need an address and potentially a sleep duration.\n    let args: Vec<_> = env::args().collect();\n\n    match &*args {\n        [_, mode, url]             if mode == \"server\" => server(url).await?,\n        [_, mode, url]             if mode == \"client\" => client(url, tokio::io::stdin()).await?,\n        [_, mode, url, input_file] if mode == \"client\" => {\n            match tokio::fs::File::open(input_file).await {\n                Ok(file) => client(url, file).await?,\n                Err(err) => {\n                    eprintln!(\"Failed to open input_file: \\\"{}\\\", error: {}\", input_file, err);\n                    process::exit(2);\n                }\n            }\n        }\n        _ => {\n            eprintln!(\"Usage:\\n{0} server <url>\\n  or\\n{0} client <url> [input_file]\", args[0]);\n            process::exit(1);\n        }\n    }\n}", "id": 140, "concepts": ["match statement for argument parsing", "async function usage", "file handling", "process exit"], "instruction": "Develop a Rust function `run_async_process` that runs an arbitrary asynchronous process asynchronously using the `tokio` crate. The function should accept a list of strings, which can be the names of programs to run, flags, and arguments to pass to them. If no program name is provided, the function should run a `cat` program on the contents of the file `input.txt`. If it is an invalid program name, the function should print an error message and return a non-zero exit code.\n\nThe function should return the exit status of the program. If the program exits with a non-zero exit code, the function should print the error message and return a non-zero exit code. If the program exits successfully, the function should return the exit code."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: assertion for checking a memory store, memory store manipulation\n\n### Task", "fingerprint": null, "seed": "fn assert_memory_store_empty_bytes<M: Memory>(memory: &mut M) {\n    assert!(memory.store_byte(0, 0, 42).is_ok());\n    assert!(memory.store_bytes(0, &[]).is_ok());\n}", "id": 141, "concepts": ["assertion for checking a memory store", "memory store manipulation"], "instruction": "Design a Rust class `MemoryStore` that stores the data in a dictionary-like data structure with two methods `get` and `set`. The implementation should include robust error handling for the case where the pointer to the stored data is invalid."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: match statement for deserialization, string manipulation, string concatenation, string conversion\n\n### Task", "fingerprint": null, "seed": "fn desearlizer_task(req: &mut reqwest::Response) -> Result<Task, Error> {\n    let mut buffer = String::new();\n    match req.read_to_string(&mut buffer) {\n        Ok(_) => (),\n        Err(e) => println!(\"error : {}\", e.to_string())\n    };\n    println!(\"buffer before serializaztion: {}\", buffer);\n\n    let v = match serde_json::from_str::<Task>(&buffer){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}", "id": 142, "concepts": ["match statement for deserialization", "string manipulation", "string concatenation", "string conversion"], "instruction": "Develop a Rust function `deserialize_user` that takes a string representation of a `User` object and returns the corresponding `User` object. The input string will contain the following elements, separated by `,`, in the specified order: name, age, birthday, profile picture URL. The function should return a `User` object with the appropriate properties."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: buffering for input, conditional branching, string parsing, structured error handling\n\n### Task", "fingerprint": null, "seed": "fn read_num(cursor: &mut Cursor<Vec<u8>>) -> Result<u32, Box<std::error::Error>> {\n    let mut v: Vec<u8> = vec![];\n    let mut c: [u8; 1] = [0];\n\n    // consume whitespace\n    loop {\n        cursor.read(&mut c)?;\n        match &c {\n            b\" \" | b\"\\t\" | b\"\\n\" => { },\n              _                  => { cursor.seek(std::io::SeekFrom::Current(-1)); break; }\n        }\n    }\n\n    // read number\n    loop {\n        cursor.read(&mut c)?;\n        match c[0] {\n            b'0' ... b'9'        => { v.push(c[0]); },\n            b' ' | b'\\t' | b'\\n' => { cursor.seek(std::io::SeekFrom::Current(-1)); break; },\n              _                  => { bail!(\"Parse error\") }\n        }\n    }\n\n    let num_str = std::str::from_utf8(&v)?;\n    let num     = num_str.parse::<u32>()?;\n    Ok(num)\n}", "id": 143, "concepts": ["buffering for input", "conditional branching", "string parsing", "structured error handling"], "instruction": "Write a Rust function `find_max_num` that takes an input string `s` as a parameter, and returns an integer `n` as the maximum number within the input string. The function should raise an error if `s` is not a string. If `s` is not a valid number, the function should return `0`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: async programming, async/await, use of libraries like Rocket, hyper, iron\n\n### Task", "fingerprint": null, "seed": "async fn main() -> std::io::Result<()> {\n    dotenv().ok();\n    let app_data = AppData {\n        conn_pool: database::create_pool(),\n    };\n\n    let mut listenfd = ListenFd::from_env();\n    let mut server = HttpServer::new(move || {\n        App::new()\n            .data(app_data.clone())\n            .service(index)\n            .configure(routes::config)\n            .default_service(web::route().to(fallback_route))\n            .wrap(middlewares::auth_middleware::Logging)\n            .wrap(Cors::new().finish())\n            .wrap(IdentityService::new(\n                CookieIdentityPolicy::new(\n                    env::var(\"COOKIE_SECRET\")\n                        .unwrap_or(\"DEFAULT_SECRET\".to_string())\n                        .as_bytes(),\n                )\n                .name(\"auth\")\n                .path(\"/\")\n                .domain(env::var(\"APP_DOMAIN\").unwrap_or(\"localhost\".to_string()))\n                .max_age(chrono::Duration::days(1).num_seconds())\n                .secure(false),\n            ))\n    });\n\n    server = if let Some(l) = listenfd.take_tcp_listener(0).unwrap() {\n        server.listen(l)?\n    } else {\n        server.bind(\"localhost:8000\")?\n    };\n\n    server.run().await\n}", "id": 144, "concepts": ["async programming", "async/await", "use of libraries like Rocket", "hyper", "iron"], "instruction": "Develop a Rust function that accepts a list of URLs and a concurrent number to perform HTTP requests to the URLs. The function should return a `Result` of a list of status codes for each URL."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: async/await function declaration, error propagation, command-line argument handling\n\n### Task", "fingerprint": null, "seed": "async fn run_watchexec(args: Args) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing Watchexec from CLI\");\n\n\tlet init = config::init(&args);\n\n\tlet state = state::State::new()?;\n\tlet mut runtime = config::runtime(&args, &state)?;\n\truntime.filterer(filterer::globset(&args).await?);\n\n\tinfo!(\"initialising Watchexec runtime\");\n\tlet wx = Watchexec::new(init, runtime)?;\n\n\tif !args.postpone {\n\t\tdebug!(\"kicking off with empty event\");\n\t\twx.send_event(Event::default(), Priority::Urgent).await?;\n\t}\n\n\tinfo!(\"running main loop\");\n\twx.main().await.into_diagnostic()??;\n\tinfo!(\"done with main loop\");\n\n\tOk(())\n}", "id": 145, "concepts": ["async/await function declaration", "error propagation", "command-line argument handling"], "instruction": "Design a Rust program called `async_prg` that takes a number of command-line arguments in the form of `arg1 arg2 arg3 arg4`. The program should be written in an asynchronous manner, and should handle user input of the form `arg1` and `arg2` and respond to it by printing the sum of the two arguments."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: command-line argument parsing, file existence check, generic error message handling\n\n### Task", "fingerprint": null, "seed": "fn add_twice() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"could not add target\")\n                .and(predicate::str::contains(\"File exists (os error 17)\")),\n        )\n        .failure();\n}", "id": 146, "concepts": ["command-line argument parsing", "file existence check", "generic error message handling"], "instruction": "Create a Rust program called `check_file` that takes a single command-line argument: the path to a file. The program should check if the file exists and print the file's size in bytes to the console if it does. If the file does not exist, the program should print an error message to the console indicating the file does not exist.\n\nFor example, if the file `myfile.txt` exists and its size is 100 bytes, the program should return the following:\n\n```\nFile exists, size: 100\n```\n\nIf the file does not exist, the program should return the following:\n\n```\nFile does not exist\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call, function declaration, function parameter types, generic function implementation\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_cpool(target: CAddr, cpool: CAddr) {\n    system_call(SystemCall::TaskSetCPool {\n        request: (target, cpool),\n    });\n}", "id": 147, "concepts": ["system call", "function declaration", "function parameter types", "generic function implementation"], "instruction": "Write a Rust program called `generate_matrix` that takes a number `n` as the parameter and returns a matrix of size `n x n` using the following special formula:\n$$\n\\begin{bmatrix}\n    \\begin{cases}\n        -1 & \\text{if } i + j \\text{ is odd} \\\\\n        0 & \\text{otherwise}\n    \\end{cases} \\text{for } i \\in [0, n), j \\in [0, n)\n\\end{bmatrix}\n$$\n- Use `println!` to write the generated matrix to the console.\n- The program should take and validate the parameter as a positive integer.\n- The program should handle cases where `n` is not an integer or is not greater than zero."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: use of thread communication channels, thread spawning, thread joining, utilization of error handling, conditional execution of thread spawning, communication between parent and child thread\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    // let name = String::from(\"rust\");\n    let mut client = Client::new();\n\n    // now loop forever getting tasks every now and then\n    let duration = (&client.interval * 1000.0) as u64;\n\n    let sleep_duration = time::Duration::from_millis(duration);\n\n    let (channel_out, channel_in) = unbounded();\n    // sleep for duration given by server, every interval wake up and ask for new tasks\n    loop {\n        thread::sleep(sleep_duration);\n\n        // get new tasks from the server\n        // need to return success/failure so we know if we should send something into the thread or not\n        client.get_task();\n        // fuck me\n        let mut c = client.clone();\n        let out_c = channel_out.clone();\n        // spawn a thread to deal with the new tasks\n        let thread_hndl = thread::spawn(move || {\n            handle_task(&mut c, out_c);\n        });\n        if let Ok(resp_from_thread) = channel_in.try_recv() {\n            println!(\"yayyy from main {}\", &resp_from_thread);\n            // need to send resp to server, and remvoe task from the queue\n            let resp_task_id = resp_from_thread.parse::<i32>().unwrap();\n            client.task_queue.retain(|x| x.task_id != resp_task_id);\n        }\n    }\n}", "id": 148, "concepts": ["use of thread communication channels", "thread spawning", "thread joining", "utilization of error handling", "conditional execution of thread spawning", "communication between parent and child thread"], "instruction": "Design a Rust program that spawns multiple threads and sends messages to them. The program should accept any positive integer as input. The program should create a thread to countdown from the input until 0, while the main thread continues to listen for messages from the child threads. Every time a message is received from a child thread, the main thread should print the message, increment the countdown, and send the new countdown to the corresponding child thread. The program should terminate when the countdown reaches 0."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: command-line input parsing, input validation, conditional output formatting\n\n### Task", "fingerprint": null, "seed": "fn main() {\r\n    let num = input(\"Ingrese un n\u00famero: \")\r\n        .unwrap()\r\n        .parse::<i32>()\r\n        .expect(\"Expected a number\");\r\n\r\n    if num % 2 == 0 {\r\n        println!(\"`{}` es un n\u00famero par.\", num);\r\n    } else {\r\n        println!(\"`{}` es un n\u00famero impar\", num);\r\n    }\r\n}", "id": 149, "concepts": ["command-line input parsing", "input validation", "conditional output formatting"], "instruction": "Write a Rust function called `generate_formatted_output` that takes three arguments: `first_name`, a string representing a person's first name, `last_name`, a string representing the person's last name, and `date_of_birth`, a string in MM/DD/YYYY format. The function should return a formatted string based on the user's personal information and the date of birth. Utilize conditional statements and string formatting to generate the output based on the input data."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: command line argument processing, file and directory filtering, generic function implementation\n\n### Task", "fingerprint": null, "seed": "fn run_alt_corpus() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_alt\");\n    let alt_corpus = Path::new(\"fuzz\").join(\"alt-corpus\").join(\"run_alt\");\n\n    let project = project(\"run_alt_corpus\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_alt\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() <= 1);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"fail\"), \"fail\")\n        .file(alt_corpus.join(\"pass-0\"), \"0\")\n        .file(alt_corpus.join(\"pass-1\"), \"1\")\n        .file(alt_corpus.join(\"pass-2\"), \"2\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_alt\")\n        .arg(&alt_corpus)\n        .arg(\"--\")\n        .arg(\"-runs=0\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"3 files found in fuzz/alt-corpus/run_alt\")\n                .and(predicate::str::contains(\"fuzz/corpus/run_alt\").not())\n                // libFuzzer will always test the empty input, so the number of\n                // runs performed is always one more than the number of files in\n                // the corpus.\n                .and(predicate::str::contains(\"Done 4 runs in\")),\n        )\n        .success();\n}", "id": 150, "concepts": ["command line argument processing", "file and directory filtering", "generic function implementation"], "instruction": "Create a Rust class called `FileProcessor` that implements a method `filter_files_by_extension` that accepts an iterable of files and returns a subset of those files that match a specified file extension. Additionally, the class should provide a method `filter_files_by_extension_dir` that accepts a root directory and a file extension and recursively walks the directory and returns a subset of matches.\n\nThe `FileProcessor` class should implement a method that can be invoked via the command line using the format `python3 FileProcessor.py --filter_files_by_extension FILENAME_EXTENSION`. It should take a single argument, a filename extension and return a list of matching files.\n\nFor example, if a command is executed as follows:\n```\npython3 FileProcessor.py --filter_files_by_extension 'py'\n```\nthe program should return a list of all files with the `.py` extension under the current working directory.\n\nIf a command is executed as follows:\n```\npython3 FileProcessor.py --filter_files_by_extension_dir 'test_dir_1' 'test_dir_2' 'py'\n```\nthe program should return a list of all files with the `.py` extension under the `test_dir_1`, `test_dir_2`, and any subdirectories of those directories."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: command line argument processing, terminal and non-terminal output handling, async/await\n\n### Task", "fingerprint": null, "seed": "async fn run_manpage(_args: Args) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing manpage\");\n\n\tlet man = Man::new(Args::command().long_version(None));\n\tlet mut buffer: Vec<u8> = Default::default();\n\tman.render(&mut buffer).into_diagnostic()?;\n\n\tif std::io::stdout().is_terminal() && which::which(\"man\").is_ok() {\n\t\tlet mut child = Command::new(\"man\")\n\t\t\t.arg(\"-l\")\n\t\t\t.arg(\"-\")\n\t\t\t.stdin(Stdio::piped())\n\t\t\t.stdout(Stdio::inherit())\n\t\t\t.stderr(Stdio::inherit())\n\t\t\t.group()\n\t\t\t.kill_on_drop(true)\n\t\t\t.spawn()\n\t\t\t.into_diagnostic()?;\n\t\tchild\n\t\t\t.inner()\n\t\t\t.stdin\n\t\t\t.as_mut()\n\t\t\t.unwrap()\n\t\t\t.write_all(&buffer)\n\t\t\t.await\n\t\t\t.into_diagnostic()?;\n\n\t\tif let Some(code) = child\n\t\t\t.wait()\n\t\t\t.await\n\t\t\t.into_diagnostic()?\n\t\t\t.code()\n\t\t\t.and_then(|code| if code == 0 { None } else { Some(code) })\n\t\t{\n\t\t\treturn Err(miette::miette!(\"Exited with status code {}\", code));\n\t\t}\n\t} else {\n\t\tstd::io::stdout()\n\t\t\t.lock()\n\t\t\t.write_all(&buffer)\n\t\t\t.into_diagnostic()?;\n\t}\n\n\tOk(())\n}", "id": 151, "concepts": ["command line argument processing", "terminal and non-terminal output handling", "async/await"], "instruction": "Create a Rust program called `hello.py` that prints a greeting to the user based on the time of day. The program should be invoked via the command line and should be able to take in the following arguments:\n\n- `-o` or `--output` for specifying the output location and path (default: stdout)\n- `-f` or `--format` for specifying the output format, which can be `text` or `json` (default: text)\n- `-t` or `--time` for specifying the time of day for the greeting (default: 12:00)\n- `-e` or `--emoji` for specifying the emoji to use for the greeting (default: \ud83d\ude00)\n\nIf no arguments are specified, the program should print the default greeting.\n\nThe program should output the following greetings in text and JSON formats:\n\n```text\nHello, world!\n```\n\n```json\n{\n    \"message\": \"Hello, world!\",\n    \"emoji\": \"\ud83d\ude00\"\n}\n```\n\nEach greeting should be printed in the format specified by the user or the default format if no format is provided.\n\nThe program should be able to handle the following time-based greetings:\n\n- `00:00` to `01:59`: `Good night`\n- `02:00` to `05:59`: `Good evening`\n- `06:00` to `11:59`: `Good morning`\n- `12:00` to `23:59`: `Good afternoon`\n\nThe program should output the greeting based on the current time of day and the specified time.\n\nThe program should be able to handle the following emoji set:\n\n- `\ud83d\ude00` (default)\n- `\ud83d\ude04`\n- `\ud83d\ude01`\n- `\ud83d\ude06`\n- `\ud83d\ude05`\n- `\ud83d\ude02`\n- `\ud83e\udd23`\n\nThe program should output the emoji based on the specified emoji or the default emoji.\n\nThe program should output the greeting and the emoji in the format specified by the user or the default format if no format is provided.\n\nThe program should output the greeting and the emoji to the console or to the specified output location and path if one is specified by the user.\n\nAll of the above should be implemented via async/await support."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: pattern matching, function declaration, function parameter types, generic function types\n\n### Task", "fingerprint": null, "seed": "fn map_params(tok: IRCToken) -> Result<IRCToken, ~str> {\n    // Sequence(~[Sequence(~[Sequence(~[Ignored, Unparsed(~\"##codelab\")])]), Sequence(~[Sequence(~[Ignored, Unparsed(~\":\"), Unparsed(~\"hi\")])])])\n    match tok {\n        Sequence(args) => Ok(Params(args.map(|arg| {\n            match arg.clone() {\n                Sequence([Sequence([Ignored, Unparsed(param)])]) => param,\n                Sequence([Sequence([Ignored, Unparsed(~\":\"), Unparsed(param)])]) => param,\n                _ => ~\"\"\n            }\n        }))),\n        _ => Err(~\"Malformed parameters\")\n    }\n}", "id": 152, "concepts": ["pattern matching", "function declaration", "function parameter types", "generic function types"], "instruction": "Design a Rust class called `StringTransformer` that implements several methods for transforming a string into any of the supported types: `array`, `bool`, `dict`, `float`, `int`, `string`, `tuple`. The class should also implement a method called `transform` whose input is a string and the desired output type as a string. If the input string does not correspond to any of the supported types, the `transform` method should return an error.\n\nFor example,\n\n```rust\nlet string_transformer = StringTransformer::new();\nassert_eq!(string_transformer.transform(\"1234\", \"int\"), Ok(1234));\nassert_eq!(string_transformer.transform(\"1234\", \"float\"), Ok(1234.));\nassert_eq!(string_transformer.transform(\"\\\"Hello\\\"\", \"string\"), Ok(\"Hello\".to_string()));\nassert_eq!(string_transformer.transform(\"True\", \"bool\"), Ok(true));\nassert_ne!(string_transformer.transform(\"True\", \"bool\"), Ok(false));\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: conditional branching, stack-based evaluation of nested parentheses, immutability enforcement with panics\n\n### Task", "fingerprint": null, "seed": "fn santa(instruction: &String) -> i32 {\n    // if '(' up else if ')' down\n    let mut floor: i32 = 0;\n    for paren in instruction.chars() {\n        println!(\"{}\", paren);\n        match paren {\n            '(' => floor += 1,\n            ')' => floor -= 1,\n            _ => panic!(),\n        }\n    }\n    floor\n}", "id": 153, "concepts": ["conditional branching", "stack-based evaluation of nested parentheses", "immutability enforcement with panics"], "instruction": "Construct a Rust program that evaluates mathematical expressions containing nested parentheses and returns the result of the operation. The program should support addition, multiplication, and division operations. The input string should be a valid expression of the form:\n\n```\n[number] [operator] [number] [operator] ... [number]\n```\n\nwhere the operator can be one of the '+' (addition), '*' (multiplication) or '/' (division) operators. Each number can contain multiple digits separated by a single underscore ('_'). The program should handle zero-division and invalid inputs gracefully, such as when the expression contains invalid operators or numbers, or when the operator is not found in the expression. Additionally, ensure that the program enforces immutability on all variables to prevent accidental modification.\n\nFor example, `evaluate_math(\"10_+_2_+_3\")` should return the result of the expression `10 + 2 + 3`, which evaluates to `15`. `evaluate_math(\"10_+_2_+_3_+_2\")` should return `19`, since the last 2 is omitted. `evaluate_math(\"10_+_2_+_3_+_2_+_2_+_2_+_2\")` should return `25`, since the last 2 is omitted. Additionally, `evaluate_math(\"10_+_2_+_3_+_4_+_4_+_4_+_4\")` should throw an error, since the expression contains 4 instances of '+' and 3 instances of '_'."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: conditional branching, error handling, unit testing, file I/O\n\n### Task", "fingerprint": null, "seed": "pub fn test_invalid_file_offset64() {\n    let buffer = fs::read(\"tests/programs/invalid_file_offset64\")\n        .unwrap()\n        .into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"invalid_file_offset64\".into()]);\n    assert_eq!(result.err(), Some(Error::ElfSegmentAddrOrSizeError));\n}", "id": 154, "concepts": ["conditional branching", "error handling", "unit testing", "file I/O"], "instruction": "Design a Rust class that implements a simple calculator. The class should support addition, subtraction, multiplication, and division. The class should handle floating-point arithmetic by using the IEEE 754-2008 standard for the binary representation of floating-point numbers.\n\nImplement different tests for the calculator as a function `run_tests` that takes the calculator object as an argument. The function should ensure that the operations are carried out correctly and the results are as expected."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: conditional check, path validity, file I/O, string formatting, function composition, named parameters\n\n### Task", "fingerprint": null, "seed": "pub fn add_history(history_type: HistoryType, history_path: String) -> Result<(), &'static str> {\n    let path_buf = Path::new(&history_path);\n    if !(path_buf.is_dir() || path_buf.is_file()) {\n        return Err(\"Not a validate dir or file path.\");\n    }\n    let mut configurator = Configurator::new();\n    configurator.add_history(history_type, path_buf);\n    configurator.save_config();\n    Ok(())\n}", "id": 155, "concepts": ["conditional check", "path validity", "file I/O", "string formatting", "function composition", "named parameters"], "instruction": "Design a Rust class that implements a simple file system by handling file and directory manipulations. The system should allow creating files, deleting files, and moving files within the file system. The class should also support directory search queries, such as the number of files within a directory and the full path of a file.\n\nThe class should handle erroneous inputs gracefully, such as invalid file or directory names, invalid paths, and invalid queries. Additionally, implement the `__str__` method to provide human-readable string representations of the file system state."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async rust, sqlx library, sqlx query, sqlx query parameters, postgresql database connection, database query result handling\n\n### Task", "fingerprint": null, "seed": "async fn save_metric_entry(mut database: &Database, hostname: &str, timestamp: &DateTime<Utc>, entry: DockerContainerMetricEntry) -> Result<(), MetricSaveError> {\n    sqlx::query!(\n        \"insert into metric_docker_containers (hostname, timestamp, name, state, cpu_usage, memory_usage, memory_cache, network_tx, network_rx) values ($1, $2, $3, $4, $5, $6, $7, $8, $9) returning name\",\n        hostname.to_string(), *timestamp, entry.name, entry.state, entry.cpu_usage, entry.memory_usage as i64, entry.memory_cache as i64, entry.network_tx, entry.network_rx\n    ).fetch_one(&mut database).await?;\n\n    Ok(())\n}", "id": 156, "concepts": ["async rust", "sqlx library", "sqlx query", "sqlx query parameters", "postgresql database connection", "database query result handling"], "instruction": "Develop a Rust function that uses the `sqlx` library to connect to a PostgreSQL database and perform a SQL query. The function should take a query string and parameters as input, perform the query, and return the result as an `sqlx::QueryResult`. The function should handle errors appropriately, and should return `Err` if the query fails to run. It should be reusable for multiple queries, where the input parameters are passed in as positional arguments."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: creating a build directory, file system operations, string manipulation and formatting\n\n### Task", "fingerprint": null, "seed": "fn build_dev() {\n    let project = project(\"build_dev\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_dev_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_dev_b\")\n        .assert()\n        .success();\n\n    // Build to ensure that the build directory is created and\n    // `fuzz_build_dir()` won't panic.\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"--dev\")\n        .assert()\n        .success();\n\n    let build_dir = project.fuzz_build_dir().join(\"debug\");\n\n    let a_bin = build_dir.join(\"build_dev_a\");\n    let b_bin = build_dir.join(\"build_dev_b\");\n\n    // Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    // Test that building all fuzz targets does in fact recreate the files.\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"--dev\")\n        .assert()\n        .success();\n\n    assert!(a_bin.is_file());\n    assert!(b_bin.is_file());\n}", "id": 157, "concepts": ["creating a build directory", "file system operations", "string manipulation and formatting"], "instruction": "Design a Rust program that builds a source file. The program takes one positional parameter: a path to a source file. The program should read the given source file, find all the functions in the file, and produce a build script that adds a target to the build process for each function. The build script should also generate a file named `functions.rs` that contains the re-exported functions.\n\nThe build script should include a target for each function and a target for `functions.rs` that builds `functions.rs`. The build script should include a target for the main source file that depends on all the functions. The build script should also include a top-level target that builds the program.\n\nThe generated `functions.rs` should create aliases for the re-exported functions. For example, `functions.rs` might contain:\n```rust\npub use crate::functions::hello as hello_world;\npub use crate::functions::goodbye as goodbye_world;\n```\nThe generated `functions.rs` must be relative to the source file, and it should be included at the top of the source file.\n\nThe generated `build.rs` should include a main function that invokes `cargo build` with the correct arguments. `build.rs` must be relative to the source file.\n\nThe generated build script must use the correct build feature.\n\nThe generated build script must generate one target for each function in the source file. The target must include the function's body as an attribute.\n\nThe generated build script must generate a target for the source file that depends on all the functions.\n\nThe generated build script must generate a top-level target that builds the program.\n\nThe generated build script must include a top-level target that runs the test suite.\n\nThe solution should include robust error handling to deal with the case where the source file does not exist or is not a file.\n\nThe solution should also include a relative path to the source file instead of an absolute path."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: conditional branching, multiple file input operations, string operations, new line character removal, nested loops\n\n### Task", "fingerprint": null, "seed": "fn parseModelInfo(reader: &mut BufReader<&File>, buf: &mut String, models: &mut Vec<Model>, basePath: &str) -> Model {\r\n    //Firstly, read the meshId and materialId;\r\n    reader.read_line(buf);\r\n    let mut split_info = buf.split(\" \");\r\n    if len(split_info) != 2 {}\r\n    let meshId: i32 = split_info.next().unwrap().parse().unwrap();\r\n    let materidId = split_info.next().unwrap().parse().unwrap();\r\n    let meshFilePath = basePath + \"/meshes/\" + meshId + \"_mesh.obj\";\r\n    let materialPath = basePath + \"/materials/\" + materidId + \"/\" + materidId;\r\n    //Then, read the position info;\r\n    split_info = buf.split(\" \");\r\n    let mut modelInfo: Vec<Vec3f> = Vec::new();\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 3 {\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        modelInfo.push(Vec3f {\r\n            x: split_info.next().unwrap().parse().unwrap(),\r\n            y: split_info.next().unwrap().parse().unwrap(),\r\n            z: split_info.next().unwrap().parse().unwrap(),\r\n        });\r\n        infoIndex += 1;\r\n    }\r\n    loadImageFromMaterial(model, materidId);\r\n\r\n    models.push(Model {\r\n        meshId,\r\n        materidId: 0,\r\n        position: Vec3f {\r\n            x: modelInfo.get(0).unwrap().x,\r\n            y: modelInfo.get(0).unwrap().y,\r\n            z: modelInfo.get(0).unwrap().z,\r\n        },\r\n        rotation: Vec3f {\r\n            x: modelInfo.get(1).unwrap().x,\r\n            y: modelInfo.get(1).unwrap().y,\r\n            z: modelInfo.get(1).unwrap().z,\r\n        },\r\n        scaling: Vec3f {\r\n            x: modelInfo.get(2).unwrap().x,\r\n            y: modelInfo.get(2).unwrap().y,\r\n            z: modelInfo.get(2).unwrap().z,\r\n        },\r\n    }\r\n    );\r\n\r\n    //Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n}", "id": 158, "concepts": ["conditional branching", "multiple file input operations", "string operations", "new line character removal", "nested loops"], "instruction": "Design a Rust function that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. The function should return the output of the last executed command. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: recursion, iterative implementation, branching based on conditional return\n\n### Task", "fingerprint": null, "seed": "pub fn merge_sort<T: PartialOrd + Debug>(mut v: Vec<T>) -> Vec<T> {\n    // sort the left half\n    // sort the right half O(n*ln(n))\n    // bring the sorted half together O(n)\n    if v.len() <= 1 {\n        return v;\n    }\n    let mut res = Vec::with_capacity(v.len());\n    let b = v.split_off(v.len()/2);\n    let a = merge_sort(v);\n    let b = merge_sort(b);\n    // bring them together again add whichever is lowest the front of a or the front of b\n    let mut a_it = a.into_iter();\n    let mut b_it = b.into_iter();\n    let mut a_peek = a_it.next();\n    let mut b_peek = b_it.next();\n    loop {\n        match a_peek {\n            Some(ref a_val) => match b_peek{\n                Some(ref b_val) =>{\n                    if b_val < a_val {\n                        res.push(b_peek.take().unwrap());\n                        b_peek = b_it.next();\n                    } else {\n                        res.push(a_peek.take().unwrap());\n                        a_peek = a_it.next();\n                    }\n                }\n                None => {\n                    res.push(a_peek.take().unwrap());\n                    res.extend(a_it);\n                    return res;\n                }\n            }\n            None => {\n                if let Some(b_val) = b_peek {\n                    res.push(b_val);\n                }\n                res.extend(b_it);\n                return res;\n            }\n        }\n    }\n}", "id": 159, "concepts": ["recursion", "iterative implementation", "branching based on conditional return"], "instruction": "Design a Rust function that calculates the factorial of a given number recursively and iteratively. The iterative implementation should be implemented using a loop and the recursive implementation should use function recursion.\n\nFor example, given `num = 5`, the function should calculate the factorial recursively and return `120` as the result."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: fuzzing, crash reporting, fuzzing failure handling, fuzzing failure reporting\n\n### Task", "fingerprint": null, "seed": "fn run_with_crash() {\n    let project = project(\"run_with_crash\")\n        .with_fuzz()\n        .fuzz_target(\n            \"yes_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    run_with_crash::fail_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"yes_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .env(\"RUST_BACKTRACE\", \"1\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"panicked at 'I'm afraid of number 7'\")\n                .and(predicate::str::contains(\"ERROR: libFuzzer: deadly signal\"))\n                .and(predicate::str::contains(\"run_with_crash::fail_fuzzing\"))\n                .and(predicate::str::contains(\n                    \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\\n                     \\n\\\n                     Failing input:\\n\\\n                     \\n\\\n                     \\tfuzz/artifacts/yes_crash/crash-\"\n                ))\n                .and(predicate::str::contains(\"Output of `std::fmt::Debug`:\"))\n                .and(predicate::str::contains(\n                    \"Reproduce with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz run yes_crash fuzz/artifacts/yes_crash/crash-\"\n                ))\n                .and(predicate::str::contains(\n                    \"Minimize test case with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz tmin yes_crash fuzz/artifacts/yes_crash/crash-\"\n                )),\n        )\n        .failure();\n}", "id": 160, "concepts": ["fuzzing", "crash reporting", "fuzzing failure handling", "fuzzing failure reporting"], "instruction": "Design a Rust function that accepts a source file path and returns a list of unique lines in the file. The function should be able to handle corrupt or invalid input by reporting an error.\n\nFor example, given a source file that contains the following lines:\n\n```\nThis is the first line.\nThis is the second line.\nThis is the third line.\n```\n\nThe function should return a list of unique lines:\n\n```\n['This is the first line.', 'This is the second line.', 'This is the third line.']\n```\n\nInclude error handling and reporting to handle invalid inputs such as empty or nonexistent files, as well as cases where the source file is corrupt or has invalid syntax."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: list comprehension, pattern matching, hash map lookup, list filtering\n\n### Task", "fingerprint": null, "seed": "fn get_submodules(\n    repo: &Repository,\n    at: &Commit,\n) -> Result<Vec<Submodule>, Box<dyn std::error::Error>> {\n    let submodule_cfg = modules_file(&repo, &at)?;\n    let submodule_cfg = Config::parse(&submodule_cfg)?;\n    let mut path_to_url = HashMap::new();\n    let entries = submodule_cfg.entries(None)?;\n    for entry in &entries {\n        let entry = entry?;\n        let name = entry.name().unwrap();\n        if name.ends_with(\".path\") {\n            let url = name.replace(\".path\", \".url\");\n            let url = submodule_cfg.get_string(&url).unwrap();\n            path_to_url.insert(entry.value().unwrap().to_owned(), url);\n        }\n    }\n    let mut submodules = Vec::new();\n    let tree = at.tree()?;\n    for (path, url) in &path_to_url {\n        let path = Path::new(&path);\n        let entry = tree.get_path(&path);\n        // the submodule may not actually exist\n        let entry = match entry {\n            Ok(e) => e,\n            Err(_) => continue,\n        };\n        assert_eq!(entry.kind().unwrap(), git2::ObjectType::Commit);\n        submodules.push(Submodule {\n            path: path.to_owned(),\n            commit: entry.id(),\n            repository: url.to_owned(),\n        });\n    }\n    submodules.retain(|s| {\n        let is_rust =\n            s.repository.contains(\"rust-lang\") || s.repository.contains(\"rust-lang-nursery\");\n        let exclude = vec![\n            \"https://github.com/rust-lang/llvm.git\",\n            \"https://github.com/rust-lang/llvm-project.git\",\n            \"https://github.com/rust-lang/lld.git\",\n            \"https://github.com/rust-lang-nursery/clang.git\",\n            \"https://github.com/rust-lang-nursery/lldb.git\",\n            \"https://github.com/rust-lang/libuv.git\",\n            \"https://github.com/rust-lang/gyp.git\",\n            \"https://github.com/rust-lang/jemalloc.git\",\n            \"https://github.com/rust-lang/compiler-rt.git\",\n            \"https://github.com/rust-lang/hoedown.git\",\n        ];\n        is_rust\n            && !exclude.contains(&s.repository.as_str())\n            && !exclude.contains(&&*format!(\"{}.git\", s.repository))\n    });\n    Ok(submodules)\n}", "id": 161, "concepts": ["list comprehension", "pattern matching", "hash map lookup", "list filtering"], "instruction": "Create a Rust program that takes a list of integers and filters out the even numbers. The program should also calculate and print the total count of even numbers."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: hash-map of hash-map with mutable access, list comprehension in a function, pass-by-reference\n\n### Task", "fingerprint": null, "seed": "fn a_table_should_preserve_the_money_supply() {\n  let mut table = HashMapOfTreeMap::new();\n  broker(&mut table, 1000);\n  expect_money_conserved(&table);\n}", "id": 162, "concepts": ["hash-map of hash-map with mutable access", "list comprehension in a function", "pass-by-reference"], "instruction": "Design a Rust function that takes a list of strings and return a list of the unique strings in alphabetical order. The function should be designed to be high performance and efficient in both memory and time complexity.\n\nYou may create a hash-map of hash-map as a data structure to store the unique characters and their frequency count. The function can be implemented in a reusable way that can easily apply to any list of strings. The function would also be able to handle the case where the list of strings is empty."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: async-await, thread pool usage, named tuples, closures, data parallelism, concurrency\n\n### Task", "fingerprint": null, "seed": "fn main() -> Result<()> {\n    let args = Args::parse();\n    let Args {\n        aspect_ratio,\n        image_width,\n        image_height,\n        samples_per_pixel,\n        outfile,\n        max_depth,\n    } = args;\n\n    let (stats_tx, stats_rx) = unbounded();\n    let (render_tx, render_rx) = bounded(1024);\n\n    let look_from = Point3::new(13.0, 2.0, 3.0);\n    let look_at = Point3::new(0.0, 0.0, 0.0);\n\n    // Camera\n    let camera = Camera::new(\n        look_from,\n        look_at,\n        Vec3::new(0.0, 1.0, 0.0),\n        20.0,\n        aspect_ratio,\n        0.1,\n        10.0,\n    );\n\n    // World\n    let world = World::get_world(true);\n\n    let color_handle = thread::spawn(move || {\n        pixels::pixel_loop(\n            &camera,\n            &world,\n            image_width,\n            image_height,\n            samples_per_pixel,\n            max_depth,\n            stats_tx,\n            render_tx,\n        )\n    });\n\n    let stats_handle = thread::spawn(move || {\n        stats::stats_loop(\n            stats_rx,\n            ((image_width as f32 * image_height as f32 * 11.3) as usize + 24) as usize,\n        )\n    });\n    let render_handle = thread::spawn(move || render::render_loop(&outfile, render_rx));\n\n    let color_io_result = color_handle.join().unwrap();\n    let stats_io_result = stats_handle.join().unwrap();\n    let render_io_result = render_handle.join().unwrap();\n\n    color_io_result?;\n    stats_io_result?;\n    render_io_result?;\n\n    Ok(())\n}", "id": 163, "concepts": ["async-await", "thread pool usage", "named tuples", "closures", "data parallelism", "concurrency"], "instruction": "Design a Rust function that accepts a list of integers and returns a tuple of two lists: one containing the even and one containing the odd numbers from the input list. The function should be asynchronous, using both threads and the `tokio` crate, and use a thread pool to handle the heavy computation."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: async-await, rayon rayon::join, list splitting\n\n### Task", "fingerprint": null, "seed": "pub fn quick_sort_rayon<T: Send + PartialOrd + Debug>(v: &mut[T]) {\n    if v.len() <= 1 {\n        return;\n    }\n    let p = pivot(v);\n    println!(\"{:?}\", v);\n    let (a, b) = v.split_at_mut(p);\n    // put f2 on queue then start f1;\n    // if another thread is ready it will steal f2\n    // this works recursively recursively down the stack\n    rayon::join(||quick_sort_rayon(a), || quick_sort_rayon(&mut b[1..]));\n}", "id": 164, "concepts": ["async-await", "rayon rayon::join", "list splitting"], "instruction": "Implement a Rust program that takes a list of URLs and fetches them in parallel. The program should use `tokio` for asynchronous network communication and `rayon` for parallel execution. The program should split the list into multiple sublists of `MAX_CONCURRENCY` URLs and call the `fetch_url` function for each sublist, where `MAX_CONCURRENCY` is a constant value set to `15`. This allows for the program to utilize multiple threads for network communication and to execute multiple requests in parallel."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async-await, custom debugger, multithreading, atomic variable increments\n\n### Task", "fingerprint": null, "seed": "pub fn test_ebreak() {\n    let buffer = fs::read(\"tests/programs/ebreak64\").unwrap().into();\n    let value = Arc::new(AtomicU8::new(0));\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .debugger(Box::new(CustomDebugger {\n            value: Arc::clone(&value),\n        }))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"ebreak\".into()])\n        .unwrap();\n    assert_eq!(value.load(Ordering::Relaxed), 1);\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(value.load(Ordering::Relaxed), 2);\n}", "id": 165, "concepts": ["async-await", "custom debugger", "multithreading", "atomic variable increments"], "instruction": "Design a Rust function that takes a list of numbers and returns a list of the unique elements in the original list, while maintaining the original order of those elements. The function should be implemented in a way that uses `async-await` syntax and `async` functions to efficiently process the input. The function should also handle cases where input is a list of nested lists.\n\nFor example, given `list = [[1, 2, 3], [3], [1, 2, 3]]`, the function should return `[1, 2, 3]`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: Rust function format, indentation, multi-line string, list expression, test assertion\n\n### Task", "fingerprint": null, "seed": "fn\ntest_str\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\n\"\nhello\nworld\n!\n\"\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\ns\n]\n)\n?\n;\nlet\nfrom\n:\nString\n=\ndb\n.\none_column\n(\n\"\nSELECT\nt\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nfrom\ns\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 166, "concepts": ["Rust function format", "indentation", "multi-line string", "list expression", "test assertion"], "instruction": "Design a Rust function that takes in a list of integers and returns a string representation of an arithmetic expression that calculates the sum of the list numbers.\n\nThe expression should be formatted with the following rules:\n\n1. The list contains at least one element.\n2. The expression is wrapped in parentheses.\n3. The expression is separated from the next element with a space.\n4. The operator between two consecutive list elements is wrapped in parentheses.\n5. The operator between a list element and a single-element sub-expression is wrapped in parentheses.\n6. Do not add spaces around the operator.\n7. Do not add spaces between the sub-expression and the operator.\n8. Do not add spaces between consecutive operators.\n9. Do not add spaces between a sub-expression and its parentheses.\n10. Do not add spaces between a list element and its parentheses.\n11. Do not add spaces before a sub-expression's parentheses.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(\n  arithmetic_expression([1, 2, 3]).unwrap(),\n  \"((1 + 2) + 3)\",\n);\nassert_eq!(\n  arithmetic_expression([1, 2, 3, 4, 5]).unwrap(),\n  \"(((1 + 2) + 3) + 4) + 5\",\n);\nassert_eq!(\n  arithmetic_expression([1, 2, 3, 4, 5, 6, 7, 8, 9]).unwrap(),\n  \"((((((1 + 2) + 3) + 4) + 5) + 6) + 7) + 8) + 9\",\n);\nassert_eq!(\n  arithmetic_expression([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]).unwrap(),\n  \"((((((((1 + 2) + 3) + 4) + 5) + 6) + 7) + 8) + 9) + 10) + 11\",\n);\nassert_eq!(\n  arithmetic_expression([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).unwrap(),\n  \"((((((((1 + 2) + 3) + 4) + 5) + 6) + 7) + 8) + 9) + 10)\",\n);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: list-based filtering, list-based comparisons, error handling with try-catch, string interpolation\n\n### Task", "fingerprint": null, "seed": "fn list_migration_directories_with_an_empty_migrations_folder_works(api: TestApi) {\n    let migrations_directory = api.create_migrations_directory();\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[]);\n}", "id": 167, "concepts": ["list-based filtering", "list-based comparisons", "error handling with try-catch", "string interpolation"], "instruction": "Design a Rust function that takes two lists of strings, `str1` and `str2`, and returns a new list of strings that contains all of the elements from both lists that do not appear in any of the other lists. The function should throw an error if any of the lists is empty. If the lists are the same, the function should return an empty list.\n\nThe solution should utilize a list comprehension for the filtering logic, and appropriate error handling for the case when the function is called with empty lists."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string literals, raw string literals, byte strings, string concatenation, string traversal and string splitting, string manipulation, string comparisons\n\n### Task", "fingerprint": null, "seed": "fn string_test() {\n    // literal\n    let speech = \"\\\"Ouch!\\\" said the well.\\n\";\n    println!(\"{}\", speech);\n    println!(\n        \"In the room the women come and go,\n         Singing of Mount Abora\"\n    );\n    println!(\n        \"It was a bright, cold day in Aplil, and \\\n         there were four of us \\\n         more or less.\"\n    );\n\n    let default_win_install_path = r\"C:\\Program Files\\Gorillas\";\n    println!(\"{}\", default_win_install_path);\n    // let pattern = Regex::new(r\"\\d(\\.\\d+)*\");\n\n    println!(\n        r###\"\n        This raw string started with 'r###\"'.\n        Therefore it does not end until we reach a quote mark ('\"')\n        followed immediately by three pound signs ('###'):\n    \"###\n    );\n\n    // byte strings\n    let method = b\"GET\";\n    assert_eq!(method, &[b'G', b'E', b'T']);\n\n    let noodles = \"noodles\".to_string();\n    let oodles = &noodles[1..];\n    let poodles = \"\\u{CA0}_\\u{CA0}\";\n\n    assert_eq!(oodles.len(), 6);\n    assert_eq!(poodles.len(), 7);\n    assert_eq!(poodles.chars().count(), 3);\n\n    // let mut s = \"hello\";\n    // s[0] = 'c'; error: tye thpe 'str' cannot be mutably indexed\n    // s.push('\\n'); error: no method named `push` found for type `&str`\n\n    assert_eq!(\n        format!(\"{}\u00b0 {:02}\u2019 {:02}\u201d N\", 24, 5, 23),\n        \"24\u00b0 05\u2019 23\u201d N\".to_string()\n    );\n    let bits = vec![\"veni\", \"vidi\", \"vici\"];\n    assert_eq!(bits.concat(), \"venividivici\");\n    assert_eq!(bits.join(\",\"), \"veni,vidi,vici\");\n\n    assert!(\"ONE\".to_lowercase() == \"one\");\n\n    assert!(\"peanut\".contains(\"nut\"));\n    assert_eq!(\"\\u{CA0}_\\u{CA0}\".replace(\"\\u{CA0}\", \"\u25a0\"), \"\u25a0_\u25a0\");\n    assert_eq!(\"     clean\\n\".trim(), \"clean\");\n\n    for word in \"veni, vidi, vici\".split(\", \") {\n        assert!(word.starts_with(\"v\"));\n    }\n}", "id": 168, "concepts": ["string literals", "raw string literals", "byte strings", "string concatenation", "string traversal and string splitting", "string manipulation", "string comparisons"], "instruction": "Write a Rust function that takes two strings as arguments and returns a boolean value indicating whether or not the first string can be constructed by concatenating the second string with itself. The function should handle string concatenation for `N > 1` times, where `N` is the length of the second string.\n\nFor example, the function should return `True` for the following input:\n\n```rust\nassert_eq!(can_be_concatenated(\"abc\", \"cab\"), true);\nassert_eq!(can_be_concatenated(\"ac\", \"bc\"), true);\nassert_eq!(can_be_concatenated(\"a\", \"bc\"), false);\nassert_eq!(can_be_concatenated(\"ab\", \"ca\"), false);\n```\n\n# Result"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string splitting, tuple assignment, tuple destructuring, string indexing\n\n### Task", "fingerprint": null, "seed": "fn tuple_test() {\n    let text = \"I see the eigenvalue in thine eye\";\n    let (head, tail) = text.split_at(21);\n    assert_eq!(head, \"I see the eigenvalue \");\n    assert_eq!(tail, \"in thine eye\");\n}", "id": 169, "concepts": ["string splitting", "tuple assignment", "tuple destructuring", "string indexing"], "instruction": "Write a Rust function that extracts all unique characters from a string and returns a list of the characters in sorted order.\n\nFor example, given the string `\"hello\"` the function should return the list `[\"e\", \"h\", \"l\", \"o\"]`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call implementation, channel take with no payload, system call parameter retrieval, return value handling\n\n### Task", "fingerprint": null, "seed": "fn channel_take_nonpayload(target: CAddr) -> ChannelMessage {\n    let result = system_call(SystemCall::ChannelTake {\n        request: target,\n        response: None\n    });\n    match result {\n        SystemCall::ChannelTake {\n            response, ..\n        } => {\n            return response.unwrap()\n        },\n        _ => panic!(),\n    };\n}", "id": 171, "concepts": ["system call implementation", "channel take with no payload", "system call parameter retrieval", "return value handling"], "instruction": "Write a Rust function that simulates a system call for writing to a file. The function should accept three parameters: `filename`, `data`, and `newline`. The function should write the data string to the file, with an optional newline character. The function should return the number of bytes written to the file, or a negative value in case of an error."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: bitwise alignment of values without using division, bitwise operation for alignment, input validation with assertions\n\n### Task", "fingerprint": null, "seed": "fn align_to(size: uint, align: uint) -> uint {\n\t    assert!(align != 0);\n\t\t    (size + align - 1) & !(align - 1)\n}", "id": 172, "concepts": ["bitwise alignment of values without using division", "bitwise operation for alignment", "input validation with assertions"], "instruction": "Write a Rust function that takes an integer value and returns a new value in which 5 bits are shifted to the right by 3 positions. Do not use division for this operation. Employ bitwise operations for this process."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: solid principles of software design: single responsibility, dependency inversion\n\n### Task", "fingerprint": null, "seed": "pub fn test_nop() {\n    let buffer = fs::read(\"tests/programs/nop\").unwrap().into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"nop\".into()]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}", "id": 173, "concepts": ["solid principles of software design: single responsibility", "dependency inversion"], "instruction": "Design a Rust program that simulates a card game for two players. The two players take turns to draw cards from a deck of 52 cards. Each player has a hand that starts out empty. The program should run over multiple rounds until the deck is empty. At the beginning of each round, the program should print the player's hand, the total score they have earned so far, and the number of cards in the deck.\n\nThe program should then prompt each player for their next move, where the player can either choose to draw a card from the deck, or pass. If the player draws a card, the program should add the card to their hand and remove it from the deck. If the player chooses to pass, the program should not modify their hand or the deck. The program should continue drawing cards for each player until someone has 21 or more cards in their hand. If the player has 21 or more cards, the program should announce the winner and ask if they want to play another round. If the player chooses to play another round, the program should reset the deck and start the next round. If the player chooses to exit, the program should print the scores of both players and end.\n\nYou can use this list of card numbers to represent the cards: `[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]` where 2 represents the Ace card, 11 represents the Jack card, 12 represents the Queen card, and 13 represents the King card.\n\nThe program should use the following dependencies:\n- A Card class containing an integer representing the card number and a string representing the card's textual value.\n- A Deck class with a list of cards that can be shuffled, drawn, and reset."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: image rendering, SDL2 image creation, SDL2 event handling\n\n### Task", "fingerprint": null, "seed": "fn show_image(image: &Image)\n{\n    let sdl             = sdl2::init().unwrap();\n    let video_subsystem = sdl.video().unwrap();\n    let display_mode    = video_subsystem.current_display_mode(0).unwrap();\n\n    let w = match display_mode.w as u32 > image.width {\n        true  => image.width,\n        false => display_mode.w as u32\n    };\n    let h = match display_mode.h as u32 > image.height {\n        true  => image.height,\n        false => display_mode.h as u32\n    };\n    \n    let window = video_subsystem\n        .window(\"Image\", w, h)\n        .build()\n        .unwrap();\n    let mut canvas = window\n        .into_canvas()\n        .present_vsync()\n        .build()\n        .unwrap();\n    let black = sdl2::pixels::Color::RGB(0, 0, 0);\n\n    let mut event_pump = sdl.event_pump().unwrap();\n    // render image\n        canvas.set_draw_color(black);\n        canvas.clear();\n\n        for r in 0..image.height {\n            for c in 0..image.width {\n                let pixel = &image.pixels[image.height as usize - r as usize - 1][c as usize];\n                canvas.set_draw_color(Color::RGB(pixel.R as u8, pixel.G as u8, pixel.B as u8));\n                canvas.fill_rect(Rect::new(c as i32, r as i32, 1, 1)).unwrap();\n            }\n        }\n        \n        canvas.present();\n\n    'main: loop \n    {        \n        for event in event_pump.poll_iter() {\n            match event {\n                sdl2::event::Event::Quit {..} => break 'main,\n                _ => {},\n            }\n        }\n\n        sleep(Duration::new(0, 250000000));\n    }\n    \n}", "id": 175, "concepts": ["image rendering", "SDL2 image creation", "SDL2 event handling"], "instruction": "Design a Rust program that displays an image on a window using the SDL2 graphics library. The program should receive the path to an image file as a command-line argument. The program should first load the image file into a `Surface` object. The program should then make a window with a fixed size and render the image in the window. The window should run a loop that awaits for user input. The program should handle window resizing events and close the window when the user presses the escape key."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: unsafe blocks, function pointer dereference, pointer arithmetic, pointer conversions, pointer dereferencing, pointer arithmetic, pointer conversions, pointer dereferencing, pointer arithmetic, pointer conversions, pointer dereferencing, pointer arithmetic, pointer conversions, pointer dereferencing, pointer arithmetic, pointer conversions, pointer dereferencing, pointer arithmetic, pointer conversions, pointer dereferencing, pointer arithmetic, pointer conversions, pointer dereferencing, pointer arithmetic, pointer conversions, pointer dereferencing\n\n### Task", "fingerprint": null, "seed": "pub unsafe extern \"C\" fn gatt_svr_register_cb(\n    ctxt: *mut ble_gatt_register_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) {\n    let mut buf_arr: [i8; BLE_UUID_STR_LEN as usize] = [0; BLE_UUID_STR_LEN as usize];\n    let buf = buf_arr.as_mut_ptr();\n\n    match (*ctxt).op as u32 {\n        BLE_GATT_REGISTER_OP_SVC => {\n            printf(\n                cstr!(\"registered service %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.svc.svc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.svc.handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_CHR => {\n            printf(\n                cstr!(\"registering characteristic %s with def_handle=%d val_handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.chr.chr_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.chr.def_handle as i32,\n                (*ctxt).__bindgen_anon_1.chr.val_handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_DSC => {\n            printf(\n                cstr!(\"registering descriptor %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.dsc.dsc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.dsc.handle as i32,\n            );\n        }\n        _ => {\n            printf(cstr!(\"unknown operation: %d\\n\"), (*ctxt).op as u32);\n        }\n    }\n}", "id": 176, "concepts": ["unsafe blocks", "function pointer dereference", "pointer arithmetic", "pointer conversions", "pointer dereferencing", "pointer arithmetic", "pointer conversions", "pointer dereferencing", "pointer arithmetic", "pointer conversions", "pointer dereferencing", "pointer arithmetic", "pointer conversions", "pointer dereferencing", "pointer arithmetic", "pointer conversions", "pointer dereferencing", "pointer arithmetic", "pointer conversions", "pointer dereferencing", "pointer arithmetic", "pointer conversions", "pointer dereferencing", "pointer arithmetic", "pointer conversions", "pointer dereferencing"], "instruction": "Design a Rust class that holds a list of function pointers of the same type. The class should implement a method `apply_to_all_elements(self, arg: T)` to apply a function to all elements of the list. The method should accept a function pointer as an argument and use it to apply the function to each element of the list.\n\nThe class should implement the following assertions:\n```rust\nlet pointers: Vec<fn() -> i32> = vec![];\nassert_eq!(pointers.apply_to_all_elements(add_one), vec![1, 1, 1]);\nlet pointers: Vec<fn() -> i32> = vec![add_one];\nassert_eq!(pointers.apply_to_all_elements(add_one), vec![2]);\nlet pointers: Vec<fn() -> i32> = vec![add_one, add_one, add_one];\nassert_eq!(pointers.apply_to_all_elements(add_one), vec![3, 3, 3]);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: conditional parsing, type casting, type inference in Rust, trait implementation for custom types\n\n### Task", "fingerprint": null, "seed": "fn de_board(raw: Vec<usize>, t: isize, l: i32, width: u8, height: u8) -> game::Board {\n    let mut res = game::Board::new(t, l, width, height);\n    res.pieces = raw\n        .into_iter()\n        .map(|x| game::Piece::from(x))\n        .collect();\n    res\n}", "id": 177, "concepts": ["conditional parsing", "type casting", "type inference in Rust", "trait implementation for custom types"], "instruction": "Create a Rust function that takes a string as input and returns the length of the longest substring with unique characters. The substring can be overlapping.\n\nFor example, given a string `s = \"abcabcbb\"`, the function should return `3`, where the longest substring is `abc`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: mutability in Rust, slicing and splitting in arrays, disjoint sets for finding connected components\n\n### Task", "fingerprint": null, "seed": "fn get_disjoint<T>(ts: &mut [T], a: usize, b: usize) -> (&mut T, &mut T) {\n    assert!(a != b, \"a ({}) and b ({}) must be disjoint\", a, b);\n    assert!(a < ts.len(), \"a ({}) is out of bounds\", a);\n    assert!(b < ts.len(), \"b ({}) is out of bounds\", b);\n    if a < b {\n        let (al, bl) = ts.split_at_mut(b);\n        (&mut al[a], &mut bl[0])\n    } else {\n        let (bl, al) = ts.split_at_mut(a);\n        (&mut al[0], &mut bl[b])\n    }\n}", "id": 179, "concepts": ["mutability in Rust", "slicing and splitting in arrays", "disjoint sets for finding connected components"], "instruction": "Develop a Rust function that takes a two-dimensional grid as an input and returns a list of lists of coordinates that represent the connected components. The coordinates of each connected component should be represented as a list of two-element tuples.\n\nEach coordinate in the grid represents a cell, and the value of a cell is either 0 or 1. If a cell is 0, it represents an empty cell, and if it is 1, it represents an occupied cell. The connected components are defined as follows:\n\n- A cell is part of a connected component if it is 1 and at least one of its neighboring cells is 1 as well.\n- A cell is considered adjacent to another cell if they share a common side, or if they share a common vertex.\n- In the grid above, a cell is adjacent to another cell if they share a common edge and the values of those two cells are 1.\n\nFor example, given the following grid:\n```\n[\n  [0, 0, 0],\n  [0, 1, 0],\n  [0, 0, 1]\n]\n```\nThe connected components of the grid are as follows:\n```\n[[(0, 1), (1, 1)]]\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: exception frame, panic, panic message with debug info\n\n### Task", "fingerprint": null, "seed": "fn hard_fault(ef: &ExceptionFrame) -> ! {\n    panic!(\"Hardfault... : {:#?}\", ef);\n}", "id": 180, "concepts": ["exception frame", "panic", "panic message with debug info"], "instruction": "Create a Rust class called `Stack` that implements a stack data structure for integers. The class should define the following methods:\n\n- `push(val: i32) -> ()`: push a value onto the stack\n- `pop() -> i32`: pop a value from the stack and return it\n- `peek() -> i32`: return the top value without removing it from the stack\n- `is_empty() -> bool`: return `true` if the stack is empty; otherwise, return `false`\n\nImplement the `Stack` class using the following data structure:\n\n- a vector `vec` that stores the values\n\nUse the following approach with three threads:\n\n- thread 1, starts with `Stack` class, calls `push(1)`, then `push(2)`, then `pop()`, then `is_empty()`, and finally `peek()`\n- thread 2, starts with `Stack` class, calls `push(3)`, then `push(4)`, then `pop()`, then `is_empty()`, and finally `peek()`\n- thread 3, starts with `Stack` class, calls `push(5)`, then `push(6)`, then `pop()`, then `is_empty()`, and finally `peek()`\n\nEnsure that the three threads will experience the same behavior. In other words, ensure that the sequence of output values is always the same across all three threads."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: conditional compilation, multiple versions of an API in Rust, conditional compilation for conditional compilation\n\n### Task", "fingerprint": null, "seed": "pub fn test_contains_ckbforks_section() {\n    let buffer = fs::read(\"tests/programs/ckbforks\").unwrap();\n    let ckbforks_exists_v0 = || -> bool {\n        let elf = goblin_v023::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    let ckbforks_exists_v1 = || -> bool {\n        let elf = goblin_v040::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    assert_eq!(ckbforks_exists_v0, true);\n    assert_eq!(ckbforks_exists_v1, true);\n}", "id": 183, "concepts": ["conditional compilation", "multiple versions of an API in Rust", "conditional compilation for conditional compilation"], "instruction": "Create a program that counts the number of prime numbers less than the specified limit, using the 'find_nth_prime_memoized' method from the previous example."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: hash table implementation in Rust, functional programming in Rust, trait implementation in Rust, type casting in Rust\n\n### Task", "fingerprint": null, "seed": "fn a_table_should_read_0_for_any_key() {\n  let mut table = HashMapOfTreeMap::new();\n  let mut vs = [Value::default(); 1];\n  table.read (0, &[0], &mut vs);\n  match vs {\n    [Value { v: 0, t: 0}] => (),\n    _ => assert!(false)\n  }\n}", "id": 184, "concepts": ["hash table implementation in Rust", "functional programming in Rust", "trait implementation in Rust", "type casting in Rust"], "instruction": "Develop a Rust function to implement a hash table, which is a data structure that stores key-value pairs in a way that allows for fast lookup by key. The hash table should use a trait to specify the storage type and include methods to insert a new value, retrieve an existing value, and delete a key-value pair. The function should also include assertions to verify that the key and value are not empty strings."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string slicing, string formatting, chaining iterators, string formatting with named arguments, string formatting with arguments in a fixed order\n\n### Task", "fingerprint": null, "seed": "pub fn debug_format(input: String) -> String {\n    if input.len() <= 20 {\n        return input;\n    }\n    input\n        .chars()\n        .take(8)\n        .chain(\"...\".chars())\n        .chain(input.chars().skip(input.len() - 8))\n        .collect()\n}", "id": 185, "concepts": ["string slicing", "string formatting", "chaining iterators", "string formatting with named arguments", "string formatting with arguments in a fixed order"], "instruction": "Create a Rust function to format a string into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: thread-safe, error handling, variable setting, ownership transfer\n\n### Task", "fingerprint": null, "seed": "pub fn set_working_folder(working_folder: String) -> Result<(), ()> {\n    unsafe {\n        WORKING_FOLDER = working_folder;\n    }\n    Ok(())\n}", "id": 186, "concepts": ["thread-safe", "error handling", "variable setting", "ownership transfer"], "instruction": "Develop a Rust class that implements a thread-safe queue of data. The queue class should provide the following methods:\n- `enqueue(data)`: add data into a queue\n- `dequeue()`: remove and return the next data in the queue\n- `peek()`: return the next data in the queue without removing\n\nImplement the class using a data structure called `RingBuffer` that implements a ring buffer to store the data. The class should handle any issues related to data handling and ownership."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: async/await, event-driven programming, web-assembly, state management, input validation, rendering 3D graphics\n\n### Task", "fingerprint": null, "seed": "pub async fn render_window_wasm(subaction: brawllib_rs::high_level_fighter::HighLevelSubaction) {\n    use brawllib_rs::renderer::app::state::{AppEventIncoming, State};\n    use brawllib_rs::renderer::app::App;\n    use wasm_bindgen::prelude::*;\n    use web_sys::HtmlElement;\n\n    let document = web_sys::window().unwrap().document().unwrap();\n\n    let body = document.body().unwrap();\n    let parent_div = document.create_element(\"div\").unwrap();\n    parent_div\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .style()\n        .set_css_text(\"margin: auto; width: 80%; aspect-ratio: 4 / 2; background-color: black\");\n    body.append_child(&parent_div).unwrap();\n\n    let app = App::new_insert_into_element(parent_div, subaction).await;\n    let event_tx = app.get_event_tx();\n\n    let frame = document.create_element(\"p\").unwrap();\n    frame.set_inner_html(\"Frame: 0\");\n    body.append_child(&frame).unwrap();\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Run\");\n    let event_tx_move = event_tx.clone();\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Stop\" {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Pause))\n                .unwrap();\n            button_move.set_inner_html(\"Run\");\n        } else {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Play))\n                .unwrap();\n            button_move.set_inner_html(\"Stop\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Perspective\");\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Orthographic\" {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(false))\n                .unwrap();\n            button_move.set_inner_html(\"Perspective\");\n        } else {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(true))\n                .unwrap();\n            button_move.set_inner_html(\"Orthographic\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    app.get_event_tx()\n        .send(AppEventIncoming::SetState(State::Pause))\n        .unwrap();\n\n    app.run();\n}", "id": 187, "concepts": ["async/await", "event-driven programming", "web-assembly", "state management", "input validation", "rendering 3D graphics"], "instruction": "Implement a Rust program utilizing async/await constructs for event-driven programming. The program should render 3D graphics based on provided input data, such as colors, position, and size, including animation and transitions. Additionally, provide input validation and error handling for handling invalid input such as out-of-range values."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: C language, casting between different Rust types, unsafe Rust operations, string literals, string conversion, bitwise shifts\n\n### Task", "fingerprint": null, "seed": "extern \"C\" fn gatt_svr_chr_access_device_info(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_MODEL_NUMBER_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MODEL_NUM.as_ptr() as *const c_void,\n                MODEL_NUM.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    if uuid == GATT_MANUFACTURER_NAME_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MANUF_NAME.as_ptr() as *const c_void,\n                MANUF_NAME.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}", "id": 188, "concepts": ["C language", "casting between different Rust types", "unsafe Rust operations", "string literals", "string conversion", "bitwise shifts"], "instruction": "Design a Rust function `is_prime_number` that determines whether an integer is a prime number. The function should use bitwise operators to check whether an integer is a power of 2, and return True if it is."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: pattern matching, pattern matching on Rust enums\n\n### Task", "fingerprint": null, "seed": "fn handle_trame(trame: Trame) -> Option<Trame> {\n    match (\n        trame.id,\n        trame.cmd,\n        &trame.data[0..trame.data_length as usize],\n    ) {\n        (0...5, 0x0, [0x55]) => Some(trame!(trame.id, 0x00, [0xAA])),\n        (_, _, _) => None,\n    }\n}", "id": 190, "concepts": ["pattern matching", "pattern matching on Rust enums"], "instruction": "Design a Rust function that takes an input string and returns the corresponding enum variant if the input string matches one of the expected values. Otherwise, return None.\n\nFor example, given the input string `Orange`, the function should return `Fruit::Orange`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: Cargo subcommands, command-line argument setting, complex command-line argument usage, assertion with custom message\n\n### Task", "fingerprint": null, "seed": "fn run_diagnostic_contains_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\"run_with_crash\", None);\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"yes_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    run_with_crash::fail_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    let run = format!(\n        \"cargo fuzz run --fuzz-dir {} yes_crash custom_dir/artifacts/yes_crash\",\n        &fuzz_dir\n    );\n\n    let tmin = format!(\n        \"cargo fuzz tmin --fuzz-dir {} yes_crash custom_dir/artifacts/yes_crash\",\n        &fuzz_dir\n    );\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"yes_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(predicates::str::contains(run).and(predicate::str::contains(tmin)))\n        .failure();\n}", "id": 191, "concepts": ["Cargo subcommands", "command-line argument setting", "complex command-line argument usage", "assertion with custom message"], "instruction": "Design a Rust program `cargo-custom_command` that implements a subcommand `mycommand` for the Rust package manager `cargo`. The subcommand should accept a position argument `num` and two optional arguments, `flag1` and `flag2`. The subcommand should output the sum of the position argument and the two optional arguments, or an error message if any of the arguments are not valid integers.\n\nFor example, given the following commands:\n```\n> cargo mycommand 5\nThe sum of 5 and 0 is 5\n> cargo mycommand 5 --flag1 1 --flag2 3\nThe sum of 5 and 6 is 11\n> cargo mycommand 5 --flag1 3\nerror: The sum of 5 and 3 is 8\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: memory leak, pointer arithmetic, Rust code style, static initialization\n\n### Task", "fingerprint": null, "seed": "pub unsafe fn gatt_svr_init() -> i32 {\n    // Leaks the eff out of the svc_def\n    let svcs_ptr = alloc_svc_def();\n    print_svcs(svcs_ptr);\n\n    ble_svc_gap_init();\n    ble_svc_gatt_init();\n\n    let mut rc;\n\n    rc = ble_gatts_count_cfg(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_count_cfg\\n\"));\n\n    rc = ble_gatts_add_svcs(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_add_svcs\\n\"));\n\n    return 0;\n}", "id": 192, "concepts": ["memory leak", "pointer arithmetic", "Rust code style", "static initialization"], "instruction": "Design a Rust class `MemoryLeak` that simulates a memory leak by allocating memory dynamically and not deallocating it after use. The class has two private fields: `size` and `pointer`, where the latter points to a dynamically allocated chunk of memory. The class should also define a static method `new(self, size: usize)` that allocates a chunk of memory of the specified size and returns a new `MemoryLeak` instance.\n\nThe class should have methods to read and write data from the memory chunk that the pointer points to. Each method should raise an appropriate error if the operation attempts to read or write outside the memory chunk. Additionally, write assertions to ensure a memory leak does not occur."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: Rust project setup, Fuzz testing framework, file operations, Rust binary creation and invocation, process execution\n\n### Task", "fingerprint": null, "seed": "fn cmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"foo\");\n    let project = project(\"cmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"foo\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let _ = data;\n                });\n            \"#,\n        )\n        .file(corpus.join(\"0\"), \"\")\n        .file(corpus.join(\"1\"), \"a\")\n        .file(corpus.join(\"2\"), \"ab\")\n        .file(corpus.join(\"3\"), \"abc\")\n        .file(corpus.join(\"4\"), \"abcd\")\n        .build();\n\n    let corpus_count = || {\n        fs::read_dir(project.root().join(\"fuzz\").join(\"corpus\").join(\"foo\"))\n            .unwrap()\n            .count()\n    };\n    assert_eq!(corpus_count(), 5);\n\n    project\n        .cargo_fuzz()\n        .arg(\"cmin\")\n        .arg(\"foo\")\n        .assert()\n        .success();\n    assert_eq!(corpus_count(), 1);\n}", "id": 193, "concepts": ["Rust project setup", "Fuzz testing framework", "file operations", "Rust binary creation and invocation", "process execution"], "instruction": "Create a Rust project with the following requirements:\n\n- A FuzzingBook-style test suite that verifies the correctness of a binary encoding function.\n- A binary program that accepts a single command-line argument that is a sequence of 5-bit chunks. The program should decode this sequence and output the decoded integer.\n- A `.travis.yml` file that uses FuzzingBook's continuous fuzzing framework to automatically run the test suite, and fails the build if any test fails."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: switch statement, bitwise operations on machine code, bitwise operations on single bits\n\n### Task", "fingerprint": null, "seed": "fn parse_prefix_command(rom: &[u8]) -> Option<Box<dyn Instruction>> {\n    let opcode = rom[0];\n    match opcode {\n        /* RLC r */\n        0x00...0x07 => unimplemented!(\"RLC r\"),\n        /* RRC r */\n        0x08...0x0F => unimplemented!(\"RRC r\"),\n        /* RL B */\n        0x10 => cmd!(alu::RotateRegisterLeft(r8!(B))),\n        /* RL C */\n        0x11 => cmd!(alu::RotateRegisterLeft(r8!(C))),\n        /* RL D */\n        0x12 => cmd!(alu::RotateRegisterLeft(r8!(D))),\n        /* RL E */\n        0x13 => cmd!(alu::RotateRegisterLeft(r8!(E))),\n        /* RL H */\n        0x14 => cmd!(alu::RotateRegisterLeft(r8!(H))),\n        /* RL L */\n        0x15 => cmd!(alu::RotateRegisterLeft(r8!(L))),\n        /* RL A */\n        0x17 => cmd!(alu::RotateRegisterLeft(r8!(A))),\n        /* RL (HL) */\n        0x16 => unimplemented!(\"RL (HL)\"),\n        /* RR r */\n        0x17...0x1F => unimplemented!(\"RR r\"),\n        /* SLA r */\n        0x20...0x27 => unimplemented!(\"SLA r\"),\n        /* SRA r */\n        0x27...0x2F => unimplemented!(\"SRA r\"),\n        /* BIT 0,r */\n        0x40...0x47 => unimplemented!(\"BIT 0,r\"),\n        /* BIT 1,r */\n        0x47...0x4F => unimplemented!(\"BIT 1,r\"),\n        /* BIT 7,r */\n        0x78...0x7F => {\n            let bit: u8 = 0b1000_0000;\n            let register = match opcode {\n                0x78 => Register8::B,\n                0x79 => Register8::C,\n                0x7A => Register8::D,\n                0x7B => Register8::E,\n                0x7C => Register8::H,\n                0x7D => Register8::L,\n                // 0x7E => TargetRegister::HL,\n                0x7F => Register8::A,\n                _ => unreachable!()\n            };\n            cmd!(alu::Bit {\n                bit,\n                register\n            })\n        },\n        _ => None\n\n    }\n\n}", "id": 194, "concepts": ["switch statement", "bitwise operations on machine code", "bitwise operations on single bits"], "instruction": "Design a Rust class `Bitwise` with two methods, `set_bit(n, v)` and `get_bit(n)`. The `set_bit(n, v)` method sets the nth bit of a target integer to the value v, where v is either 0 or 1. The `get_bit(n)` method returns the value of the nth bit of a target integer. Additionally, the class should have an `invert_bits(n)` method that returns the bitwise inverse of the first n bits of the target integer."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call, tuple unpacking\n\n### Task", "fingerprint": null, "seed": "pub fn retype_cpool(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeCPool {\n        request: (source, target),\n    });\n}", "id": 195, "concepts": ["system call", "tuple unpacking"], "instruction": "Implement a Rust class named `TextEditOp` with three private fields: `text`, which is the text being modified, `i` and `j`, which are the indices of the start and end of the modified text. Provide a constructor that accepts three arguments of type `String`, and a method `apply(t)` that takes another `TextEditOp` as an argument and applies the changes. The method is supposed to update the `text` field of the current object and update the `i` and `j` fields accordingly. Assume that the `TextEditOp` objects are immutable and the given object is not `None`.\n\nThe `apply` method should use the following steps:\n1. Split the `text` field of the current object into two parts at indices `i` and `j`.\n2. Split the `text` field of the argument object into two parts at indices `i` and `j`, and then concatenate the two parts in the order `(part1, part2)` to form a new string.\n3. Update the `text` field of the current object with the new string.\n4. Update the `i` and `j` fields of the current object to match the indices of the new string.\n\nUse `Option` to handle cases where the given argument is `None` and your code should return `None` as well."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: channel-based communication, system call\n\n### Task", "fingerprint": null, "seed": "pub fn channel_put_cap(target: CAddr, value: CAddr) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Cap(Some(value)))\n    });\n}", "id": 196, "concepts": ["channel-based communication", "system call"], "instruction": "Implement a Rust function that creates a new thread to execute a system shell command. The function should accept a command string as an input. The function should return the output of the shell command as a string. If an exception occurs during the execution of the command, the function should return an empty string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: Rust tests, program execution, custom data types\n\n### Task", "fingerprint": null, "seed": "pub fn test_op_rvc_srai_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_srai_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srai_crash_32\".into()]);\n    assert!(result.is_ok());\n}", "id": 198, "concepts": ["Rust tests", "program execution", "custom data types"], "instruction": "Implement a Rust function that determines whether an input integer is prime or not. Write tests to ensure the function works correctly for various inputs."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: Rust tests, program execution, custom program name, program loading\n\n### Task", "fingerprint": null, "seed": "pub fn test_load_elf_crash_64() {\n    let buffer = fs::read(\"tests/programs/load_elf_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"load_elf_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 199, "concepts": ["Rust tests", "program execution", "custom program name", "program loading"], "instruction": "Implement a Rust class named `Program` that contains several methods to load and execute programs given their file paths. The class should have an attribute `path` of type `String` to store the path of the program to be executed. The class should also have an attribute `name` of type `String` to store the name of the program, which is used to specify the output file name of the program (if the program is run without errors). The class should have the following methods:\n\n- `open_file(path: String)`: open the file whose path is defined by `path`, given a string `path`\n- `execute(name: String)`: execute the program whose file path is stored in `path`, given a string `name`\n\nThe class should be tested to ensure that the program is executed correctly. The tests should also ensure that the path and name attributes are correctly updated."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: character iteration, parsing, input validation\n\n### Task", "fingerprint": null, "seed": "pub fn day09_2(s: String) -> u32{\n    let mut running_total = 0;\n\n    let mut in_garbage = false;\n    let mut prev_cancel = false;\n    for c in s.chars(){\n        if in_garbage {\n            if c == '>' && !prev_cancel {\n                in_garbage = false;\n                prev_cancel = false;\n            }\n            else if c == '!' && !prev_cancel {\n                prev_cancel = true;\n            }\n            else if !prev_cancel{\n                running_total+=1;\n            }\n            else {\n                prev_cancel = false;\n            }\n        }\n        else{\n            if c == '<' {\n                in_garbage = true;\n                prev_cancel = false;\n            }\n        }\n    }\n    running_total\n}", "id": 200, "concepts": ["character iteration", "parsing", "input validation"], "instruction": "Implement a Rust program that reads a text file called `test.txt` (provided), which contains 3000+ lines of text on multiple lines. The program should read each line of text, parse out the first word in the line (before the space), and count the number of occurrences of each word.\n\nThe program should ignore case, punctuation, and numbers. While counting, ignore 'a', 'an', 'the', and 'and' as well.\n\nWrite assertions for validation."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: GTK+ TreeView, GTK+ TreeIter, GTK+ TreeStore, GTK+ ListStore, GTK+ TreeViewColumn, GTK+ CellRendererText, GTK+ Container, GTK+ Window\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    gtk::init();\n\n    let mut window = gtk::Window::new(gtk::WindowType::TopLevel).unwrap();\n\n    window.set_title(\"TreeView Sample\");\n    window.set_window_position(gtk::WindowPosition::Center);\n\n    Connect::connect(&window, DeleteEvent::new(&mut |_| {\n        gtk::main_quit();\n        true\n    }));\n\n    // test Value\n\n    let hello = String::from(\"Hello world !\");\n    let value = glib::Value::new().unwrap();\n\n    value.init(glib::Type::String);\n    value.set(&hello);\n    println!(\"gvalue.get example : {}\", value.get::<String>());\n\n    // left pane\n\n    let mut left_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let left_store = gtk::ListStore::new(&column_types).unwrap();\n    let left_model = left_store.get_model().unwrap();\n\n    left_tree.set_model(&left_model);\n    left_tree.set_headers_visible(false);\n    append_text_column(&mut left_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n        left_store.append(&mut iter);\n        left_store.set_string(&iter, 0, \"I'm in a list\");\n    }\n\n    // right pane\n\n    let mut right_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let right_store = gtk::TreeStore::new(&column_types).unwrap();\n    let right_model = right_store.get_model().unwrap();\n\n    right_tree.set_model(&right_model);\n    right_tree.set_headers_visible(false);\n    append_text_column(&mut right_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut iter, None);\n        right_store.set_value(&iter, 0, &value);\n\n        let mut child_iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut child_iter, Some(&iter));\n        right_store.set_string(&child_iter, 0, \"I'm a child node\");\n    }\n\n    // display the panes\n\n    let mut split_pane = gtk::Box::new(gtk::Orientation::Horizontal, 10).unwrap();\n\n    split_pane.set_size_request(-1, -1);\n    split_pane.add(&left_tree);\n    split_pane.add(&right_tree);\n\n    window.add(&split_pane);\n    window.show_all();\n    gtk::main();\n}", "id": 201, "concepts": ["GTK+ TreeView", "GTK+ TreeIter", "GTK+ TreeStore", "GTK+ ListStore", "GTK+ TreeViewColumn", "GTK+ CellRendererText", "GTK+ Container", "GTK+ Window"], "instruction": "Implement a simple application that displays a list of users with their names and emails. The list should be populated from a CSV file provided by the user on program launch. The application should have a text input field where the user can type a name and the application will display all users whose names contain the input string. The name and email address must be rendered in separate columns in the application window. While the application is running, the user can click the close button to terminate it."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async/await, window builder, renderer, window size, window run\n\n### Task", "fingerprint": null, "seed": "pub fn init(\n    src: String,\n    dst: String,\n    width: u32,\n) -> std::io::Result<()> {\n    let mut logger = env_logger::Builder::new();\n    logger.init();\n\n    let mut window = Window::new((width, 200)).unwrap();\n    let mut popup = Popup::new(width, window.hidpi);\n    let mut renderer = popup.get_renderer(&mut window.handle);\n    window.run(&mut popup, &mut renderer);\n\n    Ok(())\n}", "id": 202, "concepts": ["async/await", "window builder", "renderer", "window size", "window run"], "instruction": "Implement a simple text-based graphical user interface (GUI) using Rust and the `ggez` crate. The GUI should consist of a window that displays a text string and implements a small menu system. The window should have a minimum size of 600x400 and have a \"Play\" button that when pressed, triggers the `ggez` window to render a new text string. The new text string should be the same as the original text string but with all characters shuffled. The window should display the original text string in white, the shuffled text string in red, and the button in green."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: Git object/tree traversal, string interpolation, `?` operator\n\n### Task", "fingerprint": null, "seed": "fn modules_file(repo: &Repository, at: &Commit) -> Result<String, Box<dyn std::error::Error>> {\n    if let Some(modules) = at.tree()?.get_name(\".gitmodules\") {\n        Ok(String::from_utf8(\n            modules.to_object(&repo)?.peel_to_blob()?.content().into(),\n        )?)\n    } else {\n        return Ok(String::new());\n    }\n}", "id": 203, "concepts": ["Git object/tree traversal", "string interpolation", "`?` operator"], "instruction": "Implement a Rust class `GitObject` that models a Git object. The class should store the type of object, the hash value, and the contents of the object as attributes. The class should provide methods to traverse the object tree of a given Git commit. Additionally, enhance the class with string interpolation and the `?` operator to provide a more concise and readable syntax for accessing object attributes.\n\nThe class should support the following operations:\n```rust\nlet commit = GitObject::new(\"commit\", \"a8372b43d30e7ec3230305f7923d6e54626b3f31\", None);\nlet tree = GitObject::new(\n    \"tree\",\n    \"4e5058\",\n    Some(\"a8372b43d30e7ec3230305f7923d6e54626b3f31\".to_string()),\n);\nlet blob = GitObject::new(\n    \"blob\",\n    \"134891e6c033c38a3277a042d6a807d15287c006\",\n    Some(\n        \"134891e6c033c38a3277a042d6a807d15287c006\".to_string(),\n    ),\n);\n\nlet commit.traverse(&tree, |object| {\n    let tree_objects = object.get_tree_objects();\n    for tree_object in tree_objects {\n        println!(\"tree object: {}\", tree_object.as_str());\n    }\n});\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async/await, servo initialization, robot control, non-blocking IO\n\n### Task", "fingerprint": null, "seed": "fn init_servo(robot: &mut Robot) {\n    let servos = ServoManager::new();\n\n    let m2 = servos[0xFE].reboot();\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    for _ in 0..5 {\n        robot.delay.delay_ms(70 as u32);\n    }\n\n    let m2 = servos[0xFE].ram_write(WritableRamAddr::AckPolicy(2));\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    let m1 = servos[0xFE].enable_torque();\n\n    for b in m1 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n}", "id": 204, "concepts": ["async/await", "servo initialization", "robot control", "non-blocking IO"], "instruction": "Develop a Rust function that controls a robot to guide it to a goal location. The function should be able to perform the following actions:\n\n- move forward\n- move backward\n- turn left\n- turn right\n- stop\n\nThe robot's location is initially set to 0, 0, facing north. The function should not block the main thread and should be non-blocking. The function should use the async/await feature and utilizes the servo library to control the robot."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: regular expression matching, lazy static, case insensitive matching, capturing groups\n\n### Task", "fingerprint": null, "seed": "fn commit_coauthors(commit: &Commit) -> Vec<Author> {\n    let mut coauthors = vec![];\n    if let Some(msg) = commit.message_raw() {\n        lazy_static::lazy_static! {\n            static ref RE: Regex =\n                RegexBuilder::new(r\"^Co-authored-by: (?P<name>.*) <(?P<email>.*)>\")\n                    .case_insensitive(true)\n                    .build()\n                    .unwrap();\n        }\n\n        for line in msg.lines().rev() {\n            if line.starts_with(\"Co-authored-by\") {\n                if let Some(caps) = RE.captures(line) {\n                    coauthors.push(Author {\n                        name: caps[\"name\"].to_string(),\n                        email: caps[\"email\"].to_string(),\n                    });\n                }\n            }\n        }\n    }\n    coauthors\n}", "id": 205, "concepts": ["regular expression matching", "lazy static", "case insensitive matching", "capturing groups"], "instruction": "Develop a Rust function that takes a string and returns the first valid URL in the string, within the given regular expression. If no valid URL is found, return `None`. The URLs should be matched by a case-insensitive regular expression with capturing groups, and only contain characters from the ASCII character set.\n\nValidate the regular expression by using a lazy static and compile it once. Utilize optional `Option<T>` variables to return the result."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: custom syscall implementation, syscall runtime, test case setup and teardown\n\n### Task", "fingerprint": null, "seed": "pub fn test_custom_syscall() {\n    let buffer = fs::read(\"tests/programs/syscall64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .syscall(Box::new(CustomSyscall {}))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"syscall\".into()])\n        .unwrap();\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 39);\n}", "id": 206, "concepts": ["custom syscall implementation", "syscall runtime", "test case setup and teardown"], "instruction": "Develop a Rust function that emulates the two-argument `syscall` call in Linux by implementing a custom syscall in Rust. The function should take two arguments: `syscall_no` and `arg1` and return an integer. The function should also provide examples of how to write test cases for syscalls."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: conditional expression as a return value, hash table as a dictionary, hash map, linear search, brute-force technique, conditional loop\n\n### Task", "fingerprint": null, "seed": "pub fn star2(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let mut max_guard_asleep_per_minute = vec![(0, None); 60];\n    for &guard_id in guard_map.keys() {\n        let mut guard_asleep_by_minute = vec![0; 60];\n        for day in &guard_map[&guard_id] {\n            for minute in 0..60 {\n                guard_asleep_by_minute[minute] += i32::from(!day.minutes[minute]);\n            }\n        }\n        for minute in 0..60 {\n            if max_guard_asleep_per_minute[minute].0 < guard_asleep_by_minute[minute] {\n                max_guard_asleep_per_minute[minute] = (guard_asleep_by_minute[minute], Some(guard_id));\n            }\n        }\n    }\n    if let Some((max_minute, (_, Some(max_guard_id)))) = max_guard_asleep_per_minute.iter().enumerate().max_by_key(|(_, (times, _))| times) {\n        return (max_minute as i32 * max_guard_id) .to_string();\n    }\n    panic!(\"No maximum found: Invalid input!\");\n}", "id": 208, "concepts": ["conditional expression as a return value", "hash table as a dictionary", "hash map", "linear search", "brute-force technique", "conditional loop"], "instruction": "Develop a Rust program that reads a text file containing one positive integer per line and returns the smallest positive integer that cannot be found in the file. The program should also log and print the smallest positive integer that cannot be found in the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: checksum computation, binary arithmetic operations, carry-save propagation\n\n### Task", "fingerprint": null, "seed": "pub fn checksum(input: &[u8]) -> Result<u16, LayerError> {\n    let mut sum = 0x00;\n    let mut chunks_iter = input.chunks_exact(2);\n    while let Some(chunk) = chunks_iter.next() {\n        sum += u32::from(u16::from_be_bytes(\n            chunk.try_into().expect(\"chunks of 2 bytes\"),\n        ));\n    }\n\n    if let [rem] = chunks_iter.remainder() {\n        sum += u32::from(u16::from_be_bytes([*rem, 0x00]));\n    }\n\n    let carry_add = (sum & 0xffff) + (sum >> 16);\n    let chksum = !(((carry_add & 0xffff) + (carry_add >> 16)) as u16);\n\n    Ok(chksum)\n}", "id": 209, "concepts": ["checksum computation", "binary arithmetic operations", "carry-save propagation"], "instruction": "Write a Rust function that takes two 16-bit integers as arguments and returns their logical XOR result. The function should be implemented using only bitwise operations (i.e., no loops or other constructs) and without using any built-in XOR operators. The function should contain no extra variables and use no more than 16 arithmetic operations."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: fuzz testing, stdin-based process spawning, test case generation, fuzzing, corpus management, command line argument processing\n\n### Task", "fingerprint": null, "seed": "fn tmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"i_hate_zed\");\n    let test_case = corpus.join(\"test-case\");\n    let project = project(\"tmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"i_hate_zed\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let s = String::from_utf8_lossy(data);\n                    if s.contains('z') {\n                        panic!(\"nooooooooo\");\n                    }\n                });\n            \"#,\n        )\n        .file(&test_case, \"pack my box with five dozen liquor jugs\")\n        .build();\n    let test_case = project.root().join(test_case);\n    project\n        .cargo_fuzz()\n        .arg(\"tmin\")\n        .arg(\"i_hate_zed\")\n        .arg(\"--sanitizer=none\")\n        .arg(&test_case)\n        .assert()\n        .stderr(\n            predicates::str::contains(\"CRASH_MIN: minimizing crash input: \")\n                .and(predicate::str::contains(\"(1 bytes) caused a crash\"))\n                .and(predicate::str::contains(\n                    \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\\n                     \\n\\\n                     Minimized artifact:\\n\\\n                     \\n\\\n                     \\tfuzz/artifacts/i_hate_zed/minimized-from-\"))\n                .and(predicate::str::contains(\n                    \"Reproduce with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz run --sanitizer=none i_hate_zed fuzz/artifacts/i_hate_zed/minimized-from-\"\n                )),\n        )\n        .success();\n}", "id": 210, "concepts": ["fuzz testing", "stdin-based process spawning", "test case generation", "fuzzing", "corpus management", "command line argument processing"], "instruction": "Develop a Rust function that takes a program name and a list of arguments as input. The function should spawn a new process that executes the program specified by the name with the provided arguments. The function should handle a case where the program name is not found and return an appropriate error message.\n\nAdditionally, the function should generate a corpus of test cases for the program using a fuzzing technique. The function should use the program's stdin to feed a corpus of inputs into the program and return the resulting outputs in a list. The corpus should include both valid and invalid inputs.\n\nThe function should handle cases where the program is not found, cannot be spawned, or the inputs are invalid."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: parsing input file, arithmetic operations, conditional execution, registers\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    let file_name = \"input.txt\";\n    let instructions = parse_file(file_name);\n    let (registers, largest_value) = process_instructions(&instructions);\n    println!(\"Day 8, part 1: {}\", get_largest_register_value(&registers));\n    println!(\"Day 8, part 2: {}\", largest_value);\n}", "id": 211, "concepts": ["parsing input file", "arithmetic operations", "conditional execution", "registers"], "instruction": "Develop a Rust program that reads a text file containing two positive integers separated by a newline character. It should then perform the following operations on the input values:\n- If the first value is greater than the second, print \"first is greater than second\"\n- If the first value is less than the second, print \"first is less than second\"\n- If the first value is equal to the second, print \"first equals second\""}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dice roll, probability calculation, random number generation, input validation\n\n### Task", "fingerprint": null, "seed": "pub fn test_memory_load_bytes() {\n    let mut rng = thread_rng();\n\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 0);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 2);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 1024 * 6);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 0, 0);\n}", "id": 212, "concepts": ["dice roll", "probability calculation", "random number generation", "input validation"], "instruction": "Create a program that simulates the rolling of `n` dice. `n`, the number of dice to roll, will be provided as input through the standard input. The program should calculate the average and probability of each possible roll in the form of a table showing the number of occurences with the total number of the roll as the row index and the number of occurences as the value. The table is then printed to the standard output."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: recursive directory listing, file type detection, iterative list construction, directory entry types\n\n### Task", "fingerprint": null, "seed": "fn read_dir<P: AsRef<Path>>(path: P, recursive: bool) -> io::Result<Vec<DirEntry>> {\n    let path = path.as_ref();\n    let mut entries = Vec::new();\n    for entry in fs::read_dir(path)? {\n        let entry = entry?;\n        let path = entry.path().to_str().unwrap().to_string();\n        let children = if recursive && entry.file_type()?.is_dir() {\n            Some(read_dir(&path, true)?)\n        } else {\n            None\n        };\n        entries.push(DirEntry { path, children });\n    }\n    Ok(entries)\n}", "id": 213, "concepts": ["recursive directory listing", "file type detection", "iterative list construction", "directory entry types"], "instruction": "Create a Rust function to recursively read the contents of a directory and return a list of file names in the given directory. The function should meet the requirements specified by the following assertions:\n\n```rust\nuse std::env;\n\nlet dir = env::current_dir().unwrap();\n\nlet file_list = list_files(dir).unwrap();\n\nassert!(file_list.contains(&\"Cargo.toml\".to_string()));\nassert!(file_list.contains(&\"README.md\".to_string()));\nassert!(file_list.contains(&\"src/lib.rs\".to_string()));\nassert!(file_list.contains(&\"src/main.rs\".to_string()));\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: pattern matching and destructuring, list comprehension, error handling\n\n### Task", "fingerprint": null, "seed": "fn map_prefix(tok: IRCToken) -> Result<IRCToken, ~str> {\n    match tok {\n        Sequence([Unparsed(nick), Sequence([rest])]) => match rest {\n            Sequence([Sequence([rest]), Unparsed(~\"@\"), Unparsed(host)]) => match rest {\n                Sequence([Unparsed(~\"!\"), Unparsed(user)]) => Ok(PrefixT(Prefix {nick: nick, user: user, host: host})),\n                _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: host})),\n            },\n            _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: ~\"\"})),\n        },\n        _ => Err(~\"Malformed prefix\")\n    }", "id": 214, "concepts": ["pattern matching and destructuring", "list comprehension", "error handling"], "instruction": "Write a Rust function that takes a list of `Vec<char>`, `Vec<String>`, and `Vec<bool>` as inputs. The function should check the validity of each input condition, and return a new list of corresponding outputs based on the input patterns.\n\nList patterns include:\n- `Vec<char>`: list of characters `['a', 'b', 'c']`\n- `Vec<String>`: list of strings `['123', '456', '789']`\n- `Vec<bool>`: list of booleans `[true, false, true]`\n\nAll inputs have the same length, and the outputs should be of the same type. Ensure the function handles empty lists, lists of the wrong length, and non-matching list types."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: wasm module and binary serialization, process spawning, error handling, logging, binary data, console output\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    std::panic::set_hook(Box::new(console_error_panic_hook::hook));\n    console_log::init_with_level(log::Level::Warn).expect(\"could not initialize logger\");\n\n    let fighter_bytes = include_bytes!(\"subaction_data.bin\");\n    let subaction = bincode::deserialize(fighter_bytes).unwrap();\n    wasm_bindgen_futures::spawn_local(render_window_wasm(subaction));\n}", "id": 215, "concepts": ["wasm module and binary serialization", "process spawning", "error handling", "logging", "binary data", "console output"], "instruction": "Create a Rust function to serialize and deserialize a `Vec<u8>` data structure that contains information about a WebAssembly module. This data structure should include information such as the name of the module, the version number, the base 64-encoded binary data, and a timestamp for the module creation. The function should also include error handling to catch errors that might occur while serializing and deserializing the data."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: parsing of command line arguments, type casting, alignment of a given size to a given alignment, function composition\n\n### Task", "fingerprint": null, "seed": "fn main() {\n\tlet argv = os::args();\n\tlet size = from_str::<uint>(argv[1]).unwrap();\n//\tprintln!(\"{}\",size);\n\n\tlet align = from_str::<uint>(argv[2]).unwrap();\n//\tprintln!(\"{}\", align);\n\n\tlet aligned = align_to(size,align);\n\tprintln!(\"{} by {} = {}\", size, align, aligned);\n\n//\tprint_uint(*argv[1]);\n}", "id": 216, "concepts": ["parsing of command line arguments", "type casting", "alignment of a given size to a given alignment", "function composition"], "instruction": "Create a Rust function to validate the alignment of a given size to a given alignment. The alignment must be a power of 2 and less than the size. The function should accept two arguments, a size `size` and an alignment `alignment`, and return `true` if the alignment is valid for the given size, and `false` otherwise. The function should also return `false` if either argument is negative."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: enumerations, if statements, match expressions, while loops, iteration over an iterator, method call chaining\n\n### Task", "fingerprint": null, "seed": "fn enum_test() {\n    // enum Ordering {\n    //     Less,\n    //     Equal,\n    //     Greater / 2.0\n    // }\n\n    use std::cmp::Ordering;\n\n    fn compare(n: i32, m: i32) -> Ordering {\n        if n < m {\n            Ordering::Less\n        } else if n > m {\n            Ordering::Greater\n        } else {\n            Ordering::Equal\n        }\n    }\n    // use std::cmp::Ordering::*;\n\n    // fn compare(n: i32, m: i32) -> Ordering {\n    //     if n < m {\n    //         Less\n    //     } else if n > m {\n    //         Greater\n    //     } else {\n    //         Equal\n    //     }\n    // }\n\n    // enum Pet {\n    //     Orca,\n    //     Giraffe,\n    // }\n\n    // use self::Pet::*;\n\n    #[derive(Debug, PartialEq)]\n    enum HttpStatus {\n        Ok = 200,\n        NotModified = 304,\n        NotFound = 404,\n    }\n\n    use std::mem::size_of;\n    assert_eq!(size_of::<Ordering>(), 1);\n    assert_eq!(size_of::<HttpStatus>(), 2); // 404 doesn't fit in a u8\n\n    assert_eq!(HttpStatus::Ok as i32, 200);\n\n    fn http_status_from_u32(n: u32) -> Option<HttpStatus> {\n        match n {\n            200 => Some(HttpStatus::Ok),\n            304 => Some(HttpStatus::NotModified),\n            404 => Some(HttpStatus::NotFound),\n            _ => None,\n        }\n    }\n\n    let status = http_status_from_u32(404).unwrap();\n    // assert_eq!(status as i32, 404);\n    assert_eq!(status, HttpStatus::NotFound);\n\n    #[derive(Copy, Clone, Debug, PartialEq)]\n    enum TimeUnit {\n        Seconds,\n        Minutes,\n        Hours,\n        Days,\n        Months,\n        Years,\n    }\n\n    impl TimeUnit {\n        /// Return the plural noun for this time unit.\n        fn plural(self) -> &'static str {\n            match self {\n                TimeUnit::Seconds => \"seconds\",\n                TimeUnit::Minutes => \"minutes\",\n                TimeUnit::Hours => \"hours\",\n                TimeUnit::Days => \"days\",\n                TimeUnit::Months => \"months\",\n                TimeUnit::Years => \"years\",\n            }\n        }\n        /// Return the singular noun for this time unit.\n        fn singular(self) -> &'static str {\n            self.plural().trim_right_matches('s')\n        }\n    }\n\n    /// A timestamp that has been deliberately rounded off, so our program\n    /// says \"6 monthes ago\" instead of \"February 9, 2016, at 9:49 AM\".\n    #[derive(Copy, Clone, Debug, PartialEq)]\n    enum RoughTime {\n        InThePast(TimeUnit, u32),\n        JustNow,\n        InTheFuture(TimeUnit, u32),\n    }\n\n    let four_score_and_seven_years_ago = RoughTime::InThePast(TimeUnit::Years, 4 * 20 + 7);\n\n    let three_hours_from_now = RoughTime::InTheFuture(TimeUnit::Hours, 3);\n\n    struct Point3d(u32, u32, u32);\n    enum Shape {\n        Sphere { center: Point3d, radius: f32 },\n        Cubold { corner1: Point3d, corner2: Point3d },\n    }\n\n    let unit_sphere = Shape::Sphere {\n        center: Point3d(0, 0, 0),\n        radius: 1.0,\n    };\n\n    // enum RelationshipStatus {\n    //     Single,\n    //     InARelationship,\n    //     ItsComplicated(Option<String>),\n    //     ItsExtremelyComplicated {\n    //         car: DifferentialEquation,\n    //         cdr: EarlyModernistPoem\n    //     }\n    // }\n    //\n\n    use std::collections::HashMap;\n    enum Json {\n        Null,\n        Boolean(bool),\n        Number(f64),\n        String(String),\n        Array(Vec<Json>),\n        Object(Box<HashMap<String, Json>>),\n    }\n\n    // An ordered collection of `T`s\n    enum BinaryTree<T> {\n        Empty,\n        NonEmpty(Box<TreeNode<T>>),\n    }\n\n    // A part of a BinaryTree.\n    struct TreeNode<T> {\n        element: T,\n        left: BinaryTree<T>,\n        right: BinaryTree<T>,\n    }\n\n    let jupiter_tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Jupiter\",\n        left: BinaryTree::Empty,\n        right: BinaryTree::Empty,\n    }));\n    let mercury_tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Mercury\",\n        left: BinaryTree::Empty,\n        right: BinaryTree::Empty,\n    }));\n    let uranus_tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Uranus\",\n        left: BinaryTree::Empty,\n        right: BinaryTree::Empty,\n    }));\n    let mars_tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Mars\",\n        left: jupiter_tree,\n        right: mercury_tree,\n    }));\n    let tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Saturn\",\n        left: mars_tree,\n        right: uranus_tree,\n    }));\n\n    // let mut tree = BinaryTree::Empty;\n    // for planet in planets {\n    //    tree.add(planet);\n    // }\n\n    // 10.2\n\n    fn rough_time_to_english(rt: RoughTime) -> String {\n        match rt {\n            RoughTime::InThePast(units, count) => format!(\"{}, {} ago\", count, units.plural()),\n            RoughTime::JustNow => format!(\"just now\"),\n            RoughTime::InTheFuture(units, 1) => format!(\"a {} from now\", units.plural()),\n            RoughTime::InTheFuture(units, count) => {\n                format!(\"{}, {} from now\", count, units.plural())\n            }\n        }\n    }\n\n    rough_time_to_english(four_score_and_seven_years_ago);\n\n    // 10.2.1\n\n    // match meadow.count_rabbits() {\n    //     0 => {} // nothing to say\n    //     1 => println!(\"A rabbit is nosing around inthe clover.\"),\n    //     n => println!(\"There are {} rabbits hopping about in the meadow\", n)\n    // }\n    //\n    // let calendar =\n    //     match settings.get_string(\"calendar\") {\n    //        \"gregorian\" => Calendar::Gregorian,\n    //        \"chinese\" => Calendar::Chinese,\n    //        \"ethiopian\" => Calendar::Ethiopian,\n    //        other => return parse_error(\"calendar\", other)\n    //     };\n    // let caption =\n    //     match photo.tagged_pet() {\n    //        Pet::Tyrannosaur => \"RRRRAAAAAHHHHH\",\n    //        Pet::Samoyed => \"*dog thoughts*\",\n    //        _ => \"I'm cute, love me\" // generic caption, works for any pet\n    //     }\n    // // there are many Shapes, but we only support \"selecting\"\n    // // either some text, or everything in a rectangular area.\n    // // You can't select an ellipse or trapezoid.\n    // match document.selection() {\n    //    Shape::TextSpan(start, end) => paint_text_selection(start, end),\n    //    Shape::Rectangle(rect) => paint_rect_selection(rect),\n    //    _ => panic!(\"unexpected selection type\")\n    // }\n    //\n    // fn check_move(current_hex: Hex, click: Point) -> game::Result<Hex> {\n    //    match point_to_hex(click) {\n    //        None =>\n    //            Err(\"That's not a game space.\"),\n    //        Some(current_hex) => // try to match if user clicked the current_hex\n    //                             // (if doesn't work)\n    //            Err(\"You are already there! You must click somewhere else.\"),\n    //        Some(other_hex) =>\n    //            Ok(other_hex)\n    //    }\n    // }\n    //\n    // fn check_move(current_hex: Hex, click: Point) -> game::Result<Hex> {\n    //    match point_to_hex(click) {\n    //        None =>\n    //            Err(\"That's not a game space.\"),\n    //        Some(hex) =>\n    //            if hex == current_hex {\n    //                Err(\"You are already there! You must click somewhere else.\"),\n    //            } else {\n    //                Ok(hex)\n    //            }\n    //        Some(other_hex) =>\n    //            Ok(other_hex)\n    //    }\n    // }\n    //\n    // fn describe_point(x: i32, y: i32) -> &'static str {\n    //     use std::cmp::Ordering::*;\n    //     match (x.cmp(&0), y.cmp(&0) {\n    //         (Equal, Equal) -> \"at the origin\",\n    //         (_, Equal) => \"on the x axis\",\n    //         (Equal, _) => \"on the y axis\",\n    //         (Greater, Greater) => \"in the first quadrant\",\n    //         (Less, Grater) => \"in the second quadrant\",\n    //         _ => \"somewhere else\"\n    //     }\n    // }\n    //\n    // match balloon.location {\n    //     Point { x: 0, y: height } =>\n    //        println!(\"straight up {} meters\", height),\n    //     Point { x: x, y: y } =>\n    //        println!(\"at ({}m, {}m)\", x, y);\n    // }\n    //\n    // match get_acount(id) {\n    //    Some(Account { name, language, .. {) =>\n    //        language.show_custom_greeting(name)\n    // }\n    //\n    // 10.2.3\n    //\n    // match account {\n    //    Account { name, language, .. } => {\n    //        ui.greet(&name, &language);\n    //        ui.show_settigs(&account); // error: use of moved value `account`\n    //    }\n    // }\n    // match account {\n    //   Account { ref name, ref language, .. } => {\n    //        ui.greet(name, language);\n    //        ui.show_settings(&account); // ok\n    //   }\n    // }\n    //\n    // match line_result {\n    //     Err(ref err) => log_error(err), // `err` is &Error (shared ref)\n    //     Ok(ref mut line) -> {           // `line` is &mut String (mut ref)\n    //         trim_comments(line);        // modify the String in place\n    //         handle(line);\n    //     }\n    // }\n    //\n    // match sphere.center() {\n    //     &Point3d { x, y, z } => ...\n    // }\n    //\n    // match friend.borrow_car() {\n    //     Some(&Car { engine, .. }) => // error: can't move out of borrow\n    //     ...\n    //     None -> {}\n    // }\n    //\n    // Some(&Car {ref engine, .. }) => // ok, engine is a reference\n    //\n    // match chars.peek() {\n    //     Some(&c) -> println!(\"coming up: {:?}\", c),\n    //     None =-> println!(\"end of chars\")\n    // }\n    //\n    // 10.2.4\n    //\n    // let at_end =\n    //     match chars.peek() {\n    //         Some(&'\\r') | Some(&'\\n') | None => true,\n    //         _ => false\n    //     };\n    // match next_char {\n    //     '0' ... '9' =>\n    //         self.read_number(),\n    //     'a' ... 'z' | 'A' ... 'Z' =>\n    //         self.read_word(),\n    //     ' ' | '\\t' | '\\n' =>\n    //         self.skip_whitespace(),\n    //     _ =>\n    //         self.handle_punctuation()\n    // }\n    //\n    // 10.2.5\n    //\n    // match robot.last_known_location() {\n    //     Some(point) if self.distance_to(point) < 10 =>\n    //         short_distance_strategy(point),\n    //     Some(point) ->\n    //         long_distance_strategy(point),\n    //     None ->\n    //         searching_strategy()\n    // }\n    //\n    // 10.2.6\n    //\n    // match self.get_selection() {\n    //     Shape::Rect(top_left, bottom_right) ->\n    //         optimized_paint(&Shape::Rect(top_left, bottom_right)),\n    //     other_shape =>\n    //         paint_outline(other_shape.get_outline()),\n    // }\n    //\n    // rect @ Shape::Rect(..) -> optimized_paint(&rect)\n    //\n    // match chars.next() {\n    //     Some(digit @ '0' ... '9') => read_number(disit, chars),\n    // }\n    //\n    // 10.2.7\n    //\n    // // ...unpack a struct into three new local variables\n    // let Track { album, track_number, title, ..} = song;\n    //\n    // // ...unpack a function argument that's a tuple\n    // fn distance_to((x,y): (f64, f64)) -> f64 { ... }\n    //\n    // // ...iterate over keys and values of a HashMap\n    // for (id, document) in &cache_map {\n    //    println!(\"Document #{}: {}\", id, document.title);\n    // }\n    //\n    // // ...automatically dereference an argument to a closure\n    // // (handy because sometimes other code passes you a reference\n    // // when you'd rather have a copy)\n    // let sum = numbers.fold(0, |a, &num| a + num);\n    //\n    // // ...handle just one enum variant specially\n    // if let RoughTime::InTheFuture(_, _) = user.date_of_birth() {\n    //     user.set_time_traveler(true);\n    // }\n    //\n    // // ...run some code only if a table lookup succeeds\n    // if let Some(document) = cache_map.get(&id) {\n    //     return send_cached_response(document);\n    // }\n    //\n    // // ...repeatedly try something until it succeeds\n    // while let Err(err) = present_cheesy_anti_robot_task() {\n    //     log_robot_attempt(err);\n    //     // let the user try again (it might still be a human)\n    // }\n    //\n    // // ...manually loop over an iterator\n    // while let Some(_) = lines.peek() {\n    //     read_paragraph(&mut lines);\n    // }\n    //\n    // 10.2.8\n\n    impl<T: Ord> BinaryTree<T> {\n        fn add(&mut self, value: T) {\n            match *self {\n                BinaryTree::Empty => {\n                    *self = BinaryTree::NonEmpty(Box::new(TreeNode {\n                        element: value,\n                        left: BinaryTree::Empty,\n                        right: BinaryTree::Empty,\n                    }))\n                }\n                BinaryTree::NonEmpty(ref mut node) => {\n                    if value <= node.element {\n                        node.left.add(value);\n                    } else {\n                        node.right.add(value);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut add_tree = BinaryTree::Empty;\n    add_tree.add(\"Mercury\");\n    add_tree.add(\"Venus\");\n}", "id": 217, "concepts": ["enumerations", "if statements", "match expressions", "while loops", "iteration over an iterator", "method call chaining"], "instruction": "Construct a Rust function `kth_smallest(nums, k)` that calculates the `kth` smallest integer in a list. When the list is empty, the function should return `None`. You should also write a test that verifies the function handles both cases.\n\nThe function should use an iterator to iterate over the list of numbers and process them one by one. It should print a message that is appropriate for the context (`Kth smallest integer in the list is...` or `There are not enough elements in the list for this query.`) and return `None` if the list is empty.\n\nUse a match expression or if statements to implement the algorithm.\n\nFor example, given the input `[5, 9, 3, 7, 4]` and `2`, the function should return `4` and print `Kth smallest integer in the list is 4`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: constant structure initialization, unsafe Rust functionality, memory buffer manipulation\n\n### Task", "fingerprint": null, "seed": "extern \"C\" fn gatt_svr_chr_access_heart_rate(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    /* Sensor location, set to \"Chest\" */\n    const BODY_SENS_LOC: u8 = 0x01;\n\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_HRS_BODY_SENSOR_LOC_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                &BODY_SENS_LOC as *const u8 as *const c_void,\n                size_of::<u8>() as u16,\n            )\n        };\n\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}", "id": 218, "concepts": ["constant structure initialization", "unsafe Rust functionality", "memory buffer manipulation"], "instruction": "Create a Rust class to validate and format monetary amounts in USD. The class should accept USD amounts as a string input, as long as the input string matches the format `$` or `$<digits>.<digits><currency>`, where the digits are 0-9, and currency is either `USD` or `cents`. The class should provide `format()` and `validate()` methods for formatting and validating input, respectively.\n\nThe `format()` method should perform the following validations:\n- the number of digits after the decimal point should not be greater than 2;\n- the currency should only be `cents`;\n- the value should be non-negative.\n\nThe `validate()` method should do the following validations:\n- the input should have the format `$` or `$<digits>.<digits><currency>`;\n- the number of digits after the decimal point should not be greater than 2;\n- the currency should only be `cents`;\n- the value should be non-negative.\n\nThe `format()` and `validate()` methods should use `unsafe` Rust functionality to write the formatted string to a memory buffer."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: CLI parsing, no-main functionality, libfuzzer_sys invocation, cargo fuzz argument passing\n\n### Task", "fingerprint": null, "seed": "fn run_no_crash() {\n    let project = project(\"run_no_crash\")\n        .with_fuzz()\n        .fuzz_target(\n            \"no_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    #[cfg(fuzzing_repro)]\n                    eprintln!(\"Reproducing a crash\");\n\n                    run_no_crash::pass_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"no_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Done 1000 runs\")\n                .and(predicate::str::contains(\"Reproducing a crash\").not()),\n        )\n        .success();\n}", "id": 219, "concepts": ["CLI parsing", "no-main functionality", "libfuzzer_sys invocation", "cargo fuzz argument passing"], "instruction": "Create a Rust function that can be used as a no-main function (i.e., without the main function) and can be used as a fuzzing target. The Rust function should have a CLI interface that allows users to configure its behavior. The function should be compiled using libfuzzer_sys and linked against the fuzzing library.\n\nTo fuzz the function, utilize cargo-fuzz to create a fuzzer target that invokes the Rust function with randomly generated input. The fuzzing target should use the fuzzing library to generate inputs and report any crashes. Additionally, the fuzzer target should parse the command-line arguments and configure the behavior of the function."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: binary structure debugging, debugging with a debugger, binary structure debugging with `debug_fmt`\n\n### Task", "fingerprint": null, "seed": "fn debug_fmt() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"debugfmt\");\n    let project = project(\"debugfmt\")\n        .with_fuzz()\n        .fuzz_target(\n            \"debugfmt\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n                use libfuzzer_sys::arbitrary::{Arbitrary, Unstructured, Result};\n\n                #[derive(Debug)]\n                pub struct Rgb {\n                    r: u8,\n                    g: u8,\n                    b: u8,\n                }\n\n                impl<'a> Arbitrary<'a> for Rgb {\n                    fn arbitrary(raw: &mut Unstructured<'a>) -> Result<Self> {\n                        let mut buf = [0; 3];\n                        raw.fill_buffer(&mut buf)?;\n                        let r = buf[0];\n                        let g = buf[1];\n                        let b = buf[2];\n                        Ok(Rgb { r, g, b })\n                    }\n                }\n\n                fuzz_target!(|data: Rgb| {\n                    let _ = data;\n                });\n            \"#,\n        )\n        .file(corpus.join(\"0\"), \"111\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"fmt\")\n        .arg(\"debugfmt\")\n        .arg(\"fuzz/corpus/debugfmt/0\")\n        .assert()\n        .stderr(predicates::str::contains(\n            \"\nRgb {\n    r: 49,\n    g: 49,\n    b: 49,\n}\",\n        ))\n        .success();\n}", "id": 220, "concepts": ["binary structure debugging", "debugging with a debugger", "binary structure debugging with `debug_fmt`"], "instruction": "Create a Rust function that reverses an array in place. The function should use the `debug_fmt` feature to print detailed debugging information about the indices and elements of the array as it iterates through the elements."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: error handling, logging, error message formatting\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    env_logger::init().unwrap_or_else(\n        |err|\n            panic!(\"unable to initiate env logger: {}\", err)\n    );\n\n    match core::start() {\n        Ok(()) => info!(\"game exiting\"),\n        Err(err) => error!(\"core start error: {}\", err),\n    }\n}", "id": 221, "concepts": ["error handling", "logging", "error message formatting"], "instruction": "Create a Rust function that raises an error in a specific case. The function should use the `Result` enum type and handle any possible errors. The function should also use macros to define the error message."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: CLI command execution, string manipulation, async I/O, regular expression for pattern matching, `async` and `await`\n\n### Task", "fingerprint": null, "seed": "pub async fn dump_wifi_passwords() -> Option<WifiLogins> {\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    let mut wifi_logins = WifiLogins::new();\n\n    let list_of_process = String::from_utf8_lossy(&output.stdout);\n    for line in list_of_process.lines() {\n        if line\n            .to_lowercase()\n            .contains(obfstr::obfstr!(\"all user profile\"))\n            && line.contains(\":\")\n        {\n            let ssid = line.split(':').nth(1)?.trim();\n            let profile = get_wifi_profile(ssid).await?;\n            for pline in profile.lines() {\n                if pline\n                    .to_lowercase()\n                    .contains(obfstr::obfstr!(\"key content\"))\n                    && pline.contains(\":\")\n                {\n                    let key = pline.split(\": \").nth(1)?;\n                    wifi_logins.insert(ssid.to_string(), key.to_string());\n                }\n            }\n        }\n    }\n\n    Some(wifi_logins)\n}", "id": 222, "concepts": ["CLI command execution", "string manipulation", "async I/O", "regular expression for pattern matching", "`async` and `await`"], "instruction": "Create a Rust function that executes a command in a separate process using the `std::process` module. The function should accept a string argument that represents the command to be executed. When the command is executed successfully, the function should return a string that represents the command output. If the command execution fails, the function should raise a `CommandExecutionError` exception with an appropriate error message."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: tokenization, recursive descent parsing, number of decimal digits, character set range specification, character set difference\n\n### Task", "fingerprint": null, "seed": "pub fn grammar() -> ParseContext<IRCToken> {\n    let mut ctx = ParseContext::new();\n    /*\n    message    =  [ \":\" prefix SPACE ] command [ params ] crlf\n    prefix     =  servername / ( nickname [ [ \"!\" user ] \"@\" host ] )\n    command    =  1*letter / 3digit\n    params     =  *14( SPACE middle ) [ SPACE \":\" trailing ]\n               =/ 14( SPACE middle ) [ SPACE [ \":\" ] trailing ]\n\n    nospcrlfcl =  %x01-09 / %x0B-0C / %x0E-1F / %x21-39 / %x3B-FF\n                    ; any octet except NUL, CR, LF, \" \" and \":\"\n    middle     =  nospcrlfcl *( \":\" / nospcrlfcl )\n    trailing   =  *( \":\" / \" \" / nospcrlfcl )\n\n    SPACE      =  %x20        ; space character\n    crlf       =  %x0D %x0A   ; \"carriage return\" \"linefeed\" \n    */\n    ctx.rule(\"message\", ~Map(~LessThan(1, ~Literal(\":\") * ~Rule(\"prefix\") * ~Rule(\"SPACE\")) * ~Rule(\"command\") * ~LessThan(1, ~Rule(\"params\")), map_message));\n    ctx.rule(\"prefix\", ~Map(~Rule(\"nickname\") * ~LessThan(1, ~LessThan(1, ~Literal(\"!\") * ~Rule(\"user\")) * ~Literal(\"@\") * ~Rule(\"host\")), map_prefix) + ~Build(~Rule(\"servername\"), build_serverprefix));\n    ctx.rule(\"command\", ~Build(~MoreThan(1, ~Rule(\"letter\")) + ~Exactly(3, ~Rule(\"digit\")), build_unparsed));\n    ctx.rule(\"params\", ~Map(~More(~Rule(\"SPACE\") * ~Rule(\"middle\")) * ~LessThan(1, ~Rule(\"SPACE\") * ~Literal(\":\") * ~Rule(\"trailing\"))\n                          + ~More(~Rule(\"SPACE\") * ~Rule(\"middle\")) * ~LessThan(1, ~Rule(\"SPACE\") * ~LessThan(1, ~Literal(\":\")) * ~Rule(\"trailing\")), map_params));\n    ctx.rule(\"nospcrlfcl\", ~Diff(~Chars(1), ~Set(\"\\x00\\r\\n :\".iter().collect())));\n    ctx.rule(\"middle\", ~Build(~Rule(\"nospcrlfcl\") * ~More(~Literal(\":\") + ~Rule(\"nospcrlfcl\")), build_unparsed));\n    ctx.rule(\"trailing\", ~Build(~More(~Literal(\":\") + ~Literal(\" \") + ~Rule(\"nospcrlfcl\")), build_unparsed));\n    ctx.rule(\"SPACE\", ~Map(~Literal(\" \"), map_ignored));\n    ctx.rule(\"crlf\", ~Literal(\"\\r\\n\"));\n    /*\n    target     =  nickname / server\n    msgtarget  =  msgto *( \",\" msgto )\n    msgto      =  channel / ( user [ \"%\" host ] \"@\" servername )\n    msgto      =/ ( user \"%\" host ) / targetmask\n    msgto      =/ nickname / ( nickname \"!\" user \"@\" host )\n    channel    =  ( \"#\" / \"+\" / ( \"!\" channelid ) / \"&\" ) chanstring\n                [ \":\" chanstring ]\n    servername =  hostname\n    host       =  hostname / hostaddr\n    hostname   =  shortname *( \".\" shortname )\n    shortname  =  ( letter / digit ) *( letter / digit / \"-\" )\n                *( letter / digit )\n                  ; as specified in RFC 1123 [HNAME]\n    hostaddr   =  ip4addr / ip6addr\n    ip4addr    =  1*3digit \".\" 1*3digit \".\" 1*3digit \".\" 1*3digit\n    ip6addr    =  1*hexdigit 7( \":\" 1*hexdigit )\n    ip6addr    =/ \"0:0:0:0:0:\" ( \"0\" / \"FFFF\" ) \":\" ip4addr\n    nickname   =  ( letter / special ) *8( letter / digit / special / \"-\" )\n    targetmask =  ( \"$\" / \"#\" ) mask\n                  ; see details on allowed masks in section 3.3.1\n    chanstring =  %x01-07 / %x08-09 / %x0B-0C / %x0E-1F / %x21-2B\n    chanstring =/ %x2D-39 / %x3B-FF\n                  ; any octet except NUL, BELL, CR, LF, \" \", \",\" and \":\"\n    channelid  = 5( %x41-5A / digit )   ; 5( A-Z / 0-9 )\n    */\n    ctx.rule(\"servername\", ~Rule(\"hostname\"));\n    ctx.rule(\"host\", ~Build(~Rule(\"hostname\") + ~Rule(\"hostaddr\"), build_unparsed));\n    ctx.rule(\"hostname\", ~Rule(\"shortname\") * ~More(~Literal(\".\") * ~Rule(\"shortname\")));\n    ctx.rule(\"shortname\", (~Rule(\"letter\") + ~Rule(\"digit\")) * ~More(~Rule(\"letter\") + ~Rule(\"digit\") + ~Literal(\"-\")));\n    ctx.rule(\"hostaddr\", ~Rule(\"ip4addr\") + ~Rule(\"ip6addr\"));\n    ctx.rule(\"ip4addr\", ~Exactly(3, ~Rule(\"digit\")) * ~Exactly(3, ~Exactly(3, ~Literal(\".\") * ~Rule(\"digit\"))));\n    ctx.rule(\"ip6addr\", ~Rule(\"hexdigit\") * ~Exactly(7, ~Literal(\":\") * ~Rule(\"hexdigit\"))\n                      + ~Literal(\"0:0:0:0:0:\") * (~Literal(\"0\") + ~Literal(\"FFFF\")) * ~Literal(\":\") * ~Rule(\"ip4addr\"));\n    ctx.rule(\"nickname\", ~Build((~Rule(\"letter\") + ~Rule(\"special\")) * ~More(~Rule(\"letter\") + ~Rule(\"digit\") + ~Rule(\"special\") + ~Literal(\"-\")), build_unparsed));\n    /*\n    user       =  1*( %x01-09 / %x0B-0C / %x0E-1F / %x21-3F / %x41-FF )\n                    ; any octet except NUL, CR, LF, \" \" and \"@\"\n    key        =  1*23( %x01-05 / %x07-08 / %x0C / %x0E-1F / %x21-7F )\n                      ; any 7-bit US_ASCII character,\n                      ; except NUL, CR, LF, FF, h/v TABs, and \" \"\n    letter     =  %x41-5A / %x61-7A       ; A-Z / a-z\n    digit      =  %x30-39                 ; 0-9\n    hexdigit   =  digit / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n    special    =  %x5B-60 / %x7B-7D\n                       ; \"[\", \"]\", \"\\\", \"`\", \"_\", \"^\", \"{\", \"|\", \"}\"\n    */\n    ctx.rule(\"user\", ~Build(~MoreThan(1, ~Diff(~Chars(1), ~Set(\"\\x00\\r\\n @\".iter().collect()))), build_unparsed));\n    ctx.rule(\"letter\", ~Range('a','z') + ~Range('A','Z'));\n    ctx.rule(\"digit\", ~Range('0','9'));\n    ctx.rule(\"hexdigit\", ~Rule(\"digit\") + ~Range('A','F'));\n    ctx.rule(\"special\", ~Set(\"[]\\\\`_^{|}\".iter().collect()));\n\n    ctx\n}", "id": 223, "concepts": ["tokenization", "recursive descent parsing", "number of decimal digits", "character set range specification", "character set difference"], "instruction": "Create a Rust function that counts the decimal digits of a positive integer. The function should be able to handle arbitrary-precision integers, which means that it should be able to count the decimal digits of the product of large numbers. You should use a recursive descent parser to parse the input string and implement the counting algorithm. The algorithm should:\n\n- Break the input string into parts that represent a range of decimal digits: `[start_digit, end_digit]`\n- Count the number of decimal digits in the range using the formula: `end_digit - start_digit + 1`\n- Repeat the process for the next range of digits within the input string"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: parallel sorting, sorting using threads\n\n### Task", "fingerprint": null, "seed": "pub fn threaded_quick_sort<T: 'static + PartialOrd + Debug + Send>(v: &mut [T]) {\n    if v.len() <= 1 {\n        return;\n    }\n    let p = pivot(v);\n    println!(\"{:?}\", v);\n    let (a, b) = v.split_at_mut(p);\n    let raw_a = a as *mut [T];\n    let raw_s = RawSend(raw_a);\n    unsafe {\n        let handle = std::thread::spawn(move || {\n            threaded_quick_sort(&mut *raw_s.0);\n        });\n        threaded_quick_sort(&mut b[1..]);\n        // compiler doesn't know that we join these\n        // We do\n        handle.join().ok();\n    }\n}", "id": 224, "concepts": ["parallel sorting", "sorting using threads"], "instruction": "Design a Rust program that sorts a list of strings in parallel using multiple threads. The program should be able to handle cases where the list length is less than the number of available threads. The output should be the sorted list of strings, which should be printed to the console."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: object-oriented programming, bagging, value semantics, smart pointers, closures as methods, tuple structs, enumerations\n\n### Task", "fingerprint": null, "seed": "fn struct_test() {\n    // 9.1\n    /// A rectangle of eight-bit grayscale pixels\n    struct GrayscaleMap {\n        pixels: Vec<u8>,\n        size: (usize, usize),\n    }\n\n    let width = 1024;\n    let height = 576;\n    // let image = GrayscaleMap {\n    //     pixels: vec![0; width * height],\n    //     size: (width, height),\n    // };\n\n    fn new_map(size: (usize, usize), pixels: Vec<u8>) -> GrayscaleMap {\n        assert_eq!(pixels.len(), size.0 * size.1);\n        GrayscaleMap { pixels, size }\n    }\n    let image = new_map((width, height), vec![0; width * height]);\n\n    assert_eq!(image.size, (1024, 576));\n    assert_eq!(image.pixels.len(), 1024 * 576);\n\n    // pub struct GrayscaleMap {\n    //     pub pixels: Vec<u8>,\n    //     pub size: (usize, usize)\n    // }\n\n    // pub struct GrayscaleMap {\n    //     pixels: Vec<u8>,\n    //     size: (usize, usize)\n    // }\n    //\n\n    struct Broom {\n        name: String,\n        height: u32,\n        health: u32,\n        position: (f32, f32, f32),\n        intent: BroomIntent,\n    }\n\n    /// Two possitble alternatives for what a ~Broom` could be working on.\n    #[derive(Copy, Clone)]\n    enum BroomIntent {\n        FetchWater,\n        DumpWater,\n    }\n\n    // Receive the input Broom by value, taking ownership.\n    fn chop(b: Broom) -> (Broom, Broom) {\n        // Initialize `broom1` mostly from `b`, changing only `height`, Since\n        // `String` is not `Copy`, `broom1` takes ownership of `b`'s name.\n        let mut broom1 = Broom {\n            height: b.height / 2,\n            ..b\n        };\n\n        // Initialize `broom2` mostly from `broom1`. Since `String` is not\n        // `Copy`, we must clone `name` explicitly.\n        let mut broom2 = Broom {\n            name: broom1.name.clone(),\n            ..broom1\n        };\n\n        broom1.name.push_str(\" I\");\n        broom2.name.push_str(\" II\");\n\n        (broom1, broom2)\n    }\n\n    let hokey = Broom {\n        name: \"Hokey\".to_string(),\n        height: 60,\n        health: 100,\n        position: (100.0, 200.0, 0.0),\n        intent: BroomIntent::FetchWater,\n    };\n\n    let (hokey1, hokey2) = chop(hokey);\n    assert_eq!(hokey1.name, \"Hokey I\");\n    assert_eq!(hokey1.health, 100);\n\n    assert_eq!(hokey2.name, \"Hokey II\");\n    assert_eq!(hokey2.health, 100);\n\n    // 9.2\n    struct Bounds(usize, usize);\n\n    let image_bounds = Bounds(1024, 768);\n    assert_eq!(image_bounds.0 * image_bounds.1, 786432);\n\n    // pub struct Bounds(pub usize, pub usize);\n\n    // 9.3\n    // struct Onesuch;\n    // let o = Onesuch;\n\n    // 9.4\n    // 9.5\n\n    /// A first-in, first-out queue of characters.\n    pub struct Queue {\n        older: Vec<char>,   // older elements, eldest last.\n        younger: Vec<char>, // younger elements, youngest last.\n    }\n\n    impl Queue {\n        /// Push a character onto the back of a queue.\n        pub fn push(&mut self, c: char) {\n            self.younger.push(c);\n        }\n\n        /// Pop a character off the front of a queue. Return `Some(c)` if there\n        /// was a character to pop, or `None` if the queue was empty.\n        pub fn pop(&mut self) -> Option<char> {\n            if self.older.is_empty() {\n                if self.younger.is_empty() {\n                    return None;\n                }\n\n                // Bring the elements in younger over to older, and put them in\n                // the promised order.\n                use std::mem::swap;\n                swap(&mut self.older, &mut self.younger);\n                self.older.reverse();\n            }\n\n            // Now older is guaranteed to have something,. Vec's pop method\n            // already returns an Option, so we're set.\n            self.older.pop()\n        }\n\n        pub fn is_empty(&self) -> bool {\n            self.older.is_empty() && self.younger.is_empty()\n        }\n\n        pub fn split(self) -> (Vec<char>, Vec<char>) {\n            (self.older, self.younger)\n        }\n\n        pub fn new() -> Queue {\n            Queue {\n                older: Vec::new(),\n                younger: Vec::new(),\n            }\n        }\n    }\n\n    let mut q = Queue::new();\n    // let mut q = Queue {\n    //     older: Vec::new(),\n    //     younger: Vec::new(),\n    // };\n\n    q.push('0');\n    q.push('1');\n    assert_eq!(q.pop(), Some('0'));\n\n    q.push('\u221e');\n    assert_eq!(q.pop(), Some('1'));\n    assert_eq!(q.pop(), Some('\u221e'));\n    assert_eq!(q.pop(), None);\n\n    assert!(q.is_empty());\n    q.push('\u29bf');\n    assert!(!q.is_empty());\n    q.pop();\n\n    q.push('P');\n    q.push('D');\n    assert_eq!(q.pop(), Some('P'));\n    q.push('X');\n\n    let (older, younger) = q.split();\n    // q is now uninitialized.\n    assert_eq!(older, vec!['D']);\n    assert_eq!(younger, vec!['X']);\n\n    // 9.6\n\n    pub struct QueueT<T> {\n        older: Vec<T>,\n        younger: Vec<T>,\n    }\n\n    impl<T> QueueT<T> {\n        pub fn new() -> Self {\n            QueueT {\n                older: Vec::new(),\n                younger: Vec::new(),\n            }\n        }\n\n        pub fn push(&mut self, t: T) {\n            self.younger.push(t);\n        }\n\n        pub fn is_empty(&self) -> bool {\n            self.older.is_empty() && self.younger.is_empty()\n        }\n    }\n\n    // let mut qt = QueueT::<char>::new();\n\n    let mut qt = QueueT::new();\n    let mut rt = QueueT::new();\n\n    qt.push(\"CAD\"); // apparently a Queue<&'static str>\n    rt.push(0.74); // apparently a Queue<f64>\n\n    qt.push(\"BTC\"); // Bitcoins per USD, 2017-5\n    rt.push(2737.7); // Rust fails to detect ittational exuberance\n\n    // 9.7\n\n    struct Extrema<'elt> {\n        greatest: &'elt i32,\n        least: &'elt i32,\n    }\n\n    fn find_extrema<'s>(slice: &'s [i32]) -> Extrema<'s> {\n        let mut greatest = &slice[0];\n        let mut least = &slice[0];\n\n        for i in 1..slice.len() {\n            if slice[i] < *least {\n                least = &slice[i];\n            }\n            if slice[i] > *greatest {\n                greatest = &slice[i];\n            }\n        }\n        Extrema { greatest, least }\n    }\n\n    let a = [0, -3, 0, 15, 48];\n    let e = find_extrema(&a);\n    assert_eq!(*e.least, -3);\n    assert_eq!(*e.greatest, 48);\n\n    // 9.8\n    // #[derive(Copy, Clone, Debug, PartialEq)]\n    // struct Point {\n    //     x: f64,\n    //     y: f64,\n    // }\n\n    // 9.9\n\n    // pub struct SpiderRobot {\n    //     species: String,\n    //     web_enabled: bool,\n    //     log_device: [fd::FileDesc; 8],\n    //     ...\n    // }\n\n    // use std::rc::Rc;\n    // pub struct SpiderSenses {\n    //     robot: Rc<SpiderRobot>, /// <-- pointer to settings and I/O\n    //     eyes: [Camera; 32],\n    //     motion: Accelerometer,\n    //     ...\n    // }\n\n    use std::cell::Cell;\n    use std::cell::RefCell;\n    use std::fs::File;\n\n    pub struct SpiderRobot {\n        hardware_error_count: Cell<u32>,\n        log_file: RefCell<File>,\n    }\n\n    impl SpiderRobot {\n        /// Increase the error count by 1.\n        pub fn add_hardware_error(&self) {\n            let n = self.hardware_error_count.get();\n            self.hardware_error_count.set(n + 1);\n        }\n\n        /// True if any hardware errors have been reported.\n        pub fn has_hardware_errors(&self) -> bool {\n            self.hardware_error_count.get() > 0\n        }\n\n        /// Write a line to the log file.\n        pub fn log(&self, message: &str) {\n            let mut file = self.log_file.borrow_mut();\n            // writeln!(file, \"{}\", message).unwrap();\n        }\n    }\n\n    let ref_cell: RefCell<String> = RefCell::new(\"hello\".to_string());\n\n    let r = ref_cell.borrow(); // ok, return a Ref<String>\n    let count = r.len(); // ok, returns \"hello\".len()\n    assert_eq!(count, 5);\n\n    // let mut w = ref_cell.borrow_mut(); // panic: already borrowed\n    // w.push_str(\" world\");\n}", "id": 225, "concepts": ["object-oriented programming", "bagging", "value semantics", "smart pointers", "closures as methods", "tuple structs", "enumerations"], "instruction": "Create a Rust class `Image` that describes a digital image. The class should maintain the height, width, and pixel values of the image. It should offer methods to read and write the image from and to a file. The class should also support transformations such as image resizing and flipping."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: random number generator, pivot element selection, quicksort algorithm\n\n### Task", "fingerprint": null, "seed": "pub fn pivot<T: PartialOrd>(v: &mut [T]) -> usize {\n    let mut p = rand::read(v.len());\n    v.swap(p, 0);\n    p = 0;\n    for i in 1..v.len() {\n        if v[i] < v[p] {\n            // move our pivot forward 1, and put this element before it\n            v.swap(p+1, i);\n            v.swap(p, p+1);\n            p += 1\n        }\n    }\n    p\n}", "id": 226, "concepts": ["random number generator", "pivot element selection", "quicksort algorithm"], "instruction": "Develop a Rust function `quicksort` that takes a list of integers as an input and sorts it in-place using the quicksort algorithm. The function should also return the sorted list of integers. You should use a random number generator to select a random pivot element and the partitioning method described in the selection algorithm."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: conversion of raw data into game-ready data, branching based on a condition, nested loops\n\n### Task", "fingerprint": null, "seed": "fn de_timeline(raw: TimelineRaw, even: bool) -> game::Timeline {\n    let mut res = game::Timeline::new(\n        de_l(raw.index, even),\n        raw.width,\n        raw.height,\n        raw.begins_at,\n        raw.emerges_from.map(|x| de_l(x, even)),\n    );\n\n    let index = de_l(raw.index, even);\n    let begins_at = raw.begins_at;\n    let width = raw.width;\n    let height = raw.height;\n\n    res.states = raw\n        .states\n        .into_iter()\n        .enumerate()\n        .map(|(i, b)| de_board(b, begins_at + i as isize, index, width, height))\n        .collect();\n\n    res\n}", "id": 227, "concepts": ["conversion of raw data into game-ready data", "branching based on a condition", "nested loops"], "instruction": "Create a Rust function that converts a raw list of data into a list that is suitable for a game. The conversion process should involve multiple steps. The first step converts the raw data into a one-dimensional list. The second step converts this one-dimensional list into a two-dimensional list with two columns. The third step should add a third column based on the values in the first and second columns.\n\nFor each row in the original data, the second column is the row index, and the first column is the value corresponding to the index. For example, the input data [[1, 2, 3], [4, 5, 6], [7, 8, 9]] would be converted into [[0, 1, 2], [1, 2, 3], [2, 4, 5]], and the third column would be the sum of the first two columns.\n\nEnsure the function handles both indefinite and definite inputs. Provide clear error handling and logging to manage exceptions that might occur during the conversion process."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: NULL check in SQL query, list comparison, execution of SQL statements, list initialization\n\n### Task", "fingerprint": null, "seed": "fn\ntest_empty_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nempty\n=\nvec\n!\n[\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nempty\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nempty\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 228, "concepts": ["NULL check in SQL query", "list comparison", "execution of SQL statements", "list initialization"], "instruction": "Design a Rust class that takes a SQL query as a string, executes it, and returns the results as a list of rows. The SQL query is composed of column names and values separated by `=` and `AND` conditions. The class should handle the following cases:\n\n- Where a column name is not found in the result set, return `[]`\n- If there are multiple rows with the same values in a column, the first row should be chosen\n- If there are no rows that match the given conditions, return `[]`"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: assert, function return value, error handling\n\n### Task", "fingerprint": null, "seed": "fn check_layout(layout: Layout) -> Result<(), AllocErr> {\n    if layout.size() > LARGEST_POWER_OF_TWO {\n        return Err(AllocErr::Unsupported { details: \"Bigger than largest power of two\" });\n    }\n    debug_assert!(layout.size() > 0);\n    Ok(())\n}", "id": 229, "concepts": ["assert", "function return value", "error handling"], "instruction": "Implement a Rust function `largest_odd_number` that takes an input list of integers `numbers` and returns the largest integer that is not divisible by 2. If no such integer exists, the function returns `None`. You should use an `assert` statement and handle any potential errors using error handling."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: async function execution, logging, server start, execution branching, HTTP request handling\n\n### Task", "fingerprint": null, "seed": "async fn main() {\n    env::set_var(\"RUST_LOG\", \"warp_server\");\n    env_logger::init();\n\n    let log = warp::log(\"warp_server\");\n\n    let homepage = warp::path::end().map(|| {\n        Response::builder()\n            .header(\"content-type\", \"text/html\")\n            .body(\n                \"<html><h1>juniper_warp</h1><div>visit <a href=\\\"/playground\\\">/playground</a></html>\"\n                    .to_string(),\n            )\n    });\n\n    log::info!(\"Listening on 127.0.0.1:8080\");\n\n    let state = warp::any().map(move || Context {});\n    let graphql_filter = juniper_warp::make_graphql_filter(schema(), state.boxed());\n\n    warp::serve(\n        warp::get()\n            .and(warp::path(\"playground\"))\n            .and(juniper_warp::playground_filter(\"/graphql\", None))\n            .or(homepage)\n            .or(warp::path(\"graphql\").and(graphql_filter))\n            .with(log),\n    )\n    .run(([127, 0, 0, 1], 8080))\n    .await\n}", "id": 230, "concepts": ["async function execution", "logging", "server start", "execution branching", "HTTP request handling"], "instruction": "Design a Rust function to handle asynchronous HTTP requests. The function should handle HTTP requests to a `localhost` server on port `5000` that responds to requests to `https://localhost:5000/async/test` with a status of 200 with the content of 'Hello, World!'. Additionally, handle and log any errors that might occur during the server startup and requests to the server.\n\nThe function should be able to handle requests to `https://localhost:5000/sync/test` and return a status of 200 with the content of 'Hello, World!'. The function should also handle requests to `https://localhost:5000/async/test2` and return a status of 200 with the content of 'Hello, World!'. For each case, execute the request in a separate thread and execute the request in an asynchronous manner."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: compilation of programs, error handling with Result type, branch prediction and code execution\n\n### Task", "fingerprint": null, "seed": "pub fn test_jump0() {\n    let buffer = fs::read(\"tests/programs/jump0_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"jump0_64\".into()]);\n    assert!(result.is_err());\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 232, "concepts": ["compilation of programs", "error handling with Result type", "branch prediction and code execution"], "instruction": "Compile and run the following Rust program, which counts the number of lines in a file, `count_lines.rs`.\n\n```rust\nuse std::env;\nuse std::fs::File;\nuse std::io::{BufReader, BufRead};\n\nfn main() {\n    let filename: Option<String> = env::args().nth(1);\n    let filename_str = filename.as_ref().unwrap();\n    let file = File::open(filename_str).expect(\"Could not open file\");\n    let reader = BufReader::new(file);\n    let mut line_count = 0;\n    for line in reader.lines() {\n        line_count += 1;\n    }\n    println!(\"Number of lines: {}\", line_count);\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: module configuration, module and segment construction, module configuration with arguments, module configuration with conditional logic, configuration variables for conditional logic\n\n### Task", "fingerprint": null, "seed": "pub fn module<'a>(context: &'a Context) -> Option<Module<'a>> {\n    const SUCCESS_CHAR: &str = \"\u279c\";\n    const FAILURE_CHAR: &str = \"\u2716\";\n    let color_success = Color::Green.bold();\n    let color_failure = Color::Red.bold();\n\n    let mut module = context.new_module(\"character\")?;\n    module.get_prefix().set_value(\"\");\n\n    let arguments = &context.arguments;\n    let use_symbol = module\n        .config_value_bool(\"use_symbol_for_status\")\n        .unwrap_or(false);\n    let exit_success = arguments.value_of(\"status_code\").unwrap_or(\"0\") == \"0\";\n\n    /* If an error symbol is set in the config, use symbols to indicate\n    success/failure, in addition to color */\n    let symbol = if use_symbol && !exit_success {\n        module.new_segment(\"error_symbol\", FAILURE_CHAR)\n    } else {\n        module.new_segment(\"symbol\", SUCCESS_CHAR)\n    };\n\n    if exit_success {\n        symbol.set_style(color_success.bold());\n    } else {\n        symbol.set_style(color_failure.bold());\n    };\n\n    Some(module)\n}", "id": 233, "concepts": ["module configuration", "module and segment construction", "module configuration with arguments", "module configuration with conditional logic", "configuration variables for conditional logic"], "instruction": "Design a Rust module that takes a series of configuration parameters to initialize different modules of a class. The module should handle the instantiation of modules that represent the segments of a class, with each segment being a subclass of the class. The segment configuration should be flexible and can be configured with both a fixed or variable number of arguments, as well as conditional logic. The output should be a list of instantiated segments.\n\nFor example, given a configuration for a class with 3 segments, with a fixed number of arguments (3, 6, 8) for each segment, the output should be a list of 3 instantiated segments with 3, 3, and 2 attributes respectively. A third segment should be instantiated with 5 arguments instead of 3, as the conditional logic handles the configuration of this segment."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: BTreeMap, sorting and accessing data from a vector, tuple destructuring, type inference\n\n### Task", "fingerprint": null, "seed": "fn most_least_common(btm: BTreeMap<char, i32>) -> (char, char) {\n    let mut count_vec: Vec<_> = btm.into_iter().collect();\n    // Reverse sort the vector of pairs by \"value\" (sorted by \"key\" in case of tie)\n    count_vec.sort_by(|a, b| b.1.cmp(&a.1));\n    let m = count_vec.first().map(|&(k, _)| k).unwrap();\n    let l = count_vec.last().map(|&(k, _)| k).unwrap();\n    (m, l)\n}", "id": 234, "concepts": ["BTreeMap", "sorting and accessing data from a vector", "tuple destructuring", "type inference"], "instruction": "Design a Rust program that takes a list of tuples as input, where each tuple consists of two elements: an integer and a string. The program should sort the list of tuples by the integer value and output the list in ascending order.\n\nFor example, given a list of tuples `[(2, \"a\"), (1, \"b\"), (3, \"c\")]`, the program should output `[(1, \"b\"), (2, \"a\"), (3, \"c\")]`.\n\nTo solve this problem, the program must first extract and sort the integers from the input list. This can be done by using a third-party library such as BTreeMap (for unordered maps) or SortedList (for ordered maps) to store the integers and their corresponding strings. Then, the program can loop through the list of tuples and construct a new list of tuples by accessing the sorted integers and corresponding strings from the BTreeMap."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: asynchronous programming, asynchronous library integration, asynchronous configuration, asynchronous environment detection\n\n### Task", "fingerprint": null, "seed": "async fn init() -> Nash {\n    dotenv().ok();\n\n    let parameters = NashParameters {\n        credentials: Some(NashCredentials {\n            secret: env::var(\"NASH_API_SECRET\").unwrap(),\n            session: env::var(\"NASH_API_KEY\").unwrap(),\n        }),\n        environment: Environment::Sandbox,\n        client_id: 1,\n        timeout: 1000,\n    };\n\n    OpenLimits::instantiate(parameters).await\n}", "id": 235, "concepts": ["asynchronous programming", "asynchronous library integration", "asynchronous configuration", "asynchronous environment detection"], "instruction": "Design a Rust function that takes a filename as a string and returns whether the file exists, is a regular file, and is readable. The function should handle all error cases gracefully. The function should be fully asynchronous and provide a standardized interface for asynchronous library integration."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: File system access, path manipulation, error handling, conditionals, return statements\n\n### Task", "fingerprint": null, "seed": "fn read_or_create_default_database() -> Result<DataBase> {\n    let default_database_paths = get_default_database_paths();\n\n    if default_database_paths.is_empty() {\n        eprintln!(\"{}\", format!(\n            \"Could not find a location for the default database. \\\n            Opening a database which cannot be saved.\",\n        ).color(\"yellow\"));\n\n        return Ok(DataBase::new());\n    }\n\n    // See if a default database can be found at any path before creating a new one.\n    for path in &default_database_paths {\n        if path.is_file() {\n            return read_database(&path).map_err(|err| GrafenCliError::from(err))\n        }\n    }\n\n    let mut default_database = DataBase::new();\n    let default_path = &default_database_paths[0];\n\n    if let Some(parent_dir) = default_path.parent() {\n        match DirBuilder::new().recursive(true).create(&parent_dir) {\n            Ok(_) => default_database.set_path(&default_path).unwrap(),\n            Err(err) => {\n                eprintln!(\"{}\", format!(\n                    \"Warning: Could not create a folder for a default database at '{}' ({}). \\\n                    Opening a database which cannot be saved.\",\n                    default_path.display(), err\n                ).color(\"yellow\"));\n            },\n        }\n    }\n\n    Ok(default_database)\n}", "id": 236, "concepts": ["File system access", "path manipulation", "error handling", "conditionals", "return statements"], "instruction": "Design a Rust class that represents a file system directory. The class should provide methods for creating or deleting directories, checking for the existence of files or directories, and traversing the directory tree."}
