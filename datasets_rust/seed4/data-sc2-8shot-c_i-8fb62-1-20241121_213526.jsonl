{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: error handling, string formatting, standard library functions, return value checking\n\n### Task", "fingerprint": null, "seed": "fn send_err(stream: &mut TcpStream, err: Error) {\n    let _ = stream.write(err.to_string().as_bytes()).expect(\"failed a write\");\n}", "id": 3, "concepts": ["error handling", "string formatting", "standard library functions", "return value checking"], "instruction": "Create a Rust function that takes a string input and returns a list of all non-empty substrings of the input string. The substrings should be in lexicographic order."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: test-driven programming, software design, configuration files, test-driven development, file operations, command-line argument passing, assertions, conditional branching\n\n### Task", "fingerprint": null, "seed": "fn init_with_target() {\n    let project = project(\"init_with_target\").build();\n    project\n        .cargo_fuzz()\n        .arg(\"init\")\n        .arg(\"-t\")\n        .arg(\"custom_target_name\")\n        .assert()\n        .success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"custom_target_name\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"custom_target_name\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}", "id": 4, "concepts": ["test-driven programming", "software design", "configuration files", "test-driven development", "file operations", "command-line argument passing", "assertions", "conditional branching"], "instruction": "Create a Rust function `parse_config(filename)` that loads a configuration file in JSON format, parses the file contents into a dictionary, and returns a dictionary containing the configuration settings. Use test-driven development to design and implement the function.\n\nThe function `parse_config` should take a single string argument that specifies the path to the configuration file. It should load and parse the file contents into a dictionary using the `serde_json` crate. The function should then return a dictionary containing the parsed configuration settings.\n\nInclude error handling for invalid JSON syntax and missing configuration files, as well as any other errors that may arise during the parsing process. Additionally, include assertions to ensure the correctness of the function implementation, including assertions for valid JSON syntax, reading configuration files, and handling any potential errors."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: recursive function calls, ownership, dictionary mutation\n\n### Task", "fingerprint": null, "seed": "fn up_to_release(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    to: &VersionTag,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    let to_commit = repo.find_commit(to.commit).map_err(|e| {\n        ErrorContext(\n            format!(\n                \"find_commit: repo={}, commit={}\",\n                repo.path().display(),\n                to.commit\n            ),\n            Box::new(e),\n        )\n    })?;\n    let modules = get_submodules(&repo, &to_commit)?;\n\n    let mut author_map = build_author_map(&repo, &reviewers, &mailmap, \"\", &to.raw_tag)\n        .map_err(|e| ErrorContext(format!(\"Up to {}\", to), e))?;\n\n    for module in &modules {\n        if let Ok(path) = update_repo(&module.repository) {\n            let subrepo = Repository::open(&path)?;\n            let submap = build_author_map(\n                &subrepo,\n                &reviewers,\n                &mailmap,\n                \"\",\n                &module.commit.to_string(),\n            )?;\n            author_map.extend(submap);\n        }\n    }\n\n    Ok(author_map)\n}", "id": 5, "concepts": ["recursive function calls", "ownership", "dictionary mutation"], "instruction": "Implement a class that represents a small database with the following features:\n- Read and write key-value pairs to a file at a specified path.\n- Clear the content of the file.\n- Get the top-N most frequent keys in the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: test framework, programming language features\n\n### Task", "fingerprint": null, "seed": "pub fn test_andi() {\n    let buffer = fs::read(\"tests/programs/andi\").unwrap().into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"andi\".into()]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}", "id": 6, "concepts": ["test framework", "programming language features"], "instruction": "Construct a Rust function `run_test(test_name, input_data, expected_output)` that runs a function-based test case. The function should receive three arguments: `test_name`, the name of the test case; `input_data`, the input data to be processed by the function; and `expected_output`, the expected output of the function.\n\nThe function should show a passing or failing result for each test case in a user-friendly format. If the input data does not match the expected output, the function should also show the input and the expected output for the failed test case.\n\nThe function should also support the following assertions:\n\n```rust\nassert_eq!(run_test(\"test1\", \"abc\", \"abc\"), true);\nassert_eq!(run_test(\"test2\", \"abcd\", \"abcd\"), true);\nassert_eq!(run_test(\"test3\", \"abcde\", \"abcde\"), true);\nassert_eq!(run_test(\"test4\", \"abc\", \"efg\"), false);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: C-like programming language, memory access with unsafe, general control flow with match expressions, UUID conversion with string manipulation\n\n### Task", "fingerprint": null, "seed": "pub unsafe extern \"C\" fn gatt_svr_register_cb(\n    ctxt: *mut ble_gatt_register_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) {\n    let mut buf_arr: [i8; BLE_UUID_STR_LEN as usize] = [0; BLE_UUID_STR_LEN as usize];\n    let buf = buf_arr.as_mut_ptr();\n\n    match (*ctxt).op as u32 {\n        BLE_GATT_REGISTER_OP_SVC => {\n            printf(\n                cstr!(\"registered service %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.svc.svc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.svc.handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_CHR => {\n            printf(\n                cstr!(\"registering characteristic %s with def_handle=%d val_handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.chr.chr_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.chr.def_handle as i32,\n                (*ctxt).__bindgen_anon_1.chr.val_handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_DSC => {\n            printf(\n                cstr!(\"registering descriptor %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.dsc.dsc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.dsc.handle as i32,\n            );\n        }\n        _ => {\n            printf(cstr!(\"unknown operation: %d\\n\"), (*ctxt).op as u32);\n        }\n    }\n}", "id": 8, "concepts": ["C-like programming language", "memory access with unsafe", "general control flow with match expressions", "UUID conversion with string manipulation"], "instruction": "Write a Rust program that takes a string input and converts it into a UUID object in hexadecimal format. The input string should be a UUID in the form of 32 hexadecimal digits separated by hyphens. You should use the starting position of each hyphen as a byte offset to parse the UUID value. The program should print the original input and the converted UUID in hexadecimal format."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call abstraction, C function call, buffering, concurrent execution\n\n### Task", "fingerprint": null, "seed": "fn system_call(message: SystemCall) -> SystemCall {\n    let addr = task_buffer_addr();\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}", "id": 9, "concepts": ["system call abstraction", "C function call", "buffering", "concurrent execution"], "instruction": "Write a Rust class named `Process` that encapsulates a process running in a Linux system, with the following functionality:\n- `read`: Read a specified number of characters from the standard input (stdin) and return them as a string.\n- `write`: Write a string to the standard output (stdout).\n- `__enter__`: Start the process in a separate thread.\n- `__exit__`: Wait for the process to finish and return its exit code."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: fuzzing with provided corpus, libFuzzer, test framework, command-line argument parsing, output filtering\n\n### Task", "fingerprint": null, "seed": "fn run_alt_corpus() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_alt\");\n    let alt_corpus = Path::new(\"fuzz\").join(\"alt-corpus\").join(\"run_alt\");\n\n    let project = project(\"run_alt_corpus\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_alt\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() <= 1);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"fail\"), \"fail\")\n        .file(alt_corpus.join(\"pass-0\"), \"0\")\n        .file(alt_corpus.join(\"pass-1\"), \"1\")\n        .file(alt_corpus.join(\"pass-2\"), \"2\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_alt\")\n        .arg(&alt_corpus)\n        .arg(\"--\")\n        .arg(\"-runs=0\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"3 files found in fuzz/alt-corpus/run_alt\")\n                .and(predicate::str::contains(\"fuzz/corpus/run_alt\").not())\n                // libFuzzer will always test the empty input, so the number of\n                // runs performed is always one more than the number of files in\n                // the corpus.\n                .and(predicate::str::contains(\"Done 4 runs in\")),\n        )\n        .success();\n}", "id": 10, "concepts": ["fuzzing with provided corpus", "libFuzzer", "test framework", "command-line argument parsing", "output filtering"], "instruction": "Write a Rust program that takes a list of command-line arguments as input and performs operations on them. The list of arguments may contain any number of strings, and the program must identify which operation should be performed based on the first argument.\n\nThe program must support the following operations:\n\n- `reverse`: reverse the input list\n- `shuffle`: shuffle the input list\n- `shuffle-reverse`: reverse the input list and then shuffle it\n\nThe program must utilize the provided fuzzing corpus to identify which operation is being performed. The provided corpus includes predefined test cases, as well as a test case for each operation.\n\nTo accomplish this, the program must use the [libFuzzer](https://llvm.org/docs/LibFuzzer.html) framework.\n\nThe program must utilize the [test](https://crates.io/crates/test) framework for unit testing.\n\nThe program must utilize the [structopt](https://crates.io/crates/structopt) crate for command-line argument parsing.\n\nThe program must support for output filtering to remove extraneous information from the program's output.\n\nThe program must be incorporated into a top-level `Cargo.toml` manifest file, and leverage the `cargo-fuzz` subcommand to trigger the fuzzing experiments."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file path manipulation, environment variable lookup, error handling, file system access, file paths resolution, string manipulation\n\n### Task", "fingerprint": null, "seed": "fn read_input_configurations(confs: Vec<PathBuf>) -> (Vec<ComponentEntry>, Vec<ComponentEntry>) {\n    let mut configurations = Vec::new();\n\n    for path in confs {\n        match read_configuration(&path) {\n            Ok(conf) => configurations.push(conf),\n            Err(err) => eprintln!(\"{}\", err),\n        }\n    }\n\n    eprint!(\"\\n\");\n\n    let current_dir = current_dir().unwrap_or(PathBuf::new());\n    let entries = configurations\n        .iter()\n        .map(|conf| ReadConf {\n            conf: None,\n            path: current_dir.join(&conf.path),\n            backup_conf: None,\n            description: conf.description.clone(),\n            volume_type: conf.volume_type.clone(),\n        })\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    let components = configurations\n        .into_iter()\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    (components, entries)\n}", "id": 11, "concepts": ["file path manipulation", "environment variable lookup", "error handling", "file system access", "file paths resolution", "string manipulation"], "instruction": "Design a Rust class `PathResolver` that resolves file paths relative to the current working directory, without using the `Path` module provided by the standard library. The class should handle errors gracefully by following the standard Python error handling mechanisms for file path exceptions. Additionally, the class should also support relative file paths, such as `..`, `../`, and `./`.\n\nYou are allowed to use libraries that simplify your solution. For instance, you can use the `Path` module provided in the standard library, or use file path manipulation functions from the `os` and `os.path` modules."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: handling errors in data retrieval, filtering out empty strings, filtering based on path existence\n\n### Task", "fingerprint": null, "seed": "pub fn get_history(history_type: HistoryType) -> Result<String, ()> {\n    let configurator = Configurator::new();\n    let history = configurator.get_history(history_type);\n    // filter out empty string and not exist history path\n    let clean_history: Vec<&String> = match history_type {\n        HistoryType::WorkingFolder => history\n            .into_iter()\n            .filter(|s| !s.is_empty())\n            .filter(|s| Path::new(s).is_dir())\n            .collect::<Vec<_>>(),\n        _ => history\n            .into_iter()\n            .filter(|s| !s.is_empty())\n            .filter(|s| Path::new(s).is_file())\n            .collect::<Vec<_>>(),\n    };\n\n    let history_json_text =\n        serde_json::to_string(&clean_history).unwrap_or_else(|_| String::from(\"[]\"));\n    Ok(history_json_text)\n}", "id": 12, "concepts": ["handling errors in data retrieval", "filtering out empty strings", "filtering based on path existence"], "instruction": "Write a Rust function called `get_file_content_by_path` that takes a string argument `path` as input, and returns the file content as a string if the file exists and is readable. If the file does not exist or is not readable, the function should raise an exception that is defined in the `FileError` class. If the file is empty or contains only whitespace, the function should return an empty string. The function should also check if the path exists and is readable before attempting to read the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: extern \"C\" function, C binding, C binding from Rust\n\n### Task", "fingerprint": null, "seed": "extern \"C\" fn gatt_svr_chr_access_heart_rate(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    /* Sensor location, set to \"Chest\" */\n    const BODY_SENS_LOC: u8 = 0x01;\n\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_HRS_BODY_SENSOR_LOC_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                &BODY_SENS_LOC as *const u8 as *const c_void,\n                size_of::<u8>() as u16,\n            )\n        };\n\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}", "id": 13, "concepts": ["extern \"C\" function", "C binding", "C binding from Rust"], "instruction": "Write a Rust class with a method `add_numbers_C(a, b)` that adds two numbers `a` and `b` and returns the result. The method should be implemented in C and linked to the Rust code as a `extern \"C\"` function."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: integration testing with `cargo-fuzz`, fuzz test execution, profdata file generation, file manipulation\n\n### Task", "fingerprint": null, "seed": "fn run_with_coverage() {\n    let target = \"with_coverage\";\n\n    let project = project(\"run_with_coverage\")\n        .with_fuzz()\n        .fuzz_target(\n            target,\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    println!(\"{:?}\", data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(target)\n        .arg(\"--\")\n        .arg(\"-runs=100\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 100 runs\"))\n        .success();\n\n    project\n        .cargo_fuzz()\n        .arg(\"coverage\")\n        .arg(target)\n        .assert()\n        .stderr(predicate::str::contains(\"Coverage data merged and saved\"))\n        .success();\n\n    let profdata_file = project.fuzz_coverage_dir(target).join(\"coverage.profdata\");\n    assert!(profdata_file.exists(), \"Coverage data file not generated\");\n}", "id": 14, "concepts": ["integration testing with `cargo-fuzz`", "fuzz test execution", "profdata file generation", "file manipulation"], "instruction": "Write a Rust function `is_prime` that takes an integer `n` as input and returns a boolean indicating whether `n` is a prime number or not. Utilize `cargo-fuzz` to develop fuzz tests for this function. Ensure that fuzz tests are automatically run when the function is modified or when new test cases are added. Generate a profile data file for the fuzz tests to measure the function's performance and find bottlenecks. Finally, write a Rust program that takes a prime number `n` as input and writes the `n`th prime number to a text file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: string formatting, string concatenation, conditional branching, looping\n\n### Task", "fingerprint": null, "seed": "fn string_test() {\n    // literal\n    let speech = \"\\\"Ouch!\\\" said the well.\\n\";\n    println!(\"{}\", speech);\n    println!(\n        \"In the room the women come and go,\n         Singing of Mount Abora\"\n    );\n    println!(\n        \"It was a bright, cold day in Aplil, and \\\n         there were four of us \\\n         more or less.\"\n    );\n\n    let default_win_install_path = r\"C:\\Program Files\\Gorillas\";\n    println!(\"{}\", default_win_install_path);\n    // let pattern = Regex::new(r\"\\d(\\.\\d+)*\");\n\n    println!(\n        r###\"\n        This raw string started with 'r###\"'.\n        Therefore it does not end until we reach a quote mark ('\"')\n        followed immediately by three pound signs ('###'):\n    \"###\n    );\n\n    // byte strings\n    let method = b\"GET\";\n    assert_eq!(method, &[b'G', b'E', b'T']);\n\n    let noodles = \"noodles\".to_string();\n    let oodles = &noodles[1..];\n    let poodles = \"\\u{CA0}_\\u{CA0}\";\n\n    assert_eq!(oodles.len(), 6);\n    assert_eq!(poodles.len(), 7);\n    assert_eq!(poodles.chars().count(), 3);\n\n    // let mut s = \"hello\";\n    // s[0] = 'c'; error: tye thpe 'str' cannot be mutably indexed\n    // s.push('\\n'); error: no method named `push` found for type `&str`\n\n    assert_eq!(\n        format!(\"{}\u00b0 {:02}\u2019 {:02}\u201d N\", 24, 5, 23),\n        \"24\u00b0 05\u2019 23\u201d N\".to_string()\n    );\n    let bits = vec![\"veni\", \"vidi\", \"vici\"];\n    assert_eq!(bits.concat(), \"venividivici\");\n    assert_eq!(bits.join(\",\"), \"veni,vidi,vici\");\n\n    assert!(\"ONE\".to_lowercase() == \"one\");\n\n    assert!(\"peanut\".contains(\"nut\"));\n    assert_eq!(\"\\u{CA0}_\\u{CA0}\".replace(\"\\u{CA0}\", \"\u25a0\"), \"\u25a0_\u25a0\");\n    assert_eq!(\"     clean\\n\".trim(), \"clean\");\n\n    for word in \"veni, vidi, vici\".split(\", \") {\n        assert!(word.starts_with(\"v\"));\n    }\n}", "id": 15, "concepts": ["string formatting", "string concatenation", "conditional branching", "looping"], "instruction": "Write a Rust function to generate a multiplication table. The function should take a positive integer as a parameter and return a string. The string should show the multiplication table for the given number. The generation of each line of the table should follow this pattern: `[A] * [B] = [C]`, where the values of `A`, `B`, and `C` are determined by the function's parameter. The function should also include a user-friendly header that shows the title of the table as well as the corresponding column and row labels."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expressions for pattern matching, capturing groups, iterating over lines\n\n### Task", "fingerprint": null, "seed": "fn commit_coauthors(commit: &Commit) -> Vec<Author> {\n    let mut coauthors = vec![];\n    if let Some(msg) = commit.message_raw() {\n        lazy_static::lazy_static! {\n            static ref RE: Regex =\n                RegexBuilder::new(r\"^Co-authored-by: (?P<name>.*) <(?P<email>.*)>\")\n                    .case_insensitive(true)\n                    .build()\n                    .unwrap();\n        }\n\n        for line in msg.lines().rev() {\n            if line.starts_with(\"Co-authored-by\") {\n                if let Some(caps) = RE.captures(line) {\n                    coauthors.push(Author {\n                        name: caps[\"name\"].to_string(),\n                        email: caps[\"email\"].to_string(),\n                    });\n                }\n            }\n        }\n    }\n    coauthors\n}", "id": 17, "concepts": ["regular expressions for pattern matching", "capturing groups", "iterating over lines"], "instruction": "Write a program that accepts a string as input and prints the contents of the file with the specified string appended to the end. The string should be appended to each line of the file. The program should handle cases where the string is empty or contains whitespace."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: if-else-if-else branching, optional value handling\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    println!(\"Common letters in the box ids: {}\",\n             match find_common_id() {\n                 Some(s) => s,\n                 None => \"NA\".to_string()\n             });\n}", "id": 19, "concepts": ["if-else-if-else branching", "optional value handling"], "instruction": "Write a Rust program that satisfies the following conditions:\n- The program should take a string as an argument from the command line.\n- The program should use a series of conditional statements to determine the length of the string.\n- The program should provide different messages for different string lengths.\n- The program should use optional value handling to gracefully handle empty or null strings in the input."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: error message parsing with predicate, multiple conditional branching\n\n### Task", "fingerprint": null, "seed": "fn init_twice() {\n    let project = project(\"init_twice\").build();\n\n    // First init should succeed and make all the things.\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n\n    // Second init should fail.\n    project\n        .cargo_fuzz()\n        .arg(\"init\")\n        .assert()\n        .stderr(predicates::str::contains(\"File exists (os error 17)\").and(\n            predicates::str::contains(format!(\n                \"failed to create directory {}\",\n                project.fuzz_dir().display()\n            )),\n        ))\n        .failure();\n}", "id": 20, "concepts": ["error message parsing with predicate", "multiple conditional branching"], "instruction": "Write a Rust class `MyError` that represents a custom error type for your future projects. The class should handle errors produced by a custom function `my_func` that you will implement. The class should be able to handle all three types of errors that might arise when calling `my_func`: 1. `MyErrorKind::MyErrorKind1(n)` for the first error, where `n` represents the value of the parameter `n` that caused the error; 2. `MyErrorKind::MyErrorKind2` for the second error; and 3. `MyErrorKind::MyErrorKind3` for the third error. In case of any other error, the class should raise a `MyError::MyError(e)` with a default error message."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: JSON deserialization, stream reading, error handling, type casting\n\n### Task", "fingerprint": null, "seed": "fn get_command(stream: &mut TcpStream, buf: &mut[u8]) -> Result<Task, Error> {\n    let buf_sz = stream.read(buf).expect(\"failed to read from stream\");\n    let buf_usize = buf_sz as usize;\n\n    let v = match serde_json::from_slice::<Task>(&buf[..buf_usize]){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}", "id": 21, "concepts": ["JSON deserialization", "stream reading", "error handling", "type casting"], "instruction": "Write a Rust function that deserializes a JSON object from a file path and returns a dictionary representation of the object.\nThe function should handle malformed JSON or JSON with syntax errors.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(\n    deserialize_json(\"test_data/example1.json\").unwrap(),\n    json!({\n        \"array\": [1, 2, 3, 4],\n        \"bool\": true,\n        \"float\": 1.0,\n        \"int\": 1,\n        \"null\": null,\n        \"string\": \"test\",\n        \"object\": {\n            \"foo\": \"bar\"\n        },\n    })\n);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: conditional statement, function definition, function call\n\n### Task", "fingerprint": null, "seed": "fn print_uint(x:uint) {\n\tprintln!(\"{}\",x);\n}", "id": 22, "concepts": ["conditional statement", "function definition", "function call"], "instruction": "Design a Rust class `User` with a method `is_valid_password(password)` that checks whether a provided password is valid and returns a boolean. Define the method so that it validates a password if it is at least 6 characters long, contains at least one number, and contains at least one lowercase and one uppercase letter."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: string processing, nested conditional branching, ASCII character value calculations\n\n### Task", "fingerprint": null, "seed": "pub fn day09_2(s: String) -> u32{\n    let mut running_total = 0;\n\n    let mut in_garbage = false;\n    let mut prev_cancel = false;\n    for c in s.chars(){\n        if in_garbage {\n            if c == '>' && !prev_cancel {\n                in_garbage = false;\n                prev_cancel = false;\n            }\n            else if c == '!' && !prev_cancel {\n                prev_cancel = true;\n            }\n            else if !prev_cancel{\n                running_total+=1;\n            }\n            else {\n                prev_cancel = false;\n            }\n        }\n        else{\n            if c == '<' {\n                in_garbage = true;\n                prev_cancel = false;\n            }\n        }\n    }\n    running_total\n}", "id": 23, "concepts": ["string processing", "nested conditional branching", "ASCII character value calculations"], "instruction": "Create a Rust function `calculate_ascii_sum` that takes a string as an argument, calculates the sum of the ASCII values of all characters in the string, and returns the sum. Use conditional branching statements to determine the range of the ASCII values. The function should also handle the following edge cases:\n- If the string is empty, return `0`.\n- If the string contains non-ASCII characters, return `-1`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file system operations, command-line argument parsing, string formatting and manipulation\n\n### Task", "fingerprint": null, "seed": "fn add() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n\n    assert!(project.fuzz_cargo_toml().is_file());\n    let cargo_toml = fs::read_to_string(project.fuzz_cargo_toml()).unwrap();\n    let expected_bin_attrs = \"test = false\\ndoc = false\";\n    assert!(cargo_toml.contains(expected_bin_attrs));\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"new_fuzz_target\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}", "id": 24, "concepts": ["file system operations", "command-line argument parsing", "string formatting and manipulation"], "instruction": "Implement a Rust class `FileIO` with the following methods:\n\n- `read_file(file_name)`: reads and returns the content of the given file.\n- `write_file(file_name, file_content)`: writes a given file with the given content.\n- `create_file(file_name)`: creates a new file with a given name.\n- `delete_file(file_name)`: deletes the file with a given name.\n- `read_file_line_by_line(file_name)`: reads and returns the content of the given file as a list of lines.\n- `parse_command_line_args(command_line_args)`: parses a command line arguments as a list of command line arguments, and returns a `namedtuple` of command line arguments."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: HashMap and TreeMap data structures, read and write operations, mutability\n\n### Task", "fingerprint": null, "seed": "fn a_table_should_read_what_was_put() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }]);\n  let mut vs = [Value::default(); 1];\n  table.read (1, &[0], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }]);\n}", "id": 25, "concepts": ["HashMap and TreeMap data structures", "read and write operations", "mutability"], "instruction": "Create a Rust class `User` that manages the information of a user. The class should store information such as a user ID, name, email, and password. Provide functions for reading and writing the information. The class should be implemented to handle errors such as missing or invalid data or unauthorized writes."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call invocation, enum-based system call interface, function argument structuring\n\n### Task", "fingerprint": null, "seed": "pub fn retype_cpool(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeCPool {\n        request: (source, target),\n    });\n}", "id": 26, "concepts": ["system call invocation", "enum-based system call interface", "function argument structuring"], "instruction": "Create a Rust class `SystemCall` that encapsulates system calls to the operating system. The class encapsulates a system call's name and arguments, which are passed to the system call through function arguments. The class also provides an interface to invoke the system call, which is handled by a central method: `invoke_sys_call(self)`.\n\nThe method `invoke_sys_call` executes the system call by calling a system-specific function through the function pointer passed in as an argument. The method returns the system call's return value by parsing a system call's return value through a struct that indicates the return value type and its length.\n\nThe class should handle erroneous inputs gracefully, such as incorrect system call names or arguments. Additionally, implement the `__str__` method to return a formatted string showing the system call name and its arguments."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: file reading, Rust enum with associated values, module nesting, assertion checking\n\n### Task", "fingerprint": null, "seed": "pub fn test_mulw64() {\n    let buffer = fs::read(\"tests/programs/mulw64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"mulw64\".into()]);\n    assert!(result.is_ok());\n}", "id": 27, "concepts": ["file reading", "Rust enum with associated values", "module nesting", "assertion checking"], "instruction": "Write a Rust program to count the number of words in a text file and the frequency of each word. The program should read the file and count the occurrence of each word using a Rust `HashMap` with the word as key and the count as value. Then, print the results in the following format:\n\n```\nWord_1: Count_1\nWord_2: Count_2\n...\n```\n\nFor example, given the following text in `file.txt`:\n```\nThe quick brown fox jumps over the lazy dog.\n```\n\nThe program output should be:\n```\nThe: 1\nquick: 1\nbrown: 1\nfox: 1\njumps: 1\nover: 1\nthe: 2\nlazy: 1\ndog: 1\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: custom syscall implementation, `read` syscall function, `fs::read` function, `core::str::from_utf8` function, string manipulation\n\n### Task", "fingerprint": null, "seed": "pub fn test_custom_syscall() {\n    let buffer = fs::read(\"tests/programs/syscall64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .syscall(Box::new(CustomSyscall {}))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"syscall\".into()])\n        .unwrap();\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 39);\n}", "id": 28, "concepts": ["custom syscall implementation", "`read` syscall function", "`fs::read` function", "`core::str::from_utf8` function", "string manipulation"], "instruction": "Write a Rust function `read_file_bytes` that takes a file path as an input and reads the contents of the file into a byte array. The function should return a vector of bytes containing the contents of the file.\n\nThe function should use the `read` syscall to read the contents of the file, and handle errors and invalid file paths accordingly. It should also use the `fs::read` function to read the file content into a byte array, and convert it to a `String` before checking for errors."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: iterating over a list of different types, list comprehension, file system API, data path discovery\n\n### Task", "fingerprint": null, "seed": "fn get_default_database_paths() -> Vec<PathBuf> {\n    get_platform_dependent_data_dirs()\n        .into_iter()\n        .map(|dir| dir.join(\"grafen\").join(DEFAULT_DBNAME))\n        .collect()\n}", "id": 30, "concepts": ["iterating over a list of different types", "list comprehension", "file system API", "data path discovery"], "instruction": "Create a Rust function `read_file_paths` that takes a folder path as an input and returns a list containing the full file paths of all files in the given folder. It should use the Python `os` module's `walk` function to iterate over a folder structure and its subfolders, as well as the `os.path.join` function to generate the full file paths. The function should also handle errors and exceptions appropriately."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: testing a custom project, implementation of the cargo fuzz subcommand, handling command-line arguments for the fuzz target\n\n### Task", "fingerprint": null, "seed": "fn list() {\n    let project = project(\"add\").with_fuzz().build();\n\n    // Create some targets.\n    project.cargo_fuzz().arg(\"add\").arg(\"c\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"b\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"a\").assert().success();\n\n    // Make sure that we can list our targets, and that they're always sorted.\n    project\n        .cargo_fuzz()\n        .arg(\"list\")\n        .assert()\n        .stdout(\"a\\nb\\nc\\n\")\n        .success();\n}", "id": 31, "concepts": ["testing a custom project", "implementation of the cargo fuzz subcommand", "handling command-line arguments for the fuzz target"], "instruction": "Create a custom project that includes a fuzz target that computes the intersection of two lists. The fuzz target should take two lists of arbitrary numbers as input and output the intersection of the two lists.\n\nYour fuzz target should be implemented using the `cargo-fuzz` subcommand. The `cargo-fuzz` subcommand is an extension of the `cargo` subcommand that supports fuzzing Rust projects. It allows you to configure and execute fuzzing targets within your project's `Cargo.toml` file.\n\nTo use `cargo-fuzz`, you will need to install it from crates.io:\n\n```bash\n$ cargo install cargo-fuzz\n```\n\nOnce installed, you can create a fuzz target by using the `cargo-fuzz new` command within your project's root directory:\n\n```bash\n$ cargo fuzz new fuzz_target\n```\n\nThis will create a new fuzz target directory in your project's `fuzz` directory with the specified name. Inside this directory, you can add your fuzz target source code and configuration files.\n\nTo compile and run your fuzz target, you can use the `cargo-fuzz run` command:\n\n```bash\n$ cargo fuzz run fuzz_target\n```\n\nThis will compile and run the fuzz target with the default settings. You can customize the compilation and execution of your fuzz target by modifying the `fuzz_target.rs` file. For example, you can use the `cargo-fuzz run` command with the `--no-default-features` flag to exclude the default features during the compilation of your fuzz target:\n\n```bash\n$ cargo fuzz run --no-default-features fuzz_target\n```\n\nYou can also provide command-line arguments to your fuzz target using the `cargo-fuzz run` command:\n\n```bash\n$ cargo fuzz run fuzz_target -- <argument1> <argument2>\n```\n\nFor more information on `cargo-fuzz`, refer to its documentation on crates.io."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: C language interoperability (C FFI), string literal to bytes conversion, precondition checking for type validation\n\n### Task", "fingerprint": null, "seed": "extern \"C\" fn gatt_svr_chr_access_device_info(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_MODEL_NUMBER_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MODEL_NUM.as_ptr() as *const c_void,\n                MODEL_NUM.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    if uuid == GATT_MANUFACTURER_NAME_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MANUF_NAME.as_ptr() as *const c_void,\n                MANUF_NAME.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}", "id": 33, "concepts": ["C language interoperability (C FFI)", "string literal to bytes conversion", "precondition checking for type validation"], "instruction": "Create a Rust class that wraps a C function that takes a string argument and returns a pointer to a dynamically-allocated char array. The class should expose a method `get(self, key: str)` that queries a string from the protected C function, given the key string. Write assertions to ensure the input key is a string and the output is a byte array that is just passed to Rust."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: floating point comparisons, truncation, arithmetic operations, conditional if statement\n\n### Task", "fingerprint": null, "seed": "fn de_l(raw: f32, even: bool) -> i32 {\n    if even && raw < 0.0 {\n        (raw.ceil() - 1.0) as i32\n    } else {\n        raw.floor() as i32\n    }\n}", "id": 35, "concepts": ["floating point comparisons", "truncation", "arithmetic operations", "conditional if statement"], "instruction": "Create a Rust class that represents a real number and provides operations like addition, subtraction, multiplication, and division. Represent the class with the following properties:\n\n- `numerator` and `denominator` represent the numerator and denominator of the real number\n- `Decimal` should be an alias of `f64` type\n\nWhen initializing the class, `numerator` and `denominator` should be provided as parameters. Implicitly, `denominator` should be initialized as `1`, and when the class is initialized with `1` as the `denominator`, it should be treated as the identity of the real number.\n\nThe class should provide the following methods:\n\n- `add` - adds the given real number to the current instance\n- `subtract` - subtracts the given real number from the current instance\n- `multiply` - multiplies the current instance with the given real number\n- `divide` - divides the current instance by the given real number\n\nThe methods should be implemented following the operator precedence rules. For example, `a.add(b.multiply(c))` should be evaluated as `a.add(b).multiply(c)`, not as `a.multiply(b).add(c)`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: fuzzing with project_template, file generation and manipulation, file reading, API call composition\n\n### Task", "fingerprint": null, "seed": "fn cmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"foo\");\n    let project = project(\"cmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"foo\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let _ = data;\n                });\n            \"#,\n        )\n        .file(corpus.join(\"0\"), \"\")\n        .file(corpus.join(\"1\"), \"a\")\n        .file(corpus.join(\"2\"), \"ab\")\n        .file(corpus.join(\"3\"), \"abc\")\n        .file(corpus.join(\"4\"), \"abcd\")\n        .build();\n\n    let corpus_count = || {\n        fs::read_dir(project.root().join(\"fuzz\").join(\"corpus\").join(\"foo\"))\n            .unwrap()\n            .count()\n    };\n    assert_eq!(corpus_count(), 5);\n\n    project\n        .cargo_fuzz()\n        .arg(\"cmin\")\n        .arg(\"foo\")\n        .assert()\n        .success();\n    assert_eq!(corpus_count(), 1);\n}", "id": 37, "concepts": ["fuzzing with project_template", "file generation and manipulation", "file reading", "API call composition"], "instruction": "Create a Rust function that reads a file of URLs and queries the URL to obtain a JSON response. This response may contain a list of links. The function should return a list of URLs that refer to files with an extension of `.txt`, regardless of the file type and case. The function should also handle the case when the response is not in JSON format and raise an exception instead."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: async/await, delay implementation, launching external program and output parsing, API call validation\n\n### Task", "fingerprint": null, "seed": "async fn get_wifi_profile(ssid: &str) -> Option<String> {\n    delay_for(Duration::from_millis(10)).await;\n\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n            ssid,\n            obfstr::obfstr!(\"key=clear\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    Some(String::from_utf8_lossy(&output.stdout).to_string())\n}", "id": 39, "concepts": ["async/await", "delay implementation", "launching external program and output parsing", "API call validation"], "instruction": "Create a Rust class that manages a launch of an external program and parses its output. The class should accept a valid command line string as an argument, and launch the external process specified by the command.\n\nThe external process should be launched asynchronously and the output of the process should be parsed by the class.\n\nThe class should provide methods for controlling and retrieving the process' state:\n\n- `start()` should launch the external process asynchronously and provide a status to indicate its progress.\n- `wait()` should return once the external process has finished its work.\n- `get_status()` should return the current status of the external process.\n- `get_output()` should return the process' output.\n\nThe class should use the `async`/`await` keywords to handle asynchronous operations within the context of the `main` function, and parse the process' output as a stream of lines."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: logical conditional in a function implementation, string matching and string literal\n\n### Task", "fingerprint": null, "seed": "fn is_rollup_commit(commit: &Commit) -> bool {\n    let summary = commit.summary().unwrap_or(\"\");\n    summary.starts_with(\"Rollup merge of #\")\n}", "id": 40, "concepts": ["logical conditional in a function implementation", "string matching and string literal"], "instruction": "Write a Rust program that takes a string as input and outputs the first word from the end of the string that matches the pattern `[A-Z][a-z]*`. The program should handle invalid input gracefully by outputting an empty string.\n\nFor example, given the input `\"This is the first example\"`, the program should output `\"first\"`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: compilation with inline assembly, memory layout, program execution\n\n### Task", "fingerprint": null, "seed": "pub fn test_misaligned_jump64() {\n    let buffer = fs::read(\"tests/programs/misaligned_jump64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"misaligned_jump64\".into()]);\n    assert!(result.is_ok());\n}", "id": 41, "concepts": ["compilation with inline assembly", "memory layout", "program execution"], "instruction": "Develop a Rust function `get_address` that computes the address of a global variable. The function should accept the name of the global variable as an input and return its memory address as a pointer."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call invocation\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_inactive(target: CAddr) {\n    system_call(SystemCall::TaskSetInactive {\n        request: target\n    });\n}", "id": 42, "concepts": ["system call invocation"], "instruction": "Write a Rust class that implements a sparse matrix using a Hash Table (a dictionary-like structure). This class should support the following operations:\n- `set_value(row, col, value)`\n- `get_value(row, col)`\n- `get_row(row)`\n- `get_col(col)`\n- `get_diag_neg()`\n- `get_diag_pos()`\n\nThe `set_value()` function should set the value at the specified row and column. The function should not throw an error in case the provided row and column are out of bounds.\n\nThe `get_value()` function should return the value at the specified row and column. It should throw an error in case the provided row and column are out of bounds.\n\nThe `get_row()` function should return a list of values for the specified row. It should throw an error in case the provided row is out of bounds.\n\nThe `get_col()` function should return a list of values for the specified column. It should throw an error in case the provided column is out of bounds.\n\nThe `get_diag_neg()` function should return a list of values on the diagonal that starts from the bottom left corner to the top right corner. The diagonal should start from the bottom left corner and continue towards the top right corner.\n\nThe `get_diag_pos()` function should return a list of values on the diagonal that starts from the top left corner to the bottom right corner. The diagonal should start from the top left corner and continue towards the bottom right corner."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: checksum calculation with multiple base cases in recursion, checksum calculation with 3 base cases in recursion, checksum calculation with 1 base case in recursion\n\n### Task", "fingerprint": null, "seed": "pub fn checksum(input: &[u8]) -> Result<u16, LayerError> {\n    let mut sum = 0x00;\n    let mut chunks_iter = input.chunks_exact(2);\n    while let Some(chunk) = chunks_iter.next() {\n        sum += u32::from(u16::from_be_bytes(\n            chunk.try_into().expect(\"chunks of 2 bytes\"),\n        ));\n    }\n\n    if let [rem] = chunks_iter.remainder() {\n        sum += u32::from(u16::from_be_bytes([*rem, 0x00]));\n    }\n\n    let carry_add = (sum & 0xffff) + (sum >> 16);\n    let chksum = !(((carry_add & 0xffff) + (carry_add >> 16)) as u16);\n\n    Ok(chksum)\n}", "id": 43, "concepts": ["checksum calculation with multiple base cases in recursion", "checksum calculation with 3 base cases in recursion", "checksum calculation with 1 base case in recursion"], "instruction": "Write a Rust function to perform a checksum of a string by adding the ASCII codes of each character. For example, `a` is 97, so `a + b + a = 194`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: ownership with reference counting, closure in trait implementation, Rc usage\n\n### Task", "fingerprint": null, "seed": "pub fn var(v: Var) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::Var(v),\n        computed: false,\n    }))\n}", "id": 44, "concepts": ["ownership with reference counting", "closure in trait implementation", "Rc usage"], "instruction": "Create a Rust program that performs a sequence of string operations on a list of strings. The program should start with a list of unsorted strings, and each operation should modify the strings in a specific way. For example, the first operation should sort the list of strings according to the length of the string, and the second operation should reverse the order of the strings in the list. The program should run until all operations have been performed.\n\nThe program should utilize trait objects and closure functions in order to achieve the desired behavior. The program should include robust error handling and ensure that the input is a list of strings."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call invocation, function parameter types, untyped addresses\n\n### Task", "fingerprint": null, "seed": "pub fn map_raw_page_free(vaddr: usize, untyped: CAddr, toplevel_table: CAddr, page: CAddr) {\n    system_call(SystemCall::MapRawPageFree {\n        untyped: untyped,\n        toplevel_table: toplevel_table,\n        request: (vaddr, page),\n    });\n}", "id": 45, "concepts": ["system call invocation", "function parameter types", "untyped addresses"], "instruction": "Implement a Rust function `get_hostname` that gets the host name of the local system. The function should use `std::net::Ipv4Addr` to parse the IP address of the local host and invoke the `gethostbyaddr` system call with the parsed IP address."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: stack-based algorithm, iterating through a string, panicking on invalid input\n\n### Task", "fingerprint": null, "seed": "fn santa(instruction: &String) -> i32 {\n    // if '(' up else if ')' down\n    let mut floor: i32 = 0;\n    for paren in instruction.chars() {\n        println!(\"{}\", paren);\n        match paren {\n            '(' => floor += 1,\n            ')' => floor -= 1,\n            _ => panic!(),\n        }\n    }\n    floor\n}", "id": 46, "concepts": ["stack-based algorithm", "iterating through a string", "panicking on invalid input"], "instruction": "Design a Rust program that performs a basic calculator operation. The program should accept a string from the command line, interpret it as an expression, and print the result. The program should support a subset of the standard arithmetic operators (+, -, *, /, %) and parentheses for grouping expressions.\n\nIf the input is invalid, the program should use `panic!` to print a descriptive error message and exit."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call invocation, function return value handling\n\n### Task", "fingerprint": null, "seed": "pub fn retype_raw_page_free(source: CAddr) -> CAddr {\n    let result = system_call(SystemCall::RetypeRawPageFree {\n        request: source,\n        response: None\n    });\n    match result {\n        SystemCall::RetypeRawPageFree {\n            response, ..\n        } => { return response.unwrap(); },\n        _ => panic!(),\n    };\n}", "id": 47, "concepts": ["system call invocation", "function return value handling"], "instruction": "Create a Rust function `get_hostname` that returns the host name of the local system. Utilize the `os::hostname()` function from the `nix` crate as an example."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: LLVM IR parsing and execution, symbolic execution of LLVM IR\n\n### Task", "fingerprint": null, "seed": "pub fn test_op_rvc_slli_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_slli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_slli_crash_32\".into()]);\n    assert!(result.is_ok());\n}", "id": 48, "concepts": ["LLVM IR parsing and execution", "symbolic execution of LLVM IR"], "instruction": "Write a Rust function that performs symbolic execution of LLVM IR code. For example, given the input LLVM IR of the function `f`:\n```\ndefine i32 @f(i32 %a, i32 %b) {\n  %c = add i32 %a, %b\n  %d = mul i32 %c, %b\n  %e = sub i32 %a, %d\n  ret i32 %e\n}\n```\nthe function should return the value of the symbolic execution for the inputs `(a, b) = (1, 2)`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: vector reflection, vector operations with dot product, vector decomposition, immutable functions\n\n### Task", "fingerprint": null, "seed": "fn reflect(v: &Vec3, n: &Vec3) -> Vec3 {\n    *v - *n * 2.0 * dot(v, n)\n}", "id": 49, "concepts": ["vector reflection", "vector operations with dot product", "vector decomposition", "immutable functions"], "instruction": "Develop a Rust program that performs a vector reflection operation on a vector. The program should return the reflected vector of the original vector."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, list extension, treeview, treeiter, treeiter-treeiter relationship, treeview-treeiter relationship, iter-iter relationship, type conversion, type casting, treeview-liststore relationship, liststore-treeiter relationship, gvalue-treeiter relationship\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    gtk::init();\n\n    let mut window = gtk::Window::new(gtk::WindowType::TopLevel).unwrap();\n\n    window.set_title(\"TreeView Sample\");\n    window.set_window_position(gtk::WindowPosition::Center);\n\n    Connect::connect(&window, DeleteEvent::new(&mut |_| {\n        gtk::main_quit();\n        true\n    }));\n\n    // test Value\n\n    let hello = String::from(\"Hello world !\");\n    let value = glib::Value::new().unwrap();\n\n    value.init(glib::Type::String);\n    value.set(&hello);\n    println!(\"gvalue.get example : {}\", value.get::<String>());\n\n    // left pane\n\n    let mut left_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let left_store = gtk::ListStore::new(&column_types).unwrap();\n    let left_model = left_store.get_model().unwrap();\n\n    left_tree.set_model(&left_model);\n    left_tree.set_headers_visible(false);\n    append_text_column(&mut left_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n        left_store.append(&mut iter);\n        left_store.set_string(&iter, 0, \"I'm in a list\");\n    }\n\n    // right pane\n\n    let mut right_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let right_store = gtk::TreeStore::new(&column_types).unwrap();\n    let right_model = right_store.get_model().unwrap();\n\n    right_tree.set_model(&right_model);\n    right_tree.set_headers_visible(false);\n    append_text_column(&mut right_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut iter, None);\n        right_store.set_value(&iter, 0, &value);\n\n        let mut child_iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut child_iter, Some(&iter));\n        right_store.set_string(&child_iter, 0, \"I'm a child node\");\n    }\n\n    // display the panes\n\n    let mut split_pane = gtk::Box::new(gtk::Orientation::Horizontal, 10).unwrap();\n\n    split_pane.set_size_request(-1, -1);\n    split_pane.add(&left_tree);\n    split_pane.add(&right_tree);\n\n    window.add(&split_pane);\n    window.show_all();\n    gtk::main();\n}", "id": 50, "concepts": ["list comprehension", "list extension", "treeview", "treeiter", "treeiter-treeiter relationship", "treeview-treeiter relationship", "iter-iter relationship", "type conversion", "type casting", "treeview-liststore relationship", "liststore-treeiter relationship", "gvalue-treeiter relationship"], "instruction": "Create a Rust function that converts a list of strings to a treeview. The treeview should be populated with the original list of strings.\n\nApply a predefined CSS styling to each row of the treeview by assigning a background color. The background color of a row is the same as the string it represents."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: null pointer constants in Rust, const functions, pointer type, return value\n\n### Task", "fingerprint": null, "seed": "const fn null_ble_gatt_chr_def() -> ble_gatt_chr_def {\n    return ble_gatt_chr_def {\n        uuid: ptr::null(),\n        access_cb: None,\n        arg: (ptr::null_mut()),\n        descriptors: (ptr::null_mut()),\n        flags: 0,\n        min_key_size: 0,\n        val_handle: (ptr::null_mut()),\n    };\n}", "id": 51, "concepts": ["null pointer constants in Rust", "const functions", "pointer type", "return value"], "instruction": "Write a Rust class to implement a stack using an array. Implement the following methods:\n- `is_empty`: returns true if the stack is empty, otherwise false\n- `peek`: returns the top element of the stack\n- `push`: add an element to the top of the stack\n- `pop`: remove an element from the top of the stack"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: pointer alignment, address calculation, conditional branching\n\n### Task", "fingerprint": null, "seed": "fn align_address(ptr: *const u8, align: usize) -> usize {\n    let addr = ptr as usize;\n    if addr % align != 0 {\n        align - addr % align\n    } else {\n        0\n    }\n}", "id": 52, "concepts": ["pointer alignment", "address calculation", "conditional branching"], "instruction": "Write a Rust function called `pointer_alignment` that takes an integer `n` and returns the number `k` such that the result of `calculate_address` with `k` as `offset` and `n` as `size` is divisible by 8. This function should calculate the address of an object in memory based on its size and offset. The function should return the alignment number `k`, which is an integer value that satisfies the alignment constraint, and `None` if the alignment constraint is not satisfied."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file system I/O, parsing an ELF binary, handling ELF binary sections\n\n### Task", "fingerprint": null, "seed": "pub fn test_contains_ckbforks_section() {\n    let buffer = fs::read(\"tests/programs/ckbforks\").unwrap();\n    let ckbforks_exists_v0 = || -> bool {\n        let elf = goblin_v023::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    let ckbforks_exists_v1 = || -> bool {\n        let elf = goblin_v040::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    assert_eq!(ckbforks_exists_v0, true);\n    assert_eq!(ckbforks_exists_v1, true);\n}", "id": 53, "concepts": ["file system I/O", "parsing an ELF binary", "handling ELF binary sections"], "instruction": "Write a Rust function to return the size of an ELF binary. An ELF binary is a file format that contains a list of segments. A segment is a contiguous range of bytes in the file that has a particular purpose (e.g., code, data, bss, etc.)\n\nThe binary is an executable file that contains a list of segments, including text, data, and bss. The function should return an integer that represents the total size of the binary in bytes."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: memory store creation, memory store interface, advanced assertion checking, return value testing\n\n### Task", "fingerprint": null, "seed": "pub fn test_memory_store_empty_bytes() {\n    assert_memory_store_empty_bytes(&mut FlatMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut SparseMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut WXorXMemory::<FlatMemory<u64>>::default());\n    #[cfg(has_asm)]\n    assert_memory_store_empty_bytes(&mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000));\n}", "id": 54, "concepts": ["memory store creation", "memory store interface", "advanced assertion checking", "return value testing"], "instruction": "Write a Rust function `create_store` that creates an in-memory data store to store key-value pairs. This function should take a name for the store as an argument, and return a store interface that can be used to store, retrieve, and remove key-value pairs from the store. The store interface should provide an `insert` method to insert a key-value pair into the store, a `get` method to retrieve the value associated with a key, and a `remove` method to remove a key-value pair from the store, with the expectation that all operations are successful."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: control flow with Result, named tuple construction, string interpolation, return value construction\n\n### Task", "fingerprint": null, "seed": "fn build_serverprefix(s: ~str) -> Result<IRCToken, ~str> {\n    Ok(PrefixT(Prefix {nick: s, user: ~\"\", host: ~\"\"}))\n}", "id": 55, "concepts": ["control flow with Result", "named tuple construction", "string interpolation", "return value construction"], "instruction": "Write a Rust program to classify a string as an IP address, an IPv4 address, or an IPv6 address. The program should take a string input from the command line and output a classification result to the console. The program should accept input of the form `192.168.100.1`, `192.168.100`, and `192.168.100.100.100.100.100.100`, but reject input of the form `192.168.100.10.10.10`, which does not conform to the IP address format. The program should also handle input that is not a string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file system manipulation, file input/output, dynamic unit selection, conditional compilation\n\n### Task", "fingerprint": null, "seed": "fn main() {\n\n    #[cfg(feature = \"breakout\")]\n    let memfile_bytes = include_bytes!(\"stm32h743zi_memory.x\");\n    #[cfg(not(feature = \"breakout\"))]\n    let memfile_bytes = include_bytes!(\"stm32h743vi_memory.x\");\n\n    // Put the linker script somewhere the linker can find it\n    let out = &PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n    File::create(out.join(\"memory.x\"))\n        .unwrap()\n        .write_all(memfile_bytes)\n        .unwrap();\n    println!(\"cargo:rustc-link-search={}\", out.display());\n}", "id": 56, "concepts": ["file system manipulation", "file input/output", "dynamic unit selection", "conditional compilation"], "instruction": "Write a Rust function called `get_best_unit` that takes the path to a file as an argument. The function should use a series of conditional compilation directives to determine the optimal unit for reading the file and return the best unit for input and output.\n\n- If the unit of the file is \"GB\", the function should return \"MB\" for reading and writing.\n- If the unit of the file is \"KB\", the function should return \"MB\" for reading and \"GB\" for writing.\n- If the unit of the file is \"MB\", the function should return \"GB\" for reading and \"KB\" for writing.\n\nIf the unit of the file is any other unit, the function should return \"B\" for reading and \"B\" for writing."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: command-line argument parsing, mocking project state, file system operations\n\n### Task", "fingerprint": null, "seed": "fn init_finds_parent_project() {\n    let project = project(\"init_finds_parent_project\").build();\n    project\n        .cargo_fuzz()\n        .current_dir(project.root().join(\"src\"))\n        .arg(\"init\")\n        .assert()\n        .success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n}", "id": 57, "concepts": ["command-line argument parsing", "mocking project state", "file system operations"], "instruction": "Write a Rust function to process a list of strings representing pathnames. The function should accept a path as an argument and search each directory within the path for all files that contain the given string. The function should return a list of absolute paths to the files found.\n\nThe function should support both absolute and relative paths as input, and should support both relative and absolute paths for output. For example, if `find_files(\"hello\", \"../Desktop\")` is called, the function should return a list of all files on the Desktop folder whose name contains the string \"hello\".\n\nThe function should also handle paths that contain special characters or non-ASCII characters. For example, `find_files(\"hello\", \"/home/user/Downloads/\")` should return a list of all files on the Downloads folder whose name contains the string \"hello\".\n\nThe function should be implemented using Rust's standard library only. It should not use any third-party libraries that are not listed as dependencies.\n\nThe function should have a main function that demonstrates its use. You can use the following code to create a list of files:\n\n```rust\nlet files = vec![\n    \"/home/user/Pictures/file1.png\",\n    \"/home/user/Documents/file2.txt\",\n    \"/home/user/Downloads/file3.pdf\",\n    \"/home/user/Videos/file4.mp4\",\n    \"/home/user/Music/file5.mp3\",\n    \"/home/user/Videos/file6.mp4\",\n    \"/home/user/Videos/file7.mp4\",\n    \"/home/user/Music/file8.mp3\",\n];\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async/await syntax, HTTP response formatting\n\n### Task", "fingerprint": null, "seed": "async fn index(_req: HttpRequest) -> impl Responder {\n    HttpResponse::Ok().json(\"Catalog API root\")\n}", "id": 58, "concepts": ["async/await syntax", "HTTP response formatting"], "instruction": "Write a Rust function called `format_http_response` that takes the status code and body of an HTTP response as strings and returns a formatted string for the HTTP response. The function should use `async fn` syntax and should include the following elements:\n\n- HTTP status code, such as 200 OK or 404 Not Found\n- HTTP response body, which can be JSON, HTML, or plain text\n- Plain text message in error cases\n- The formatting should be according to [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231#section-6.1)\n\nThe function should return a `Result` based on either `Ok` or `Err`. If the status code is 200 or 201, the function should return `Ok(body)`. If the status code is anything other than 200, the function should return `Err(body)`. The `body` string should be formatted according to the above convention.\n\nFor example, given a status code of 200 and body `{\"message\": \"OK\", \"data\": \"Hello World\"}`, the function should return `Ok(\"HTTP/1.1 200 OK\\r\\nContent-Type: application/json\\r\\n\\r\\n{\\\"message\\\": \\\"OK\\\", \\\"data\\\": \\\"Hello World\\\"}\\n\")`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: random number generation, global state management, unit testing\n\n### Task", "fingerprint": null, "seed": "pub fn test_memory_load_bytes() {\n    let mut rng = thread_rng();\n\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 0);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 2);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 1024 * 6);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 0, 0);\n}", "id": 59, "concepts": ["random number generation", "global state management", "unit testing"], "instruction": "Implement a Rust program that plays a guessing game with the user. The game starts by generating a random number between 1 and 100. The user will be prompted to make guesses until they find the correct number. Upon each guess, the program should output one of the following messages: `Too low`, `Too high`, or `You got it!`. The game should end when the user finds the number. You should write a unit test for your implementation to ensure that the random number generator is working as expected.\n\nFor example, given the input `1, 100`, the program should output:\n\n```\n[INFO] The number is between 1 and 100 (inclusive).\n[INFO] What is your guess? \n[INFO] Too low.\n[INFO] What is your guess? \n[INFO] Too high.\n[INFO] What is your guess? \n[INFO] You got it!\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: OS-dependent data paths, environment variable usage, path manipulations, conditional compilation, iteration over iterable collections\n\n### Task", "fingerprint": null, "seed": "fn get_platform_dependent_data_dirs() -> Vec<PathBuf> {\n    let xdg_data_dirs_variable = var(\"XDG_DATA_DIRS\")\n        .unwrap_or(String::from(\"/usr/local/share:/usr/local\"));\n    let xdg_dirs_iter = xdg_data_dirs_variable.split(':').map(|s| Some(PathBuf::from(s)));\n\n    let dirs = if cfg!(target_os = \"macos\") {\n        vec![\n            var_os(\"XDG_DATA_HOME\").map(|dir| PathBuf::from(dir)),\n            home_dir().map(|dir| dir.join(\"Library\").join(\"Application Support\"))\n        ].into_iter()\n         .chain(xdg_dirs_iter)\n         .chain(vec![Some(PathBuf::from(\"/\").join(\"Library\").join(\"Application Support\"))])\n         .collect()\n    } else if cfg!(target_os = \"linux\") {\n        vec![\n            var_os(\"XDG_DATA_HOME\").map(|dir| PathBuf::from(dir)),\n            home_dir().map(|dir| dir.join(\".local\").join(\"share\"))\n        ].into_iter()\n         .chain(xdg_dirs_iter)\n         .collect()\n    } else if cfg!(target_os = \"windows\") {\n        vec![var_os(\"APPDATA\").map(|dir| PathBuf::from(dir))]\n    } else {\n        Vec::new()\n    };\n\n    dirs.into_iter().filter_map(|dir| dir).collect()\n}", "id": 61, "concepts": ["OS-dependent data paths", "environment variable usage", "path manipulations", "conditional compilation", "iteration over iterable collections"], "instruction": "Implement a Rust class `DirectoryManager` that helps manage the file system. The class should support creating, deleting, and listing directories. Utilize conditional compilation to conditionally compile methods based on platform-specific file system paths. The class should also include methods for getting, setting, and manipulating environment variables.\n\nThe class should handle errors gracefully, such as invalid inputs, missing files, etc. When creating a directory, the class should ensure that the path doesn't already exist or that the parent directory exists. Similarly, when deleting a directory, the class should check that the directory exists and that it is empty. Additionally, the class should provide a method to list directories based on an optional filter to limit the results."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: explicit vector initialization, vec! macro, vector literal, vector iteration, vector slicing, vector reverse, vector capacity, vector length, vector push, vector pop, vector insert, vector remove, vector build with for loop\n\n### Task", "fingerprint": null, "seed": "fn vector_test() {\n    {\n        fn build_vector() -> Vec<i16> {\n            let mut v: Vec<i16> = Vec::<i16>::new();\n            v.push(10i16);\n            v.push(20i16);\n            v\n        }\n\n        fn build_vector_2() -> Vec<i16> {\n            let mut v = Vec::new();\n            v.push(10);\n            v.push(20);\n            v\n        }\n        let v1 = build_vector();\n        let v2 = build_vector_2();\n        assert_eq!(v1, v2);\n    }\n    let mut v1 = vec![2, 3, 5, 7];\n    assert_eq!(v1.iter().fold(1, |a, b| a * b), 210);\n\n    v1.push(11);\n    v1.push(13);\n    assert_eq!(v1.iter().fold(1, |a, b| a * b), 30030);\n\n    let mut v2 = Vec::new();\n    v2.push(\"step\");\n    v2.push(\"on\");\n    v2.push(\"no\");\n    v2.push(\"pets\");\n    assert_eq!(v2, vec![\"step\", \"on\", \"no\", \"pets\"]);\n\n    let v3: Vec<i32> = (0..5).collect();\n    assert_eq!(v3, [0, 1, 2, 3, 4]);\n\n    let mut v4 = vec![\"a man\", \"a plan\", \"a canal\", \"panama\"];\n    v4.reverse();\n    assert_eq!(v4, vec![\"panama\", \"a canal\", \"a plan\", \"a man\"]);\n\n    let mut v5 = Vec::with_capacity(2);\n    assert_eq!(v5.len(), 0);\n    assert_eq!(v5.capacity(), 2);\n\n    v5.push(1);\n    v5.push(2);\n    assert_eq!(v5.len(), 2);\n    assert_eq!(v5.capacity(), 2);\n\n    v5.push(3);\n    assert_eq!(v5.len(), 3);\n    assert_eq!(v5.capacity(), 4);\n\n    let mut v6 = vec![10, 20, 30, 40, 50];\n\n    v6.insert(3, 35);\n    assert_eq!(v6, [10, 20, 30, 35, 40, 50]);\n\n    v6.remove(1);\n    assert_eq!(v6, [10, 30, 35, 40, 50]);\n\n    let mut v7 = vec![\"carmen\", \"miranda\"];\n    assert_eq!(v7.pop(), Some(\"miranda\"));\n    assert_eq!(v7.pop(), Some(\"carmen\"));\n    assert_eq!(v7.pop(), None);\n\n    // let languages: Vec<String> = std::env::args().skip(1).collect();\n    let languages = vec![\"Lisp\", \"Scheme\", \"C\", \"C++\", \"Fortran\"];\n    let mut v8 = Vec::new();\n    for l in languages {\n        if l.len() % 2 == 0 {\n            v8.push(\"functional\");\n        } else {\n            v8.push(\"imperative\");\n        }\n    }\n    assert_eq!(\n        v8,\n        [\n            \"functional\",\n            \"functional\",\n            \"imperative\",\n            \"imperative\",\n            \"imperative\"\n        ]\n    );\n\n    // slice\n\n    let v9: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];\n    let a9: [f64; 4] = [0.0, 0.707, 1.0, 0.707];\n\n    let sv: &[f64] = &v9;\n    let sa: &[f64] = &a9;\n\n    assert_eq!(sv[0..2], [0.0, 0.707]);\n    assert_eq!(sa[2..], [1.0, 0.707]);\n    assert_eq!(&sv[1..3], [0.707, 1.0]);\n}", "id": 62, "concepts": ["explicit vector initialization", "vec! macro", "vector literal", "vector iteration", "vector slicing", "vector reverse", "vector capacity", "vector length", "vector push", "vector pop", "vector insert", "vector remove", "vector build with for loop"], "instruction": "Develop a Rust program that reads a text file containing a list of string values, and uses vector operations to perform the following tasks:\n\n- Initialize a vector with the contents of the file in the order they appear in the file.\n- Reverse and print the vector.\n- Print the last 3 elements of the vector.\n- Print the first 3 elements of the vector.\n- Set the 3rd element of the vector to \"zero\".\n- Set the 3rd element of the vector to \"default\".\n- Print the length and capacity of the vector.\n- Print the length and capacity of the vector, after resizing to the full capacity.\n- Print the length and capacity of the vector, after resizing to the half capacity.\n- Remove the 5th element from the vector.\n- Remove the last element from the vector.\n- Shrink the vector to the minimum size required for its current content.\n- Insert an element at the beginning of the vector.\n- Insert an element at the end of the vector.\n- Insert an element at a specific index in the vector."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: explicit channel message handling, explicit payload handling\n\n### Task", "fingerprint": null, "seed": "pub fn channel_take_cap(target: CAddr) -> CAddr {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Cap(v) => return v.unwrap(),\n        _ => panic!(),\n    };\n}", "id": 63, "concepts": ["explicit channel message handling", "explicit payload handling"], "instruction": "Implement a Rust function that reads a text file and outputs its content line by line. The function should take a file path as a string input and return a `Future` that will resolve with a list of strings. Each string in the list should be a line of the original file. The function should be written in a way that enables the caller to manage the returned `Future`. For example, the caller can start the `Future` and then wait for the result, or add a handler to the `Future` to handle the result asynchronously."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: command-line argument parsing, file system operations, path manipulations, file extraction\n\n### Task", "fingerprint": null, "seed": "fn main() {     \n        std::process::Command::new(\"packfolder.exe\").args(&[\"src/frontend\", \"dupa.rc\", \"-binary\"])\n    .output().expect(\"no i ciul\");\n}", "id": 64, "concepts": ["command-line argument parsing", "file system operations", "path manipulations", "file extraction"], "instruction": "Implement a Rust function that reads a text file and extracts a string of characters (max. 100) from a specified line number in the file. The file should be provided in the command-line arguments. Validate the input before proceeding with the task.\n\nFor example, given the input `myfile.txt` containing the following text:\n\n```\nThis is sample text\nto test the program.\n```\n\nThe command should output `This is sample text` if the input is `1`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: boolean test for character type, character to integer conversion, string iteration, character length measurement\n\n### Task", "fingerprint": null, "seed": "fn char_test() {\n    assert_eq!('*'.is_alphabetic(), false);\n    assert_eq!('\u03b2'.is_alphabetic(), true);\n    assert_eq!('8'.to_digit(10), Some(8));\n    assert_eq!('\\u{CA0}'.len_utf8(), 3);\n    assert_eq!(std::char::from_digit(2, 10), Some('2'));\n}", "id": 65, "concepts": ["boolean test for character type", "character to integer conversion", "string iteration", "character length measurement"], "instruction": "Implement a Rust function to check if an input string consists only of characters that are a to z, A to Z, and 0 to 9. Only the first character should be capitalized. The task should employ string iteration and character length measurement."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: function composition, trait implementation, return value handling\n\n### Task", "fingerprint": null, "seed": "pub fn test_trace() {\n    let buffer = fs::read(\"tests/programs/trace64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"trace64\".into()]);\n    assert!(result.is_err());\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 66, "concepts": ["function composition", "trait implementation", "return value handling"], "instruction": "Implement a Rust function `calculate_bus_ticket_cost` that calculates the total cost of a bus ticket based on the number of travelers, bus classes, and travel dates. The function should take two arguments: `travelers` and `ticket`, which are instances of `BusTicket` and `BusClass`, respectively.\n\nThe `BusTicket` class should have two properties: `travelers` and `classes`, both of type `Vec<BusClass>`. A `BusClass` has three properties: `name`, `price`, and `dates`, which are strings.\n\nThe function should return a float representing the total cost of the ticket, calculated as follows:\n\n- travelers $\\times$ classes $\\times$ `price` $\\times$ number of travel dates\n\nImplement all the necessary classes and functions in the `bus_ticket_calculator` module."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string parsing, text file parsing, nested structure parsing, variable initialization, list comprehension with multiple elements, conditional branching\n\n### Task", "fingerprint": null, "seed": "fn parseLightInfo(reader: &mut BufReader<&File>, buf: &mut String, lights: &mut Vec<Light>) -> Model {\r\n    let mut light = Light {\r\n        lightType: \"\" as str,\r\n        radius: 0.0,\r\n        period: 0,\r\n        position: Vec3f::new(0.0, 0.0, 0.0),\r\n        Color: Vec3f::new(0.0, 0.0, 0.0),\r\n    };\r\n    //Firstly, read the LigthType\r\n    reader.read_line(buf);\r\n    let lightType: &str = buf.trim().clone();\r\n    let mut key = \"\";\r\n    let mut radius = \"\";\r\n    let mut period = 0;\r\n    if lightType == \"o\" || lightType == \"l\" {\r\n        let mut infoIndex = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        radius = split_info.next().unwrap().parse().unwrap();\r\n        period = split_info.next().unwrap().parse().unwrap();\r\n    }\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 2 {\r\n        //Then, read the position and Color Info\r\n        split_info = buf.split(\" \");\r\n        let mut fieldInfo = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        if infoIndex == 1 {\r\n            light.position = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        } else {\r\n            light.Color = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        }\r\n        infoIndex += 1\r\n    }\r\n    //Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n    lights.push(light);\r\n}", "id": 67, "concepts": ["string parsing", "text file parsing", "nested structure parsing", "variable initialization", "list comprehension with multiple elements", "conditional branching"], "instruction": "Implement a Rust function to parse a text file and construct a nested structure. The parent elements are of the same type, and the children elements for each parent are of the same type. The top-level parent element in the nested structure is the first line of the file. The file should be parsed into a nested structure according to the following rules:\n\n- the parent elements are separated by commas\n- the children elements of a parent are separated by whitespace\n- the child elements for each parent are of the same type, whose type is determined by the child elements of the parent\n\nThe function should return the root element of the nested structure, which should be of the type determined by the children elements of the top-level parent element (as determined by the type of the top-level parent element)."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call wrapper, C pointer manipulation, structure deconstruction, function pointer deconstruction for struct arguments\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_stack_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetStackPointer {\n        request: (target, ptr),\n    });\n}", "id": 68, "concepts": ["system call wrapper", "C pointer manipulation", "structure deconstruction", "function pointer deconstruction for struct arguments"], "instruction": "Write a Rust class called `SystemCommand` that encapsulates a system command that can be executed via a wrapper function. The class should provide a method called `execute(self)` that executes the wrapped system command. The class should also implement a constructor method that accepts a file path containing the system command as an argument. The file should have exactly one line of text.\n\nThe class should handle erroneous input gracefully, such as invalid file paths or invalid command execution errors. Additionally, implement the `__str__` method to return a formatted string showing the current value of the command and the file path that contains the command."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: fuzzing, custom directory, fuzz target name, using a custom directory\n\n### Task", "fingerprint": null, "seed": "fn run_diagnostic_contains_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\"run_with_crash\", None);\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"yes_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    run_with_crash::fail_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    let run = format!(\n        \"cargo fuzz run --fuzz-dir {} yes_crash custom_dir/artifacts/yes_crash\",\n        &fuzz_dir\n    );\n\n    let tmin = format!(\n        \"cargo fuzz tmin --fuzz-dir {} yes_crash custom_dir/artifacts/yes_crash\",\n        &fuzz_dir\n    );\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"yes_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(predicates::str::contains(run).and(predicate::str::contains(tmin)))\n        .failure();\n}", "id": 69, "concepts": ["fuzzing", "custom directory", "fuzz target name", "using a custom directory"], "instruction": "Write a Rust program that fuzzes the command-line interface of the program for a Linux distribution, using a custom directory for fuzz target files. Use fuzz targets with file names that contain characters not allowed for command-line interface parameters."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: loading program from a file, unwrapping of Optional values, vector initialization\n\n### Task", "fingerprint": null, "seed": "pub fn test_op_rvc_srai_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_srai_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srai_crash_32\".into()]);\n    assert!(result.is_ok());\n}", "id": 70, "concepts": ["loading program from a file", "unwrapping of Optional values", "vector initialization"], "instruction": "Write a Rust program that reads an input file and computes the total number of lines for each word in the file. The program should support reading from a file specified by the user. The program should handle any errors that might occur while reading the file gracefully. Additionally, it should handle cases where the user does not specify a file to be read."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: macros for declaring constants, null values in structure definitions, opaque pointers, heap-allocated memory allocation\n\n### Task", "fingerprint": null, "seed": "fn alloc_svc_def() -> *const ble_gatt_svc_def {\n    leaky_box!(\n        ble_gatt_svc_def {\n            type_: BLE_GATT_SVC_TYPE_PRIMARY as u8,\n            uuid: ble_uuid16_declare!(GATT_HRS_UUID),\n            includes: ptr::null_mut(),\n            characteristics: leaky_box!(\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_HRS_MEASUREMENT_UUID),\n                    access_cb: Some(gatt_svr_chr_access_heart_rate),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_NOTIFY as u16,\n                    min_key_size: 0,\n                    val_handle: (unsafe { &mut HRS_HRM_HANDLE as *mut u16 }),\n                },\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_HRS_BODY_SENSOR_LOC_UUID),\n                    access_cb: Some(gatt_svr_chr_access_heart_rate),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_READ as u16,\n                    min_key_size: 0,\n                    val_handle: ptr::null_mut(),\n                },\n                null_ble_gatt_chr_def()\n            )\n        },\n        ble_gatt_svc_def {\n            type_: BLE_GATT_SVC_TYPE_PRIMARY as u8,\n            uuid: ble_uuid16_declare!(GATT_DEVICE_INFO_UUID),\n            includes: ptr::null_mut(),\n            characteristics: leaky_box!(\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_MANUFACTURER_NAME_UUID),\n                    access_cb: Some(gatt_svr_chr_access_device_info),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_READ as u16,\n                    min_key_size: 0,\n                    val_handle: (ptr::null_mut()),\n                },\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_MODEL_NUMBER_UUID),\n                    access_cb: Some(gatt_svr_chr_access_device_info),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_READ as u16,\n                    min_key_size: 0,\n                    val_handle: (ptr::null_mut()),\n                },\n                null_ble_gatt_chr_def()\n            )\n        },\n        null_ble_gatt_svc_def()\n    )\n}", "id": 71, "concepts": ["macros for declaring constants", "null values in structure definitions", "opaque pointers", "heap-allocated memory allocation"], "instruction": "Create a Rust class called `Randomized` that implements the `rand::Rng` trait. The class should contain an internal state that maintains a list of all the randomly generated numbers. The class should support generating random numbers of various data types, including integers in the specified range, floating-point numbers, and string values.\n\nThe class should implement the following methods:\n- `get_int(self, low: i32, high: i32) -> i32`: Returns a random integer number within the specified range, inclusive of both bounds. If the range is empty, the method should return `None`.\n- `get_float(self, low: f32, high: f32) -> f32`: Returns a random floating-point number within the specified range, inclusive of both bounds. If the range is empty, the method should return `None`.\n- `get_str(self) -> String`: Returns a random string from the list. If the list is empty, the method should return `None`.\n- `reset(self) -> ()`: Resets the internal state of the class to an empty list.\n\nThe class should be able to work with values of any type that implements `Rand`, such as `u32`, `f32`, and `String`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: error handling, trait bounds, return values from functions, using a higher-order for loop\n\n### Task", "fingerprint": null, "seed": "pub fn test_invalid_file_offset64() {\n    let buffer = fs::read(\"tests/programs/invalid_file_offset64\")\n        .unwrap()\n        .into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"invalid_file_offset64\".into()]);\n    assert_eq!(result.err(), Some(Error::ElfSegmentAddrOrSizeError));\n}", "id": 72, "concepts": ["error handling", "trait bounds", "return values from functions", "using a higher-order for loop"], "instruction": "Write a Rust function called `count_consecutive_repetitions` that accepts a string `s` as an input and returns the maximum number of consecutive repetitions of any character in the string. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(count_consecutive_repetitions(\"aabbbccc\"), 3);\nassert_eq!(count_consecutive_repetitions(\"abcccc\"), 1);\nassert_eq!(count_consecutive_repetitions(\"aaaa\"), 4);\nassert_eq!(count_consecutive_repetitions(\"\"), 0);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string manipulation, thread creation through closures, asynchronous thread joining, environment variable handling for conditional execution\n\n### Task", "fingerprint": null, "seed": "fn main() {\n  let mut prod_env = \"\".to_string();\n\n  let ws_server_thread = thread::Builder::new().name(\"ws_server\".to_string()).spawn(move || {\n      println!(\"Starting websocket server..\");\n      listen(\"127.0.0.1:3012\", |out| { Server { out: out } }).unwrap()\n  }).unwrap();\n\n  thread::sleep(time::Duration::from_millis(1000));\n  match env::var(\"PROD_ENV\".to_string()) {\n      Ok(val) => prod_env = val,\n      Err(e) => println!(\"Operating in dev mode due to: {}\", e),\n  }\n\n  if prod_env != \"\" {\n    let app_router_thread = thread::Builder::new().name(\"app_router\".to_string()).spawn(move || {\n        let mut app_router = Nickel::new();\n        println!(\"Starting app router..\");\n        app_router.mount(\"/controller/\", StaticFilesHandler::new(\"app/controller/\"));\n        app_router.mount(\"/display/\", StaticFilesHandler::new(\"app/display/\"));\n        app_router.listen(\"127.0.0.1:6767\").unwrap();\n    }).unwrap();\n    let _ = app_router_thread.join();\n  }\n\n  let _ = ws_server_thread.join();\n  println!(\"Server closing down..\");\n}", "id": 73, "concepts": ["string manipulation", "thread creation through closures", "asynchronous thread joining", "environment variable handling for conditional execution"], "instruction": "Write a Rust function that takes an arbitrary number of strings and combines them into a single string, where each string is preceded by a separator. The function should use a thread to perform the operation asynchronously while returning the string to the main thread. The function should also return the time it took to perform the operation. The function should have a default separator of a comma (,) and should use a default timeout of 10 seconds to complete the operation.\n\nInclude a helper function that accepts a string and a separator and returns a string that combines the two. Use the helper function in the main function to pass the input strings and the separator to the helper function.\n\nYou can use the time crate to measure the elapsed time. Use the `join()` method to wait for a thread to finish. Ensure that the function is resilient to cases where the user does not provide any input and exits immediately."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: async/await, async function, await, asynchronous IO\n\n### Task", "fingerprint": null, "seed": "async fn retrieve_pairs() {\n    let exchange = init().await;\n    let pairs = exchange.refresh_market_info().await.unwrap();\n    println!(\"{:?}\", pairs);\n}", "id": 74, "concepts": ["async/await", "async function", "await", "asynchronous IO"], "instruction": "Write a Rust class called `AsyncFile` that implements asynchronous file read/write for a Linux system call. The class should support five methods:\n\n- `async fn read_async(self, nbytes: usize)` that reads `nbytes` bytes from file asynchronously and returns a future result.\n- `async fn write_async(self, data: &[u8])` that writes a given byte array to the file asynchronously and returns a future result.\n- `async fn seek_async(self, offset: i64, whence: SeekFrom)` that seeks to a given position within the file asynchronously and returns a future result.\n- `async fn close_async(self)` that closes the file asynchronously and returns a future result.\n- `async fn fsync_async(self)` that flushes the file asynchronously and returns a future result.\n\nThe class should support async/await syntax, ensure that each function returns a result, and handle errors."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: command-line argument parsing, pattern matching, asynchronous IO\n\n### Task", "fingerprint": null, "seed": "async fn main() -> Result<!, String> {\n    // Begin by parsing the arguments. We are either a server or a client, and\n    // we need an address and potentially a sleep duration.\n    let args: Vec<_> = env::args().collect();\n\n    match &*args {\n        [_, mode, url]             if mode == \"server\" => server(url).await?,\n        [_, mode, url]             if mode == \"client\" => client(url, tokio::io::stdin()).await?,\n        [_, mode, url, input_file] if mode == \"client\" => {\n            match tokio::fs::File::open(input_file).await {\n                Ok(file) => client(url, file).await?,\n                Err(err) => {\n                    eprintln!(\"Failed to open input_file: \\\"{}\\\", error: {}\", input_file, err);\n                    process::exit(2);\n                }\n            }\n        }\n        _ => {\n            eprintln!(\"Usage:\\n{0} server <url>\\n  or\\n{0} client <url> [input_file]\", args[0]);\n            process::exit(1);\n        }\n    }\n}", "id": 75, "concepts": ["command-line argument parsing", "pattern matching", "asynchronous IO"], "instruction": "Write a Rust class called `AsyncCommand` that implements the `execute` method for running asynchronous tasks. The class should have a constructor that takes a command-line argument as input. The constructor should parse the command for arguments using a regular expression pattern. The `execute` method should launch a child process using the parsed arguments.\n\nThe class should also have a method `run` that runs an asynchronous loop that monitors the exit status of the child process and handles termination and error conditions appropriately.\n\nFinally, the class should have a method called `stop` that terminates the child process.\n\nImplement the `execute` method so that it uses an asynchronous loop that waits for the child process to terminate and reports the exit status to the user."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async/await, HTTP server, database connection pool, environment variables, middleware, web framework configuration\n\n### Task", "fingerprint": null, "seed": "async fn main() -> std::io::Result<()> {\n    dotenv().ok();\n    let app_data = AppData {\n        conn_pool: database::create_pool(),\n    };\n\n    let mut listenfd = ListenFd::from_env();\n    let mut server = HttpServer::new(move || {\n        App::new()\n            .data(app_data.clone())\n            .service(index)\n            .configure(routes::config)\n            .default_service(web::route().to(fallback_route))\n            .wrap(middlewares::auth_middleware::Logging)\n            .wrap(Cors::new().finish())\n            .wrap(IdentityService::new(\n                CookieIdentityPolicy::new(\n                    env::var(\"COOKIE_SECRET\")\n                        .unwrap_or(\"DEFAULT_SECRET\".to_string())\n                        .as_bytes(),\n                )\n                .name(\"auth\")\n                .path(\"/\")\n                .domain(env::var(\"APP_DOMAIN\").unwrap_or(\"localhost\".to_string()))\n                .max_age(chrono::Duration::days(1).num_seconds())\n                .secure(false),\n            ))\n    });\n\n    server = if let Some(l) = listenfd.take_tcp_listener(0).unwrap() {\n        server.listen(l)?\n    } else {\n        server.bind(\"localhost:8000\")?\n    };\n\n    server.run().await\n}", "id": 76, "concepts": ["async/await", "HTTP server", "database connection pool", "environment variables", "middleware", "web framework configuration"], "instruction": "Design a Rust program that implements an HTTP server for a simple CRUD API with the following endpoints:\n- `/users` - returns a list of all known users\n- `/users/{id}` - returns the user with the specified ID\n- `/users/{id}` - creates a new user with the specified ID\n- `/users/{id}` - updates the user with the specified ID\n\nThe server should provide a configurable web framework that supports a set of middleware functions to implement custom behavior, such as authentication, logging, rate limiting, or caching."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: backtracking algorithm, exhaustive search\n\n### Task", "fingerprint": null, "seed": "pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\n    Board::new(n as usize).solve()\n}", "id": 78, "concepts": ["backtracking algorithm", "exhaustive search"], "instruction": "Design a Rust class that implements a backtracking algorithm for solving the n-queens problem. The class should provide a method `solve_queens(self, n)` that takes an integer `n` and returns a list of n-element lists representing the successful solutions to the problem. Each element of the returned list should be an n-element list, where each element represents a single row of the chess board and the column number represents the corresponding board position. The method `solve_queens` should return `None` if no solution exists, and `None` if `n` is invalid.\n\nThe solution of the backtracking algorithm should follow the following steps:\n1. Initialize a list `queens` of size `n` with each element set to `None`.\n2. Start a backtracking loop with `row` set to `0`.\n3. While `row` is less than `n`:\n  * For each element `col` in `range(n)`:\n    * Set `queens[row] = col`.\n    * If `validate_queens(queens)`:\n      * If `row == n - 1`:\n        * Return `queens` as the solution.\n      * Else:\n        * Go to step `2` with `row + 1`.\n    * Else:\n      * Go to step `4` with `row - 1`.\n    * Set `queens[row] = None`.\n  * Go to step `4` with `row - 1`.\n4. Return `None` as the end condition.\n\nThe method `validate_queens(queens)` should check whether the current state of the queens list `queens` satisfies the constraints of the n-queens problem. It should return `True` if the state of the list meets the criteria and `False` otherwise.\n\nThe method `solve_queens(self, n)` should utilize the backtracking algorithm to find all possible solutions to the n-queens problem. It should return `None` if either the input `n` is invalid or no valid solution exists, and it should return a list of lists representing the solutions otherwise."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: default exception handler, panic with error message\n\n### Task", "fingerprint": null, "seed": "fn default_handler(irqn: i16) {\n    panic!(\"Unhandled exception (IRQn = {})\", irqn);\n}", "id": 79, "concepts": ["default exception handler", "panic with error message"], "instruction": "Design a Rust class `BadStudent` that inherits from the `std::error::Error` trait. The class should maintain a list of result grades for each assignment. The class should provide methods for retrieving and updating the list of grades, with default values of `-1` for any missing grades. The class should also contain a method that computes the student's current average grade, taking into account all of the final grades and penalties.\n\nIf the student's average is greater than or equal to 90, the method should return `StudentResult::Pass`. If the average is less than 90, the method should return `StudentResult::Fail`. If the average is less than 0 or greater than 100, the method should return `StudentResult::Invalid`. If the method encounters any other errors when computing the average grade, the method should return `StudentResult::Error` and print a message to the user."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call abstraction, function overloading, channel message, conversion to `Cap`\n\n### Task", "fingerprint": null, "seed": "pub fn channel_put_cap(target: CAddr, value: CAddr) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Cap(Some(value)))\n    });\n}", "id": 80, "concepts": ["system call abstraction", "function overloading", "channel message", "conversion to `Cap`"], "instruction": "Design a Rust function `send_message_to_terminal(message)` that sends a given message to the system's terminal window. The result of the function call should be a `Cap` struct that represents the message as a handle that can be passed to other functions. Ensure the function returns a `Result` that is combined with the `Cap` struct, rather than a `Cap` struct alone, to provide a more general and extensible implementation. The function should include documentation for the message parameter and the return value."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file reading, error handling, error type checking, test framework\n\n### Task", "fingerprint": null, "seed": "pub fn test_wxorx_crash_64() {\n    let buffer = fs::read(\"tests/programs/wxorx_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"wxorx_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}", "id": 81, "concepts": ["file reading", "error handling", "error type checking", "test framework"], "instruction": "Design a Rust program that reads a file named \"words.txt\" containing words separated by newlines and returns the word with the most occurrences.\n\nFor example, given the following content of \"words.txt\":\n\n```\nhello\nworld\nhello\n```\n\nThe program should return `hello` because it appears most often in the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: Vector initialization, functional programming techniques in a single line, pattern matching and type conversion\n\n### Task", "fingerprint": null, "seed": "fn de_board(raw: Vec<usize>, t: isize, l: i32, width: u8, height: u8) -> game::Board {\n    let mut res = game::Board::new(t, l, width, height);\n    res.pieces = raw\n        .into_iter()\n        .map(|x| game::Piece::from(x))\n        .collect();\n    res\n}", "id": 82, "concepts": ["Vector initialization", "functional programming techniques in a single line", "pattern matching and type conversion"], "instruction": "Design a Rust class called `Student` that contains a list of student names, a dictionary of student scores, and a method `high_score` that returns the name of the student with the highest score. However, the implementation must be completed in a single line of code using functional programming techniques.\n\n```rust\nlet student_names = vec![String::from(\"John\"), String::from(\"Mary\"), String::from(\"Bob\")];\nlet scores = vec![50, 80, 90];\nlet student = Student::new(&student_names, &scores);\nassert_eq!(student.high_score(), String::from(\"Mary\"));\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: string manipulation, parsing, string slices, unrolling a loop, iteration with indices\n\n### Task", "fingerprint": null, "seed": "pub fn day09_1(s : String) -> u32{\n    let mut running_total = 0;\n    let mut scope = 0;\n\n    let mut in_garbage = false;\n    let mut prev_cancel = false;\n    for c in s.chars(){\n        if in_garbage {\n            if c == '>' && !prev_cancel {\n                in_garbage = false;\n                prev_cancel = false;\n            }\n            else if c == '!' && !prev_cancel {\n                prev_cancel = true;\n            }\n            else {\n                prev_cancel = false;\n            }\n        }\n        else{\n            if c == '{' {\n                scope+=1;\n                running_total+=scope;\n            }\n            else if c == '}' {\n                scope -=1;\n            }\n            else if c == '<' {\n                in_garbage = true;\n            }\n        }\n    }\n    running_total\n}", "id": 83, "concepts": ["string manipulation", "parsing", "string slices", "unrolling a loop", "iteration with indices"], "instruction": "Design a Rust class called `Student` that contains a list of student names stored as a string slice. Write methods for the following functions:\n\n- `get_students_greater_than_limit(limit)`, which returns a list of students with grades greater than `limit`\n- `get_name_of_student_with_highest_grade()`, which returns a string containing the name of the student with the highest grade\n- `get_number_of_students_with_grade_greater_than_limit(limit)`, which returns the total number of students with grades greater than `limit`"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string manipulation, string interpolation, string parsing, string concatenation, string formatting, string escaping, string concatenation\n\n### Task", "fingerprint": null, "seed": "fn loadResFromMesh(model: &mut Model, meshFilePath: &str) {}", "id": 85, "concepts": ["string manipulation", "string interpolation", "string parsing", "string concatenation", "string formatting", "string escaping", "string concatenation"], "instruction": "Write a Rust function that takes a string as a parameter and returns a new string with the first and last characters of the input string swapped. Do not use library functions such as `reverse` or `swap`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: trait implementation, constructor pattern, service instantiation, function return\n\n### Task", "fingerprint": null, "seed": "fn app() -> App<\n    impl ServiceFactory<\n        ServiceRequest,\n        Response = ServiceResponse<impl MessageBody>,\n        Config = (),\n        InitError = (),\n        Error = Error,\n    >,\n> {\n    App::new()\n}", "id": 86, "concepts": ["trait implementation", "constructor pattern", "service instantiation", "function return"], "instruction": "Create a Rust class that implements the `Countable` trait. This trait has a single function, `count`, that takes a string as an argument and returns the number of uppercase characters in the string.\n\nThe `Countable` trait has a blanket implementation of the `count` method for all types that implement the `ToString` trait. The `count` method converts the type to a string using the `ToString` trait implementation, and then searches for uppercase characters in the string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call interface, explicit type conversion\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_top_page_table(target: CAddr, table: CAddr) {\n    system_call(SystemCall::TaskSetTopPageTable {\n        request: (target, table),\n    });\n}", "id": 87, "concepts": ["system call interface", "explicit type conversion"], "instruction": "Develop a Rust class `UnixTime` that converts a Unix timestamp (in seconds) into a human-readable string of the form \"YYYY-MM-DD hh:mm:ss\". The class should support any timestamp within the range of a single system call.\n\nYou are free to choose the format of the output string.\n\nImplement the `__str__` method to return a formatted string showing the current value of the timestamp.\n\nFor example:\n```rust\nlet timestamp = UnixTime::from_timestamp(1627526400);\nassert_eq!(timestamp.to_string(), \"2021-07-26 00:00:00\")\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: fuzzing, crash reproduction, fuzzing and crash reproduction on the Rust fuzzing platform, string and regex matching\n\n### Task", "fingerprint": null, "seed": "fn run_no_crash() {\n    let project = project(\"run_no_crash\")\n        .with_fuzz()\n        .fuzz_target(\n            \"no_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    #[cfg(fuzzing_repro)]\n                    eprintln!(\"Reproducing a crash\");\n\n                    run_no_crash::pass_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"no_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Done 1000 runs\")\n                .and(predicate::str::contains(\"Reproducing a crash\").not()),\n        )\n        .success();\n}", "id": 88, "concepts": ["fuzzing", "crash reproduction", "fuzzing and crash reproduction on the Rust fuzzing platform", "string and regex matching"], "instruction": "Create a Rust class that simulates a fictional operating system and a fuzzing platform, including a string matching function and a regex matching function. The first string matching function should be implemented with a fuzzer, and the second string matching function should be implemented with a debugger/crash reproduction. Use the Rust fuzzing and crash reproduction platform to automatically test the string matching functionality."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: parsing git commit logs, author mapping, unfolding nested data structures\n\n### Task", "fingerprint": null, "seed": "fn generate_thanks() -> Result<BTreeMap<VersionTag, AuthorMap>, Box<dyn std::error::Error>> {\n    let path = update_repo(\"https://github.com/rust-lang/rust.git\")?;\n    let repo = git2::Repository::open(&path)?;\n    let mailmap = mailmap_from_repo(&repo)?;\n    let reviewers = Reviewers::new()?;\n\n    let mut versions = get_versions(&repo)?;\n    let last_full_stable = versions\n        .iter()\n        .rfind(|v| v.raw_tag.ends_with(\".0\"))\n        .unwrap()\n        .version\n        .clone();\n\n    versions.push(VersionTag {\n        name: String::from(\"Beta\"),\n        version: {\n            let mut last = last_full_stable.clone();\n            last.minor += 1;\n            last\n        },\n        raw_tag: String::from(\"beta\"),\n        commit: repo\n            .revparse_single(\"beta\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n    versions.push(VersionTag {\n        name: String::from(\"Master\"),\n        version: {\n            // master is plus 1 minor versions off of beta, which we just pushed\n            let mut last = last_full_stable.clone();\n            last.minor += 2;\n            last\n        },\n        raw_tag: String::from(\"master\"),\n        commit: repo\n            .revparse_single(\"master\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n\n    let mut version_map = BTreeMap::new();\n\n    let mut cache = HashMap::new();\n\n    for (idx, version) in versions.iter().enumerate() {\n        let previous = if let Some(v) = idx.checked_sub(1).map(|idx| &versions[idx]) {\n            v\n        } else {\n            let author_map = build_author_map(&repo, &reviewers, &mailmap, \"\", &version.raw_tag)?;\n            version_map.insert(version.clone(), author_map);\n            continue;\n        };\n\n        eprintln!(\"Processing {:?} to {:?}\", previous, version);\n\n        cache.insert(\n            version,\n            up_to_release(&repo, &reviewers, &mailmap, &version)?,\n        );\n        let previous = match cache.remove(&previous) {\n            Some(v) => v,\n            None => up_to_release(&repo, &reviewers, &mailmap, &previous)?,\n        };\n        let current = cache.get(&version).unwrap();\n\n        // Remove commits reachable from the previous release.\n        let only_current = current.difference(&previous);\n        version_map.insert(version.clone(), only_current);\n    }\n\n    Ok(version_map)\n}", "id": 89, "concepts": ["parsing git commit logs", "author mapping", "unfolding nested data structures"], "instruction": "Develop a Rust program that extracts the information from a git commit log and displays the author name, email address, and the timestamp of each commit. The program should parse the log file and extract the relevant information as a nested data structure."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string concatenation, string formatting, reading user input, printing to standard out, flushing standard out, string trimming\n\n### Task", "fingerprint": null, "seed": "fn input(user_message: &str) -> io::Result<String> {\r\n    use std::io::Write;\r\n\r\n    print!(\"{}\", user_message);\r\n\r\n    io::stdout().flush()?;\r\n\r\n    let mut buffer: String = String::new();\r\n    io::stdin().read_line(&mut buffer)?;\r\n\r\n    Ok(buffer.trim_right().to_owned())\r\n}", "id": 90, "concepts": ["string concatenation", "string formatting", "reading user input", "printing to standard out", "flushing standard out", "string trimming"], "instruction": "Create a Rust program that prompts the user to enter a sentence and prints the length of the longest string in the sentence.\n\nThe program should use string concatenation to join the three string literals `\", \", \"` and `\"` to form the `sentence_prompt` message. Similarly, the program should use string formatting to format the `sentence_input_prompt` message and the `sentence_input_error` message. The last string literal should be used to format the `sentence_output_prompt` message.\n\nThe program should use `std::io::stdin` to read the sentence from user input and store it in the `sentence` string variable. The program should check that the input is not empty before proceeding, and print an error message if the input is empty.\n\nThe program should use `std::io::stdout` to print the length of the longest string in the sentence to the standard output and flush the standard output buffer to ensure all output is printed before the program exits. The program should use string trimming to remove leading and trailing whitespace characters from the sentence and check that the input is not empty before proceeding.\n\nThe solution should include error handling to manage invalid inputs such as empty strings, non-string inputs, or inputs that are not user-provided sentences."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with iterators, filtering with closures\n\n### Task", "fingerprint": null, "seed": "pub fn docker_metric_from_stats(first: &InstantDockerContainerMetric, second: &InstantDockerContainerMetric) -> DockerContainerMetric {\n    let first = first.clone();\n    let second = second.clone();\n    let time_diff = second.timestamp - first.timestamp;\n\n    let first_iter = first.stat.into_iter();\n\n    let stat: Vec<DockerContainerMetricEntry> = second.stat.into_iter()\n        .filter_map(|v| first_iter.clone()\n            .find(|item| item.name == v.name)\n            .map(|item| (item, v))\n        )\n        .filter(|two_entries| two_entries.1.cpu_usage > two_entries.0.cpu_usage)\n        .map(|two_entries| docker_metric_entry_from_two_stats(time_diff, two_entries.0, two_entries.1))\n        .collect();\n\n    DockerContainerMetric { stat, timestamp: second.timestamp }\n}", "id": 91, "concepts": ["iteration with iterators", "filtering with closures"], "instruction": "Develop a Rust function that takes an iterator and a predicate, and returns a new iterator that yields only elements that satisfy the predicate.\n\nFor example, given the input iterator `[1, 2, 3, 4, 5]`, the function should return an iterator that yields only `[2, 4]`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: iteration with iterators, tuple unpacking, map operation on a dictionary, sorting based on multiple fields\n\n### Task", "fingerprint": null, "seed": "fn most_least_common(btm: BTreeMap<char, i32>) -> (char, char) {\n    let mut count_vec: Vec<_> = btm.into_iter().collect();\n    // Reverse sort the vector of pairs by \"value\" (sorted by \"key\" in case of tie)\n    count_vec.sort_by(|a, b| b.1.cmp(&a.1));\n    let m = count_vec.first().map(|&(k, _)| k).unwrap();\n    let l = count_vec.last().map(|&(k, _)| k).unwrap();\n    (m, l)\n}", "id": 92, "concepts": ["iteration with iterators", "tuple unpacking", "map operation on a dictionary", "sorting based on multiple fields"], "instruction": "Develop a Rust function `merge_sort` that takes an iterable and returns a new list containing the sorted sequence. Implement the algorithm based on the following pseudo-code:\n```python\ndef merge_sort(lst):\n\tif len(lst) <= 1:\n\t\treturn lst\n\tmid = len(lst) // 2\n\tleft = merge_sort(lst[:mid])\n\tright = merge_sort(lst[mid:])\n\treturn merge(left, right)\n\ndef merge(left, right):\n\tresult = []\n\ti, j = 0, 0\n\twhile i < len(left) and j < len(right):\n\t\tif left[i] <= right[j]:\n\t\t\tresult.append(left[i])\n\t\t\ti += 1\n\t\telse:\n\t\t\tresult.append(right[j])\n\t\t\tj += 1\n\tresult += left[i:]\n\tresult += right[j:]\n\treturn result\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: memory access from RISCV binary, memory layout, memory layout manipulation, memory loading with Rust's unsafe API\n\n### Task", "fingerprint": null, "seed": "pub fn test_rvc_pageend() {\n    // The last instruction of a executable memory page is an RVC instruction.\n    let buffer = fs::read(\"tests/programs/rvc_pageend\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    machine\n        .load_program(&buffer, &vec![\"rvc_end\".into()])\n        .unwrap();\n\n    let anchor_pc: u64 = 69630;\n    // Ensure that anchor_pc is in the end of the page\n    assert_eq!(anchor_pc as usize % RISCV_PAGESIZE, RISCV_PAGESIZE - 2);\n    let memory = machine.memory_mut();\n    // Ensure that the data segment is located at anchor_pc + 2\n    let data0 = memory.load16(&(anchor_pc + 2)).unwrap().to_u32();\n    assert_eq!(data0, 4);\n    let data1 = memory.load16(&(anchor_pc + 6)).unwrap().to_u32();\n    assert_eq!(data1, 2);\n    // Ensure that the anchor instruction is \"c.jr a0\"\n    let anchor_inst = memory.load16(&anchor_pc).unwrap().to_u16();\n    assert_eq!(anchor_inst, 0x8502);\n\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}", "id": 93, "concepts": ["memory access from RISCV binary", "memory layout", "memory layout manipulation", "memory loading with Rust's unsafe API"], "instruction": "Using the provided RISCV binary `mem_decode`, decode and print to the console the memory layout and all the raw data stored within the binary."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: cargo subcommand invocation, Command struct initialization\n\n### Task", "fingerprint": null, "seed": "fn cargo_fuzz() -> Command {\n    Command::cargo_bin(\"cargo-fuzz\").unwrap()\n}", "id": 94, "concepts": ["cargo subcommand invocation", "Command struct initialization"], "instruction": "Create a Rust function `cargo_subcommand_runner` that takes a list of arguments as a vector of strings and executes a cargo subcommand. The function should return a String containing the output of the executed subcommand. The function should use the `Command` struct from the `std::process` module to create a new process and execute the specified subcommand.\n\nThe function should accept an optional first argument as the name of the cargo subcommand, and should use a default value of `build` if no argument is specified. It should also use a default value for the `args` argument set to an empty vector if no additional arguments are provided.\n\nThe function should validate the input by checking the length of the argument vector and ensuring that the first argument is a valid cargo subcommand name. It should return an error message if the first argument is invalid.\n\nThe function should handle any errors that might occur during execution of the subcommand by catching the `io::Error` and `io::ErrorKind` errors."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: calling system calls from Rust code, system call argument type conversions\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_buffer(target: CAddr, buffer: CAddr) {\n    system_call(SystemCall::TaskSetBuffer {\n        request: (target, buffer),\n    });\n}", "id": 95, "concepts": ["calling system calls from Rust code", "system call argument type conversions"], "instruction": "Develop a Rust function `call_syscall` that calls a system call from Rust code. The function should accept a system call identifier (syscall_id) and a list of arguments (args) for the syscall. The function should handle system call argument conversion and error handling appropriately."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: iteration with conditional execution, hash map operations\n\n### Task", "fingerprint": null, "seed": "fn process_instructions(instructions: &Vec<Instruction>) -> (HashMap<&str, i32>, i32) {\n    let mut registers: HashMap<&str, i32> = HashMap::new();\n    let mut max = 0;\n\n    for instruction in instructions {\n        let current = *registers.entry(&instruction.condition.register).or_insert(0);\n\n        let condition_satisfied = match instruction.condition.operator {\n            Operator::LessThan           => current <  instruction.condition.value,\n            Operator::LessThanOrEqual    => current <= instruction.condition.value,\n            Operator::GreaterThan        => current >  instruction.condition.value,\n            Operator::GreaterThanOrEqual => current >= instruction.condition.value,\n            Operator::Equal              => current == instruction.condition.value,\n            Operator::NotEqual           => current != instruction.condition.value,\n        };\n\n        if !condition_satisfied {\n            continue;\n        }\n\n        let delta = match instruction.increase {\n            true  => instruction.value,\n            false => -1 * instruction.value,\n        };\n\n        let entry = registers.entry(&instruction.register).or_insert(0);\n        *entry += delta;\n        let new_value = *entry;\n\n        if new_value > max {\n            max = new_value;\n        }\n    }\n\n    (registers, max)\n}", "id": 96, "concepts": ["iteration with conditional execution", "hash map operations"], "instruction": "Create a Rust function `find_duplicates` that takes a list of strings as an argument. The function should return a list of the duplicate strings. A duplicate is a string that appears more than once in the input, and the duplicate should appear exactly once in the output. For example, `['a', 'b', 'c', 'c', 'd']` should return `['c', 'c']` since `'c'` appears twice in the input, but only once in the output."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: iteration with a while loop, nested loops\n\n### Task", "fingerprint": null, "seed": "fn broker(table: &mut Table, ntransfers: u32) {\n\n  let mut rng = thread_rng();\n  let mut ract = Range::new(0, 100);\n  let mut ramt = Range::new(0, 1000);\n  let mut nstale = 0;\n\n  for _ in 0..ntransfers {\n    let a1 = ract.sample(&mut rng);\n    let mut a2 = ract.sample(&mut rng);\n    while a2 == a1 {\n      a2 = ract.sample(&mut rng);\n    }\n    let n = ramt.sample(&mut rng);\n\n    let rt = table.time();\n    let mut vs = [Value::default(); 2];\n    table.read(rt, &[a1, a2], &mut vs);\n    let r1 = Row { k: a1, v: vs[0].v - n };\n    let r2 = Row { k: a2, v: vs[1].v + n };\n    match table.write(rt, &[r1, r2]) {\n      WriteResult::Stale { .. } => nstale += 1,\n      _ => ()\n    }\n  }\n  assert!(nstale < ntransfers / 2);\n}", "id": 97, "concepts": ["iteration with a while loop", "nested loops"], "instruction": "Create a Rust function that computes the product of all integers in a given array, `nums`, with the constraint that the product cannot exceed `int.MAX_VALUE`. The function should handle cases where either the array, `nums` or the product is empty.\n\nFor example, `product(nums = [1, 2, 3])` should return `6` and `product(nums = [-1, 2, 3])` should return `-6`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: pattern matching, transforming data structure, condition checking, matcher building, handling invalid input\n\n### Task", "fingerprint": null, "seed": "fn map_prefix(tok: IRCToken) -> Result<IRCToken, ~str> {\n    match tok {\n        Sequence([Unparsed(nick), Sequence([rest])]) => match rest {\n            Sequence([Sequence([rest]), Unparsed(~\"@\"), Unparsed(host)]) => match rest {\n                Sequence([Unparsed(~\"!\"), Unparsed(user)]) => Ok(PrefixT(Prefix {nick: nick, user: user, host: host})),\n                _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: host})),\n            },\n            _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: ~\"\"})),\n        },\n        _ => Err(~\"Malformed prefix\")\n    }", "id": 98, "concepts": ["pattern matching", "transforming data structure", "condition checking", "matcher building", "handling invalid input"], "instruction": "Create a Rust function that takes a comma-separated string of integers, parses it into an array of integers, and then takes a second string as a pattern to find substrings that match the pattern.\n\nThe function should take two arguments, one for the input string and the other for the pattern string. The function should return an array of substrings that match the pattern, or an empty array if no matches are found.\n\nThe pattern string consists of an optional positive integer followed by an optional space followed by a character, and it can be repeated multiple times. If a positive integer is provided, the function should return all substrings from the input string that match it exactly. If a character is provided, the function should return all substrings from the input string that start with the provided character. If no integer or character is provided, the function should return all substrings from the input string with no restrictions.\n\nThe function should handle invalid input such as patterns that contain letters or other characters that are not part of the comma-separated list or patterns that contain non-numeric characters.\n\nThe function should be able to handle patterns that include multiple positive integers and characters. For example, given the following input string \"1,2,3,4,5\" and the pattern \"1, 2, 5\", the function should return an array of substrings \"1\" and \"2 5\". It should also handle patterns that contain only one integer and one character, such as \"1, 2\". If the function encounters a match, it should return the substring as a string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: System call abstraction, calling convention, unsafe code, type casting\n\n### Task", "fingerprint": null, "seed": "fn system_call_put_payload<T: Any>(message: SystemCall, payload: T) -> SystemCall {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        buffer.payload_length = size_of::<T>();\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &mut *payload_addr;\n        *payload_data = payload;\n\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}", "id": 99, "concepts": ["System call abstraction", "calling convention", "unsafe code", "type casting"], "instruction": "Implement a Rust function `call_syscall` that calls a native system call (e.g., `open`, `write`) to read data from a file using a `file_descriptor`, and then returns the file content as a `String`, without using the `std::os::raw` module. The function should accept a `file_descriptor`, a `flag` for `open`, and a `content` of type `u8` to be written to the file. The function should return the content of the file as a `String`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: runtime error testing, comparison with an expected error result, memory page access error\n\n### Task", "fingerprint": null, "seed": "pub fn test_op_rvc_srli_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_srli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srli_crash_32\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 101, "concepts": ["runtime error testing", "comparison with an expected error result", "memory page access error"], "instruction": "Design a Rust program that attempts to read the value of a memory address. It should output \"Page fault\" if the corresponding page is not present in memory. However, it should also handle cases where the memory address is not valid. This program should return an error when the process terminates in an unexpected way."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: control flow and looping, evaluation of instructions, conditional branching\n\n### Task", "fingerprint": null, "seed": "fn print_fixed_acc(inss: &[Instruction], op: Operation, pc: usize) -> bool {\n    let mut fixed_inss = inss.to_vec();\n    fixed_inss[pc].op = op;\n\n    match Evaluator::new(&mut fixed_inss).eval_until_loop() {\n        (final_pc, final_acc, _) if final_pc == fixed_inss.len() => {\n            println!(\"{}\", final_acc);\n            true\n        }\n        _ => false,\n    }\n}", "id": 102, "concepts": ["control flow and looping", "evaluation of instructions", "conditional branching"], "instruction": "Develop a Rust program that evaluates a series of instructions from a file, and returns the result. The program should read instructions from a file and evaluate them based on the following syntax:\n- `let [variable] = [expression];`: declares a variable name and assigns it a value in the form of an expression\n- `[variable] = [expression]`: assigns the value of the expression to the variable\n- `print([expression]);`: prints the value of the expression to stdout\n- `if ([expression]) [statement] else [statement]`: executes the statement if the expression is true, otherwise executes the alternate statement\n\nAll variables are global and can be declared and used freely, and the value of variables can be modified. The order of evaluation of instructions is not guaranteed (e.g., `a = 3; b = 5; c = a + b` may evaluate as `c = 8`, `c = 13`, or some other number). The program should handle erroneous inputs gracefully.\n\nUse the Rust language features provided by the standard library to implement this program."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: module creation and initialization, class definition, Python calling convention\n\n### Task", "fingerprint": null, "seed": "fn soda(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<Soda>()?;\n    Ok(())\n}", "id": 103, "concepts": ["module creation and initialization", "class definition", "Python calling convention"], "instruction": "Develop a Rust function that defines a class `Line` whose instances can be created from a tuple of integers representing two coordinates (x1, y1) and (x2, y2). The class should have two methods: `length` and `slope`, which should return the line length and the slope of the line, respectively.\n\nThe class should also include a static method called `from_points` that takes two tuples of integers as arguments and creates an instance of `Line` with the specified coordinates.\n\nThe solution should follow the Python calling convention, where the class is defined within a module and initialized at the top level of the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call dispatch, comparison-assignment, option assignment\n\n### Task", "fingerprint": null, "seed": "pub fn retype_task(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeTask {\n        request: (source, target),\n    });\n}", "id": 104, "concepts": ["system call dispatch", "comparison-assignment", "option assignment"], "instruction": "Develop a Rust program that searches for a file or directory in the root directory of the system and returns the absolute path to the file or directory if found. Start with the current working directory as the root.\n\nDevelop an algorithm to determine if the provided path is relative or absolute. If it is relative, prepend the current working directory. If it is absolute, do not modify it.\n\nContinue searching up the directory tree until the file or directory is found, printing a message when it is found.\n\nThere are two main cases to consider:\n\n1. The path is relative but does not exist in the current directory.\n1. The path is absolute but does not exist in the root directory.\n\nFor both cases, the program should output the error message and exit."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: migrating the code to a different directory, calling multiple functions on the same line\n\n### Task", "fingerprint": null, "seed": "fn list_migration_directories_with_an_empty_migrations_folder_works(api: TestApi) {\n    let migrations_directory = api.create_migrations_directory();\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[]);\n}", "id": 105, "concepts": ["migrating the code to a different directory", "calling multiple functions on the same line"], "instruction": "Design a Rust program that searches for a target value in a list of integers and prints the indices it checks. This program should handle cases where the target is not present in the list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: Filtering for matching pairs, list comprehension, string processing\n\n### Task", "fingerprint": null, "seed": "fn get_common_chars(box_one: &String, box_two: &String) -> String {\n    box_one.chars()\n        .zip(box_two.chars())\n        .filter(|ch| ch.0 == ch.1)\n        .map(|ch| ch.0)\n        .collect()\n}", "id": 106, "concepts": ["Filtering for matching pairs", "list comprehension", "string processing"], "instruction": "Develop a Rust function that takes a string of parentheses characters as input and returns True if the string is balanced, and False otherwise. The string is balanced if the number of opening parentheses equals the number of closing parentheses. The order of parentheses in the input string does not matter.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(is_balanced(\"()\"), true);\nassert_eq!(is_balanced(\"()()\"), true);\nassert_eq!(is_balanced(\")()),\"), false);\nassert_eq!(is_balanced(\"())\"), false);\nassert_eq!(is_balanced(\"()(())\"), true);\nassert_eq!(is_balanced(\"((()))\"), true);\nassert_eq!(is_balanced(\"((())\"), false);\nassert_eq!(is_balanced(\")()((\"), false);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file system access, comparison with boolean values, result checking\n\n### Task", "fingerprint": null, "seed": "pub fn test_nop() {\n    let buffer = fs::read(\"tests/programs/nop\").unwrap().into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"nop\".into()]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}", "id": 107, "concepts": ["file system access", "comparison with boolean values", "result checking"], "instruction": "Design a Rust program that searches for files in a file system and returns a list of all file paths that match the specified pattern. The pattern can be composed of the following characters:\n\n- `*` represents zero or more characters, including none\n- `?` represents a single character\n- `[abc]` represents any character in the list\n- `[]` represents an empty list\n\nFor example, given the pattern `a[bc]*`, the program should return all files that start with the letter 'a' and end with the letter 'c', or 'b' or 'c', or both, followed by zero or more characters."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: type comparison, error handling, parameterized error handling\n\n### Task", "fingerprint": null, "seed": "fn build_author_map_(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    let mut walker = repo.revwalk()?;\n\n    if repo.revparse_single(to).is_err() {\n        // If a commit is not found, try fetching it.\n        git(&[\n            \"--git-dir\",\n            repo.path().to_str().unwrap(),\n            \"fetch\",\n            \"origin\",\n            to,\n        ])?;\n    }\n\n    if from == \"\" {\n        let to = repo.revparse_single(to)?.peel_to_commit()?.id();\n        walker.push(to)?;\n    } else {\n        walker.push_range(&format!(\"{}..{}\", from, to))?;\n    }\n\n    let mut author_map = AuthorMap::new();\n    for oid in walker {\n        let oid = oid?;\n        let commit = repo.find_commit(oid)?;\n\n        let mut commit_authors = Vec::new();\n        if !is_rollup_commit(&commit) {\n            // We ignore the author of rollup-merge commits, and account for\n            // that author once by counting the reviewer of all bors merges. For\n            // rollups, we consider that this is the most relevant person, which\n            // is usually the case.\n            //\n            // Otherwise, a single rollup with N PRs attributes N commits to the author of the\n            // rollup, which isn't fair.\n            commit_authors.push(Author::from_sig(commit.author()));\n        }\n        match parse_bors_reviewer(&reviewers, &repo, &commit) {\n            Ok(Some(reviewers)) => commit_authors.extend(reviewers),\n            Ok(None) => {}\n            Err(ErrorContext(msg, e)) => {\n                if e.is::<reviewers::UnknownReviewer>() {\n                    eprintln!(\"Unknown reviewer: {}\", ErrorContext(msg, e));\n                } else {\n                    return Err(ErrorContext(msg, e).into());\n                }\n            }\n        }\n        commit_authors.extend(commit_coauthors(&commit));\n        for author in commit_authors {\n            let author = mailmap.canonicalize(&author);\n            author_map.add(author, oid);\n        }\n    }\n    Ok(author_map)\n}", "id": 109, "concepts": ["type comparison", "error handling", "parameterized error handling"], "instruction": "Design a Rust function that takes an input string and checks whether the string is a valid hexadecimal number. The function should handle the following errors:\n- ValueError: if the input string is not a valid hexadecimal number\n- TypeError: if the input string contains non-hexadecimal characters"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file I/O, while loop, file reading and parsing, regex\n\n### Task", "fingerprint": null, "seed": "fn parseFromFile(file: &File) {\r\n    let mut reader = BufReader::new(file);\r\n    let mut buf = String::from(\"\");\r\n    let line_index = 0;\r\n    let mut models: Vec<Model> = Vec::new();\r\n    let mut lights: Vec<Model> = Vec::new();\r\n    while (reader.read_line(&mut buf) != 0) {\r\n        if lien_index == 0 {\r\n            if line == 'm' {\r\n                //now we read the model data\r\n                reader.read_line(&mut buf);\r\n                let model_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut model_index = 0;\r\n                while model_index < model_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n            if line == 'l' {\r\n                reader.read_line(&mut buf);\r\n                let light_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut light_index = 0;\r\n                while light_index < light_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}", "id": 110, "concepts": ["file I/O", "while loop", "file reading and parsing", "regex"], "instruction": "Develop a Rust class that implements an iterator over lines of a file. To determine if a file exists, use the `std::fs::read_to_string` function. The class should open the file in read-only mode, and should implement the `Iterator` trait.\n\nFor example, given the following file `chitty-chitty-bang-bong.txt`:\n\n```text\nChitty, chitty, bang, bang\nChitty, chitty, bang, bang\nChitty, chitty, bang, bang\n```\n\nCalling the class constructor with the file name should create an iterator over the lines, where each line is a single string with no line breaks and all whitespace is removed. Calling `next` should return the next line, which is a `Result<String, std::io::Error>`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file system access, error handling, function definition, syntax of boolean logic\n\n### Task", "fingerprint": null, "seed": "fn read_or_create_default_database() -> Result<DataBase> {\n    let default_database_paths = get_default_database_paths();\n\n    if default_database_paths.is_empty() {\n        eprintln!(\"{}\", format!(\n            \"Could not find a location for the default database. \\\n            Opening a database which cannot be saved.\",\n        ).color(\"yellow\"));\n\n        return Ok(DataBase::new());\n    }\n\n    // See if a default database can be found at any path before creating a new one.\n    for path in &default_database_paths {\n        if path.is_file() {\n            return read_database(&path).map_err(|err| GrafenCliError::from(err))\n        }\n    }\n\n    let mut default_database = DataBase::new();\n    let default_path = &default_database_paths[0];\n\n    if let Some(parent_dir) = default_path.parent() {\n        match DirBuilder::new().recursive(true).create(&parent_dir) {\n            Ok(_) => default_database.set_path(&default_path).unwrap(),\n            Err(err) => {\n                eprintln!(\"{}\", format!(\n                    \"Warning: Could not create a folder for a default database at '{}' ({}). \\\n                    Opening a database which cannot be saved.\",\n                    default_path.display(), err\n                ).color(\"yellow\"));\n            },\n        }\n    }\n\n    Ok(default_database)\n}", "id": 111, "concepts": ["file system access", "error handling", "function definition", "syntax of boolean logic"], "instruction": "Develop a Rust program that reads all text files from a directory and outputs their contents, one file per line. Each file's contents should be prepended with its file name and a tab character. Additionally, the output should be saved to a new file named `output.txt` in the same directory as the input files."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: type-checking for a sequence of tokens, custom syntax of a parser, recursive parsing of a sub-grammar\n\n### Task", "fingerprint": null, "seed": "pub fn data_type<'a>() -> Parser<'a, char, DataType> {\n    ident().convert(|v| DataType::match_data_type(&v))\n}", "id": 112, "concepts": ["type-checking for a sequence of tokens", "custom syntax of a parser", "recursive parsing of a sub-grammar"], "instruction": "Write a Rust function `check_sequence` that takes as input a sequence of tokens of a custom syntax. The function should check that the sequence adheres to a specified grammar, which is defined as a set of legal sequences of tokens. The function should return `True` if the sequence is valid, and `False` otherwise.\n\nThe function should support any number of tokens, each with a specific type (e.g., `a`, `b`, `c`, and so on). The function should also support optional tokens, which are indicated by brackets (`[]`). For example, a valid sequence would be `[b, a]`, `[b, a, b]` or `[b, a, [], []]`.\n\nThe function should also support optional repetition of a sub-grammar (e.g., `a` or `b` can appear zero or more times). In order to achieve this, the function should support a backslash (`\\`) followed by the sub-grammar name, e.g., `a\\a*`.\n\nThe function should support both alternatives (e.g., `a` or `b`), in which case the sub-grammar should appear in a list enclosed in parentheses (`(\u2026)`). For example, `(a|b)` means one of the two sub-grammars `a` or `b`.\n\nThe function should also support nested grammars, in which case the sub-grammar should be enclosed in parentheses, e.g., `a(b|c)`.\n\nThe function should consider any number of consecutive repetitions to be one repetition, e.g., `a\\a*b` should be considered equivalent to `a(a*)b`.\n\nThe function should handle invalid inputs gracefully, such as consecutive repetition without a sub-grammar, invalid syntax of the sub-grammar, or invalid syntax for the outer grammar."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over a map, map construction, map extension, map sorting\n\n### Task", "fingerprint": null, "seed": "fn run() -> Result<(), Box<dyn std::error::Error>> {\n    let by_version = generate_thanks()?;\n\n    let mut all_time = by_version.values().next().unwrap().clone();\n    for map in by_version.values().skip(1) {\n        all_time.extend(map.clone());\n    }\n\n    site::render(by_version, all_time)?;\n\n    Ok(())\n}", "id": 113, "concepts": ["iterating over a map", "map construction", "map extension", "map sorting"], "instruction": "Develop a Rust program that accepts a list of integers and computes the sum of its positive integers, skipping the negative integers."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: conversion between number types, command line argument processing, syntax of `match` expression\n\n### Task", "fingerprint": null, "seed": "fn main() {\n\tlet argv = os::args();\n\tlet size = from_str::<uint>(argv[1]).unwrap();\n//\tprintln!(\"{}\",size);\n\n\tlet align = from_str::<uint>(argv[2]).unwrap();\n//\tprintln!(\"{}\", align);\n\n\tlet aligned = align_to(size,align);\n\tprintln!(\"{} by {} = {}\", size, align, aligned);\n\n//\tprint_uint(*argv[1]);\n}", "id": 115, "concepts": ["conversion between number types", "command line argument processing", "syntax of `match` expression"], "instruction": "Develop a Rust program that accepts an argument `N` of type `i32` and prints the factorial of `N`. If the argument cannot be converted to an `i32`, the program should exit with an error."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: referential transparency, immutability, recursive data types, data structures\n\n### Task", "fingerprint": null, "seed": "pub fn number(n: i64) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::Number(n),\n        computed: true,\n    }))\n}", "id": 116, "concepts": ["referential transparency", "immutability", "recursive data types", "data structures"], "instruction": "Design a Rust function `check_recur_list` that checks if a recursive list of integers is sorted. Make the function referentially transparent so that it can be called in different contexts with a different input."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: memory allocation, error handling with exceptions\n\n### Task", "fingerprint": null, "seed": "pub unsafe fn gatt_svr_init() -> i32 {\n    // Leaks the eff out of the svc_def\n    let svcs_ptr = alloc_svc_def();\n    print_svcs(svcs_ptr);\n\n    ble_svc_gap_init();\n    ble_svc_gatt_init();\n\n    let mut rc;\n\n    rc = ble_gatts_count_cfg(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_count_cfg\\n\"));\n\n    rc = ble_gatts_add_svcs(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_add_svcs\\n\"));\n\n    return 0;\n}", "id": 118, "concepts": ["memory allocation", "error handling with exceptions"], "instruction": "Develop a Rust class `Matrix` that represents a two-dimensional matrix with a fixed number of rows and columns (size). The class should support basic matrix operations such as addition, subtraction, multiplication, matrix-vector multiplication, and transposition. The class should also support iterating over the matrix elements in row-major order.\n\nImplement the operations using NumPy. To simplify the implementation, assume that the size is fixed and the matrix is of type `float`. If the matrix size is not valid, the class should raise an exception."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: object-oriented programming, polymorphism and inheritance, dynamic dispatch\n\n### Task", "fingerprint": null, "seed": "pub fn main() {\n    let opts = TileOptions {\n        parent_x: 108,\n        parent_y: 54,\n        width: 10,\n        height: 10,\n        max_value: 10.0,\n        min_value: 0.0,\n        mean: 5.0,\n        std_dev: 2.0,\n    };\n    let t = NormalDistTile::new(opts);\n    println!(\" {:?}\", t.subtiles);\n    println!(\"{}\", t.get(0, 0));\n    println!(\"{}\", t.get(1, 0));\n    println!(\"{}\", t.get(2, 0));\n    println!(\"{}\", t.get(3, 0));\n\n    println!(\"{}\", t.get(0, 5));\n    println!(\"{}\", t.get(1, 5));\n    println!(\"{}\", t.get(2, 5));\n    println!(\"{}\", t.get(3, 5));\n\n    println!(\"{}\", t.get((t.width - 4) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 3) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 2) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 1) as u8, (t.height - 1) as u8));\n}", "id": 119, "concepts": ["object-oriented programming", "polymorphism and inheritance", "dynamic dispatch"], "instruction": "Develop a Rust class `Fraction` to represent fractions of the form `numerator/denominator`. The class should provide methods to calculate the value of the fraction, and `add`, `subtract`, `multiply`, and `divide` methods to perform simple arithmetic operations on fractions. All methods should support fractional in-place operations, such as `frac1.add(frac2)` which returns a new fraction whose value is the sum of `frac1` and `frac2`. The class should raise an error for division by zero, and an assertion error for other inputs that are not a valid fraction."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: hashmap and treemap implementation and use for testing, mutation handling for testing\n\n### Task", "fingerprint": null, "seed": "fn a_table_should_preserve_the_money_supply() {\n  let mut table = HashMapOfTreeMap::new();\n  broker(&mut table, 1000);\n  expect_money_conserved(&table);\n}", "id": 121, "concepts": ["hashmap and treemap implementation and use for testing", "mutation handling for testing"], "instruction": "Design a Rust program to generate a list of random numbers of size 100000. The program should print the list to a file in binary format, and then read the file and print the list to screen. The program should be able to handle exceptions and errors in file reading, ensure a deterministic output in terms of the random list, and optimize the program for optimal execution speed.\n\nEnsure that the file can be read and written reliably using Rust's built-in I/O library."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: match, if-let, pattern-matching, error handling\n\n### Task", "fingerprint": null, "seed": "fn\nis_invalid_column_type\n(\nerr\n:\nError\n)\n-\n>\nbool\n{\nmatches\n!\n(\nerr\nError\n:\n:\nInvalidColumnType\n(\n.\n.\n)\n)\n}", "id": 123, "concepts": ["match", "if-let", "pattern-matching", "error handling"], "instruction": "Create a Rust function `extract_user_password()` that extracts the user name and password from a given string. The function should return a tuple containing two elements, the user name and the password, in that order.\n\nThe function should handle the following exceptions:\n- AttributeError if the string does not include an '@' symbol.\n- ValueError if the string is empty or contains only '@'."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: hashmap lookup, conditional lookup for branching, nested loop with for-let pattern matching, multiple return values in functions\n\n### Task", "fingerprint": null, "seed": "pub fn star2(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let mut max_guard_asleep_per_minute = vec![(0, None); 60];\n    for &guard_id in guard_map.keys() {\n        let mut guard_asleep_by_minute = vec![0; 60];\n        for day in &guard_map[&guard_id] {\n            for minute in 0..60 {\n                guard_asleep_by_minute[minute] += i32::from(!day.minutes[minute]);\n            }\n        }\n        for minute in 0..60 {\n            if max_guard_asleep_per_minute[minute].0 < guard_asleep_by_minute[minute] {\n                max_guard_asleep_per_minute[minute] = (guard_asleep_by_minute[minute], Some(guard_id));\n            }\n        }\n    }\n    if let Some((max_minute, (_, Some(max_guard_id)))) = max_guard_asleep_per_minute.iter().enumerate().max_by_key(|(_, (times, _))| times) {\n        return (max_minute as i32 * max_guard_id) .to_string();\n    }\n    panic!(\"No maximum found: Invalid input!\");\n}", "id": 124, "concepts": ["hashmap lookup", "conditional lookup for branching", "nested loop with for-let pattern matching", "multiple return values in functions"], "instruction": "Write a Rust program that retrieves and displays the address information of a specified user from a hashmap. The hashmap is a collection of user records, where each record contains their name, age, and address. The program should prompt the user to enter a name and attempt to retrieve the corresponding address information from the hashmap. If the name is not present in the hashmap, the program should return an error message indicating that the name does not exist. Otherwise, the program should retrieve the address information and display it to the user.\n\nFor example, if the user enters the name 'Jane', the program should retrieve the associated address information and display it to the user, such as:\n\n```\nName: Jane\nAge: 21\nAddress: 123 Main Street, Anytown, NY 12345\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: error handling in Rust, type conversion, function execution with mutation\n\n### Task", "fingerprint": null, "seed": "pub fn test_flat_crash_64() {\n    let buffer = fs::read(\"tests/programs/flat_crash_64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, FlatMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    let result = machine.load_program(&buffer, &vec![\"flat_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}", "id": 126, "concepts": ["error handling in Rust", "type conversion", "function execution with mutation"], "instruction": "Write a Rust function that retrieves the length of the longest common substring for two strings. The substring length should be calculated by finding the longest contiguous sequence of characters that appear in both strings. The function should throw an error if either input string is not of type `String`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: git submodule access, string manipulation and branch detection, compilation of a rust library\n\n### Task", "fingerprint": null, "seed": "fn get_submodules(\n    repo: &Repository,\n    at: &Commit,\n) -> Result<Vec<Submodule>, Box<dyn std::error::Error>> {\n    let submodule_cfg = modules_file(&repo, &at)?;\n    let submodule_cfg = Config::parse(&submodule_cfg)?;\n    let mut path_to_url = HashMap::new();\n    let entries = submodule_cfg.entries(None)?;\n    for entry in &entries {\n        let entry = entry?;\n        let name = entry.name().unwrap();\n        if name.ends_with(\".path\") {\n            let url = name.replace(\".path\", \".url\");\n            let url = submodule_cfg.get_string(&url).unwrap();\n            path_to_url.insert(entry.value().unwrap().to_owned(), url);\n        }\n    }\n    let mut submodules = Vec::new();\n    let tree = at.tree()?;\n    for (path, url) in &path_to_url {\n        let path = Path::new(&path);\n        let entry = tree.get_path(&path);\n        // the submodule may not actually exist\n        let entry = match entry {\n            Ok(e) => e,\n            Err(_) => continue,\n        };\n        assert_eq!(entry.kind().unwrap(), git2::ObjectType::Commit);\n        submodules.push(Submodule {\n            path: path.to_owned(),\n            commit: entry.id(),\n            repository: url.to_owned(),\n        });\n    }\n    submodules.retain(|s| {\n        let is_rust =\n            s.repository.contains(\"rust-lang\") || s.repository.contains(\"rust-lang-nursery\");\n        let exclude = vec![\n            \"https://github.com/rust-lang/llvm.git\",\n            \"https://github.com/rust-lang/llvm-project.git\",\n            \"https://github.com/rust-lang/lld.git\",\n            \"https://github.com/rust-lang-nursery/clang.git\",\n            \"https://github.com/rust-lang-nursery/lldb.git\",\n            \"https://github.com/rust-lang/libuv.git\",\n            \"https://github.com/rust-lang/gyp.git\",\n            \"https://github.com/rust-lang/jemalloc.git\",\n            \"https://github.com/rust-lang/compiler-rt.git\",\n            \"https://github.com/rust-lang/hoedown.git\",\n        ];\n        is_rust\n            && !exclude.contains(&s.repository.as_str())\n            && !exclude.contains(&&*format!(\"{}.git\", s.repository))\n    });\n    Ok(submodules)\n}", "id": 127, "concepts": ["git submodule access", "string manipulation and branch detection", "compilation of a rust library"], "instruction": "Develop a Rust program that retrieves and parses information from a git repository by using the git2-rs crate for interacting with Git. The program should identify the most recent commit to a specific branch and extract some information from the commit message.\n\nIf information is not found, the program should print an appropriate error message. Provide the ability to compile the program as a statically linked shared library with a custom command line flag."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: floating point operations, round function and branching\n\n### Task", "fingerprint": null, "seed": "fn float_test() {\n    assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.);\n    assert_eq!((-1.01f64).floor(), -2.0);\n    assert!((-1. / std::f32::INFINITY).is_sign_negative());\n}", "id": 128, "concepts": ["floating point operations", "round function and branching"], "instruction": "Develop a Rust program that implements a branching scheme with conditions based on floating point numbers. The program should read a file containing two floating point numbers, and then execute different code based on the result of some simple operations with these numbers.\n\nIf the file does not contain two floating point numbers, the program should output an appropriate error message and terminate.\n\nIf the two numbers are equal, the program should output \"Yep, they are equal\". If the difference between them is less than 10^-10, the output should be \"Barely a difference!\". If the two numbers are different, it should output \"They are different.\"\n\nSolve the problem in the fewest lines of code possible."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: asynchronous programming with async / await, simple request-response pattern implementation with built-in futures\n\n### Task", "fingerprint": null, "seed": "async fn order_book() {\n    let exchange = init().await;\n    let req = OrderBookRequest {\n        market_pair: \"eth_btc\".to_string(),\n    };\n    let resp = exchange.order_book(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 129, "concepts": ["asynchronous programming with async / await", "simple request-response pattern implementation with built-in futures"], "instruction": "Write a program that reads a list of URLs from a file and performs a GET request to each of the URLs. The program should wait for each request to finish before moving on to the next URL, handling any errors or exceptions as needed. Ensure that the program handles cases where certain URLs could not be reached. Additionally, include the ability to display the progress of the request process, such as the percentage of URLs that have been processed so far."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: parsing file lines, string splitting, reading and parsing file content, array indexing, tuple deconstruction, dynamic vector initialization\n\n### Task", "fingerprint": null, "seed": "fn parseModelInfo(reader: &mut BufReader<&File>, buf: &mut String, models: &mut Vec<Model>, basePath: &str) -> Model {\r\n    //Firstly, read the meshId and materialId;\r\n    reader.read_line(buf);\r\n    let mut split_info = buf.split(\" \");\r\n    if len(split_info) != 2 {}\r\n    let meshId: i32 = split_info.next().unwrap().parse().unwrap();\r\n    let materidId = split_info.next().unwrap().parse().unwrap();\r\n    let meshFilePath = basePath + \"/meshes/\" + meshId + \"_mesh.obj\";\r\n    let materialPath = basePath + \"/materials/\" + materidId + \"/\" + materidId;\r\n    //Then, read the position info;\r\n    split_info = buf.split(\" \");\r\n    let mut modelInfo: Vec<Vec3f> = Vec::new();\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 3 {\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        modelInfo.push(Vec3f {\r\n            x: split_info.next().unwrap().parse().unwrap(),\r\n            y: split_info.next().unwrap().parse().unwrap(),\r\n            z: split_info.next().unwrap().parse().unwrap(),\r\n        });\r\n        infoIndex += 1;\r\n    }\r\n    loadImageFromMaterial(model, materidId);\r\n\r\n    models.push(Model {\r\n        meshId,\r\n        materidId: 0,\r\n        position: Vec3f {\r\n            x: modelInfo.get(0).unwrap().x,\r\n            y: modelInfo.get(0).unwrap().y,\r\n            z: modelInfo.get(0).unwrap().z,\r\n        },\r\n        rotation: Vec3f {\r\n            x: modelInfo.get(1).unwrap().x,\r\n            y: modelInfo.get(1).unwrap().y,\r\n            z: modelInfo.get(1).unwrap().z,\r\n        },\r\n        scaling: Vec3f {\r\n            x: modelInfo.get(2).unwrap().x,\r\n            y: modelInfo.get(2).unwrap().y,\r\n            z: modelInfo.get(2).unwrap().z,\r\n        },\r\n    }\r\n    );\r\n\r\n    //Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n}", "id": 130, "concepts": ["parsing file lines", "string splitting", "reading and parsing file content", "array indexing", "tuple deconstruction", "dynamic vector initialization"], "instruction": "Write a Rust function that retrieves and parses the content of a tab-separated text file. The function should return a list of tuples, where each tuple represents a row in the file with the data values in the order of the columns.\n\nIf the file does not exist, return an empty list. If the file is empty, return an empty list. If parsing fails, return an empty list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: parsing file contents, file input, dictionary lookup, error handling with exceptions, local function definition, nested function calls, return value evaluation\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    let file_name = \"input.txt\";\n    let instructions = parse_file(file_name);\n    let (registers, largest_value) = process_instructions(&instructions);\n    println!(\"Day 8, part 1: {}\", get_largest_register_value(&registers));\n    println!(\"Day 8, part 2: {}\", largest_value);\n}", "id": 131, "concepts": ["parsing file contents", "file input", "dictionary lookup", "error handling with exceptions", "local function definition", "nested function calls", "return value evaluation"], "instruction": "Write a Rust class that implements a simple file parser with the following specifications:\n\n- The class should accept a file path as an argument upon initialization.\n- The class should be able to parse the file's contents into a dictionary.\n- The file's contents should be tokenized and parsed into a dictionary with the following keys: 'title', 'author', 'year', 'subject'\n- The class should be able to define a local function `process_line(line)` that processes each line of the file as needed.\n- The local function should return a dictionary of the line's tokens.\n- The class should be able to evaluate the return value of the local function and return a dictionary with the following structure: `{<title>: {<author>: <year>, ...}, <subject>: [<title>, ...], ...}`"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: panic! and exception frames\n\n### Task", "fingerprint": null, "seed": "fn hard_fault(ef: &ExceptionFrame) -> ! {\n    panic!(\"Hardfault... : {:#?}\", ef);\n}", "id": 132, "concepts": ["panic! and exception frames"], "instruction": "Develop a Rust function `get_next_prime` that returns the next prime number after a given integer. Utilize exception handling to manage and recover from errors in case of invalid inputs. Ensure the function accurately handles and recovers from all exceptions."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: parsing URL, URL parser, error handling, function composition, value extraction with pattern matching, string comparison\n\n### Task", "fingerprint": null, "seed": "pub fn get_driver(url: &str) -> MigrateResult<Box<Driver>> {\n    // Mysql driver does not allow to connect using a url so we need to parse it\n    let mut parser = UrlParser::new();\n    parser.scheme_type_mapper(db_scheme_type_mapper);\n    let parsed = parser.parse(url).unwrap();\n\n    match parsed.scheme.as_ref() {\n        \"postgres\" => postgres::Postgres::new(url).map(|d| Box::new(d) as Box<Driver>),\n        \"mysql\" => mysql::Mysql::new(parsed).map(|d| Box::new(d) as Box<Driver>),\n        _ => Err(invalid_url(url))\n    }\n}", "id": 133, "concepts": ["parsing URL", "URL parser", "error handling", "function composition", "value extraction with pattern matching", "string comparison"], "instruction": "Develop a Rust program that parses a given URL and extracts the hostname, path, and query parameters. You should handle invalid inputs and ensure that the hostname is always in lowercase. Provide clear error handling and logging to manage exceptions that might occur during the execution of the program."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: fuzz target building, file removal, file existence check, file creation and removal\n\n### Task", "fingerprint": null, "seed": "fn build_all() {\n    let project = project(\"build_all\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_b\")\n        .assert()\n        .success();\n\n    // Build to ensure that the build directory is created and\n    // `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n\n    let a_bin = build_dir.join(\"build_all_a\");\n    let b_bin = build_dir.join(\"build_all_b\");\n\n    // Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    // Test that building all fuzz targets does in fact recreate the files.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    assert!(a_bin.is_file());\n    assert!(b_bin.is_file());\n}", "id": 134, "concepts": ["fuzz target building", "file removal", "file existence check", "file creation and removal"], "instruction": "Develop a Rust program that automates the creation of fuzz targets by first removing all existing fuzz targets from a directory and then creating a new target within the same directory. The new fuzz target should be created by randomly generating a file with a specified extension, such as `a.txt`, `b.txt`, `c.txt`, and so on. The program should handle all exceptions and validate inputs. Ensure that the program runs in a loop that can be terminated by a user input."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: input validation, error handling, error message customization\n\n### Task", "fingerprint": null, "seed": "pub fn write_board(board_name: String, contents: String) -> Result<(), String> {\n    let mut configurator = Configurator::new();\n    unsafe {\n        configurator.set_working_folder(WORKING_FOLDER.clone());\n    }\n    configurator.write_board(board_name, contents)\n}", "id": 136, "concepts": ["input validation", "error handling", "error message customization"], "instruction": "Write a Rust function `validate_input` that takes a value `x` as an argument and returns a tuple of two elements: a boolean indicating whether `x` is a valid input, and a string that is an error message if `x` is invalid. If `x` is valid, the function should return `(True, \"\")` as the error message. Otherwise, the function should return `(False, \"X is not positive!\")` if `x` is not positive, and `(False, \"X is not an integer!\")` if `x` is not an integer."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: command line argument passing, cargo fuzzing, error handling with exceptions\n\n### Task", "fingerprint": null, "seed": "fn help() {\n    cargo_fuzz().arg(\"help\").assert().success();\n}", "id": 137, "concepts": ["command line argument passing", "cargo fuzzing", "error handling with exceptions"], "instruction": "Construct a Rust class that implements a simple calculator. The calculator should support addition, subtraction, multiplication, and division. The class should provide an interface to perform operations on numbers provided as command line arguments.\n\nFor example, running `cargo run + 1 2` should print `3`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: memory access, testing all implementations of the same trait, trait object instantiation\n\n### Task", "fingerprint": null, "seed": "fn assert_memory_load_bytes_all<R: Rng>(\n    rng: &mut R,\n    max_memory: usize,\n    buf_size: usize,\n    addr: u64,\n) {\n    assert_memory_load_bytes(\n        rng,\n        &mut SparseMemory::<u64>::new_with_memory(max_memory),\n        buf_size,\n        addr,\n    );\n    assert_memory_load_bytes(\n        rng,\n        &mut FlatMemory::<u64>::new_with_memory(max_memory),\n        buf_size,\n        addr,\n    );\n    assert_memory_load_bytes(\n        rng,\n        &mut WXorXMemory::new(FlatMemory::<u64>::new_with_memory(max_memory)),\n        buf_size,\n        addr,\n    );\n\n    #[cfg(has_asm)]\n    assert_memory_load_bytes(\n        rng,\n        &mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000),\n        buf_size,\n        addr,\n    );\n}", "id": 139, "concepts": ["memory access", "testing all implementations of the same trait", "trait object instantiation"], "instruction": "Develop a Rust class `Device` with two methods, `send()` and `receive()`, that provide basic communication capabilities. The class should support sending and receiving data in bytes. Utilize the trait-based design pattern to provide different implementations for `send()` and `receive()` based on the nature of the data.\n\nCreate a `Device` trait that defines an interface for sending and receiving data in bytes. Implement the trait for the `TCP` and `UDP` variants of `Device`. Provide a main program that instantiates and uses the `TCP` and `UDP` variants of the `Device` class dynamically based on a configuration file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: conditional evaluation of command-line arguments, environment variable manipulation\n\n### Task", "fingerprint": null, "seed": "fn should_update() -> bool {\n    std::env::args_os().nth(1).unwrap_or_default() == \"--refresh\"\n}", "id": 140, "concepts": ["conditional evaluation of command-line arguments", "environment variable manipulation"], "instruction": "Create a Rust function that checks whether the current command-line arguments match the following criteria:\n- The first argument must be the path to an executable file\n- The second argument must be the path to a file that exists and is non-empty\n- The third argument must be a string that conforms to the following regex `[a-zA-Z0-9_-]*`\n\nIf all arguments match the criteria, the function should return `true`, otherwise `false`.\n\nThe function should also check whether the current environment variables satisfy the following requirements:\n- The environment variable `VARIABLE_1` must exist and be a non-empty string.\n- The environment variable `VARIABLE_2` must exist and be set to a non-empty list of strings.\n- The last two environment variables must be different."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: result type, string manipulation, type conversion\n\n### Task", "fingerprint": null, "seed": "fn build_unparsed(s: ~str) -> Result<IRCToken, ~str> {\n    Ok(Unparsed(s))\n}", "id": 141, "concepts": ["result type", "string manipulation", "type conversion"], "instruction": "Implement a Rust function `calculate_best_pair` that takes a list of numbers and returns a tuple of the two elements that sum to the closest to 0. If there is more than one such pair with the same closest sum, return the pair whose elements have the least difference between each other. You can assume there is always at least one solution.\n\nFor the precondition check, use a try/except block to catch and handle the error when the input is not a list. For the main logic, use the `abs` function and the `find_index` function from the standard library's `itertools` module to find the two elements that sum to the closest to 0."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: maximum value of a map, default value handling, hash map iteration\n\n### Task", "fingerprint": null, "seed": "fn get_largest_register_value(registers: &HashMap<&str, i32>) -> i32 {\n    *registers\n        .iter()\n        .map(|(_, v)| v)\n        .max()\n        .unwrap_or(&0)\n}", "id": 142, "concepts": ["maximum value of a map", "default value handling", "hash map iteration"], "instruction": "Implement a Rust class with a method `find_max_value_map(map)` that uses the maximum value in a map of key-value pairs and returns it. Utilize default values and have the method handle cases where the map is empty. Utilize hash map iteration to traverse the map and return the maximum value."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: lifetimes, asynchronous programming, lifetime scopes, asynchronous task execution\n\n### Task", "fingerprint": null, "seed": "async fn main() -> std::io::Result<()> {\n    // Set keep-alive to 75 seconds\n    let _one = HttpServer::new(app).keep_alive(Duration::from_secs(75));\n\n    // Use OS's keep-alive (usually quite long)\n    let _two = HttpServer::new(app).keep_alive(KeepAlive::Os);\n\n    // Disable keep-alive\n    let _three = HttpServer::new(app).keep_alive(None);\n\n    Ok(())\n}", "id": 143, "concepts": ["lifetimes", "asynchronous programming", "lifetime scopes", "asynchronous task execution"], "instruction": "Implement a Rust program that simulates the execution of asynchronous task functions. The program should handle three types of tasks:\n- `sleep(seconds: usize)`, which pauses the program for `seconds` seconds\n- `await(signal: i32)`, which suspends the execution and waits for a signal (a number) to be received from the outside\n- `send(signal: i32)`, which sends a signal (a number) to the outside\n\nThe program should support at least two tasks to be executed in parallel. It should handle the following scenario:\n- A task is executed when the program starts\n- The second task is executed when the first task is suspended\n- The third task is executed when the first task is suspended\n- After the second task is executed, the program should exit"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterators, regular expression for pattern matching, list manipulation, nested data structures\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    let re_top = Regex::new(r\" {4}|\\[([A-Z])\\]\").unwrap();\n    let re_action = Regex::new(r\"move (\\d+) from (\\d+) to (\\d+)\").unwrap();\n    let mut stacks: Vec<Vec<char>> = Vec::new();\n\n    let mut input = io::stdin().lock().lines()\n        .flat_map(|l| l.ok());\n\n    for line in &mut input {\n        if line.trim().is_empty() { break }\n        for (ix, ch) in match_iter::<char>(&re_top, &line).enumerate() {\n            if let Some(ch) = ch {\n                ensure_size(&mut stacks, ix + 1);\n                stacks[ix].push(ch);\n            }\n        }\n    }\n\n    for stack in &mut stacks {\n        stack.reverse()\n    }\n\n    for line in input {\n        if let Some((num, src, dst)) = match_capture::<Action>(&re_action, &line) {\n            let (src, dst) = get_disjoint(&mut stacks, src - 1, dst - 1);\n            assert!(num <= src.len(), \"Trying to pop {} from {}\", num, src.len());\n            let pos = src.len() - num;\n            dst.extend_from_slice(&src[pos..]);\n            src.truncate(pos);\n        }\n    }\n\n    let letters = stacks.iter().map(|s| s.last().expect(\"Stack is empty\"));\n    println!(\"{}\", letters.collect::<String>());\n}", "id": 144, "concepts": ["iterators", "regular expression for pattern matching", "list manipulation", "nested data structures"], "instruction": "Write a Rust function that takes a text file as input and returns a list of words that match a certain pattern. The input pattern is a regular expression (regex) string that can include multiple characters and special operators (e.g., for exact match, use a single character).\n\nThe function should return a list of all words in the text file that match the given pattern. The function should use a regex to match the words in the text file against the pattern. The list of words should be in alphabetical order.\n\nThe function should handle potential errors such as invalid regular expression syntax and invalid input files."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: iterators, BTreeMaps, sorting by frequency, parsing command line arguments\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    if env::args().len() != 2 {\n        panic!(\"Incorrect number of arguments provided\\n\");\n    }\n\n    let input = BufReader::new(File::open(env::args().nth(1).unwrap()).unwrap());\n\n    let mut cols: Vec<BTreeMap<char, i32>> = vec![];\n\n    for line in input.lines() {\n        for (i, c) in line.unwrap().chars().enumerate() {\n            if i == cols.len() {\n                cols.push(BTreeMap::new());\n            }\n            *cols[i].entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut most = String::new();\n    let mut least = String::new();\n    for c in cols {\n        let (m, l) = most_least_common(c);\n        most.push(m);\n        least.push(l);\n    }\n    println!(\"Most common message: {}\", most);\n    println!(\"Least common message: {}\", least);\n}", "id": 145, "concepts": ["iterators", "BTreeMaps", "sorting by frequency", "parsing command line arguments"], "instruction": "Develop a Rust class `WordFrequency` that keeps track of the number of times each word appears in a text. The class should support adding a word (string) to the word frequency list, and have methods to return the number of times a word appears, as well as the number of words that appear at least `k` times. The class should also have a method to print the most frequent words in descending frequency order, and have a method that returns the number of words that appear in the text.\n\nThe class should implement the `Iterator` protocol to allow the class to be used as an iterator, with the `Iterator::next` method providing the next word. Additionally, the class should be able to be initialized with a text string, which it parses into a list of words. The class should have an optional parameter `k` that is used to filter out words that appear less than `k` times.\n\nThe class should be able to handle erroneous inputs gracefully, such as invalid input strings or non-integer values. In addition, the class should be able to handle command line arguments, such as `--k` and `--help`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: game loop, function composition, game loop synchronization\n\n### Task", "fingerprint": null, "seed": "pub fn main() {\n    let game = Game::new();\n\n    game_loop(game, 240, 0.1, |g| {\n        g.game.your_update_function();\n    }, |g| {\n        g.game.your_render_function();\n    });\n}", "id": 147, "concepts": ["game loop", "function composition", "game loop synchronization"], "instruction": "Implement a Rust function `roll_dice()` that takes a list of integers as arguments and returns a random value from the list. Simulate a game loop where the function is called every frame of a video game to simulate rolling the dice for the player. Utilize function composition to implement a game loop that rolls the dice 5 times and returns the total of the roll."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: mapping of input values to output values, default return value, explicit return value, case statement\n\n### Task", "fingerprint": null, "seed": "fn db_scheme_type_mapper(scheme: &str) -> SchemeType {\n    match scheme {\n        \"postgres\" => SchemeType::Relative(5432),\n        \"mysql\" => SchemeType::Relative(3306),\n        _ => SchemeType::NonRelative,\n    }\n}", "id": 149, "concepts": ["mapping of input values to output values", "default return value", "explicit return value", "case statement"], "instruction": "Implement a Rust program that accepts a list of pairs of numbers and returns a list of their sum, difference, product, and quotient. If any of the numbers in the input is negative, the output should be set to the appropriate default value (0, 1, 1, or 0). Include assertions to ensure all input numbers are non-negative."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: error handling, function composition\n\n### Task", "fingerprint": null, "seed": "pub fn write_file(path: PathBuf, content: String) -> Result<(), String> {\n    fs::write(path, content).map_err(|e| e.to_string())\n}", "id": 151, "concepts": ["error handling", "function composition"], "instruction": "Implement a Rust function that accepts a string containing a floating-point number along with a positive integer, `precision`, and returns a string containing the number after truncating it to the specified precision. If the given precision is greater than the number of decimal places, pad the output with zeros.\n\nAssume that the function accepts only valid inputs. For example, the function should pass the following assertions:\n\n```rust\nassert_eq!(round_to_precision(\"100.0\", 9), \"100.0000000\");\nassert_eq!(round_to_precision(\"12.34\", 2), \"12.3400000\");\nassert_eq!(round_to_precision(\"999.9999\", 3), \"999.999\");\nassert_eq!(round_to_precision(\"1024.0\", 2), \"1024.00\");\nassert_eq!(round_to_precision(\"999.9999\", 1), \"1000\");\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: resource-counted objects, cloning of resource-counted objects, string manipulation\n\n### Task", "fingerprint": null, "seed": "fn rc_test() {\n    use std::rc::Rc;\n\n    let s: Rc<String> = Rc::new(\"shirataki\".to_string());\n    let t: Rc<String> = s.clone();\n    let u: Rc<String> = s.clone();\n\n    assert!(s.contains(\"shira\"));\n    assert_eq!(t.find(\"taki\"), Some(5));\n    println!(\"{} are quite chewy, almost bouncy, but lack flavor\", u);\n\n    // s.push_str(\" noodles\"); // error\n}", "id": 152, "concepts": ["resource-counted objects", "cloning of resource-counted objects", "string manipulation"], "instruction": "Design a Rust class `Resource` that represents some resource that a user has attached to a user object. The `Resource` class should maintain a count of how many times it has been attached to a user. Each time a `Resource` is attached to a user, the user's count should be incremented by one. When a `Resource` is detached, the user's count should be decremented by one. The class should also be able to be cloned, to allow multiple copies of the same `Resource` to exist concurrently.\n\nFor example, given the following code:\n\n```rust\nlet user = User {\n    name: \"Alice\",\n    resources: vec![Resource::new()],\n};\nlet user2 = user.clone();\nlet user3 = user.clone();\nassert_eq!(user.resources[0].get_count(), 3);\nassert_eq!(user2.resources[0].get_count(), 2);\nassert_eq!(user3.resources[0].get_count(), 1);\n```\n\nthe program should output `3`, `2`, and `1` to represent the count of resources attached to `user`, `user2`, and `user3`, respectively."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: integer overflow, integer wrapping\n\n### Task", "fingerprint": null, "seed": "fn overflow() {\n    let big_val = std::i32::MAX;\n    // let x = big_val + 1; // panic\n    let _x = big_val.wrapping_add(1); // ok\n}", "id": 153, "concepts": ["integer overflow", "integer wrapping"], "instruction": "Implement a Rust function `f(x, y)` that computes the value of `x - y` if `x + y` overflows. If `x + y` does not overflow, the function should return `x - y`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: optional parameter, function composition, type casting, return value handling\n\n### Task", "fingerprint": null, "seed": "async fn run_completions(shell: ShellCompletion) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing completions\");\n\n\tfn generate(generator: impl Generator) {\n\t\tlet mut cmd = Args::command();\n\t\tclap_complete::generate(generator, &mut cmd, \"watchexec\", &mut std::io::stdout());\n\t}\n\n\tmatch shell {\n\t\tShellCompletion::Bash => generate(Shell::Bash),\n\t\tShellCompletion::Elvish => generate(Shell::Elvish),\n\t\tShellCompletion::Fish => generate(Shell::Fish),\n\t\tShellCompletion::Nu => generate(clap_complete_nushell::Nushell),\n\t\tShellCompletion::Powershell => generate(Shell::PowerShell),\n\t\tShellCompletion::Zsh => generate(Shell::Zsh),\n\t}\n\n\tOk(())\n}", "id": 154, "concepts": ["optional parameter", "function composition", "type casting", "return value handling"], "instruction": "Design a Rust function `f(x, y, a, b)` that returns a tuple of two values, `(c, d)` where `c` is the result of function `g(x, y)` and `d` is the result of function `h(a, b)`. The function `g` takes two arguments, `x` and `y`, and returns a tuple of two integers, `(p, q)`. The function `h` takes two arguments, `a` and `b`, and returns an integer. Both `g` and `h` operate on integer values.\n\nConvert the above `f` function to take optional parameters `x`, `y`, `a`, and `b` instead of positional arguments. If no values are provided for `x`, `y`, `a`, or `b`, they should be set to zero. If no value is provided for `a` or `b`, they should be set to 1."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: ownership transfer, mutability and immutability, collections initialization, destructuring, optional variables\n\n### Task", "fingerprint": null, "seed": "fn ownership_test() {\n    let mut v = Vec::new();\n    for i in 101..106 {\n        v.push(i.to_string());\n    }\n\n    let fifth = v.pop().unwrap();\n    assert_eq!(fifth, \"105\");\n\n    let second = v.swap_remove(1);\n    assert_eq!(second, \"102\");\n\n    let third = std::mem::replace(&mut v[2], \"substitute\".to_string());\n    assert_eq!(third, \"103\");\n\n    assert_eq!(v, vec![\"101\", \"104\", \"substitute\"]);\n\n    struct Person {\n        name: Option<String>,\n        birth: Option<i32>,\n    };\n\n    let mut composers = Vec::new();\n    composers.push(Person {\n        name: Some(\"Palestrina\".to_string()),\n        birth: Some(1525),\n    });\n\n    // let first_name = composers[0].name // error\n\n    let first_name = std::mem::replace(&mut composers[0].name, None);\n    assert_eq!(first_name, Some(\"Palestrina\".to_string()));\n    assert_eq!(composers[0].name, None);\n    let birth = composers[0].birth.take();\n    assert_eq!(birth, Some(1525));\n    assert_eq!(composers[0].birth, None);\n}", "id": 155, "concepts": ["ownership transfer", "mutability and immutability", "collections initialization", "destructuring", "optional variables"], "instruction": "Write a Rust function `print_list_with_index` that takes a list of elements as an argument and prints each element along with its corresponding index. The function should return an empty list if the list is empty, and an error message if the list is not empty but contains any non-string elements."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: algorithm design, 2-pointer technique, conditional loop, algorithmic complexity, precondition checking for type validation\n\n### Task", "fingerprint": null, "seed": "fn main() -> Result<()> {\n    let inss = parse_instructions()?;\n\n    for (pc, ins) in inss.iter().enumerate() {\n        match ins.op {\n            Operation::Nothing => {\n                // Don't invert zero `nop`s as `jmp +0` results in a loop.\n                if ins.arg != 0 && print_fixed_acc(&inss, Operation::Jump, pc) {\n                    break;\n                }\n            }\n            Operation::Jump => {\n                // Finish as soon as one inversion fixes the code.\n                if print_fixed_acc(&inss, Operation::Nothing, pc) {\n                    break;\n                }\n            }\n            Operation::Accumulate => {}\n        }\n    }\n\n    Ok(())\n}", "id": 156, "concepts": ["algorithm design", "2-pointer technique", "conditional loop", "algorithmic complexity", "precondition checking for type validation"], "instruction": "Design a Rust class that implements a variable-length sliding window. The class should operate as follows:\n\n- Given a target length `k` and a target list `l`, initialize the window with the first `k` elements in `l`.\n- If the window's length is `k`, remove the first element in the window and append the next element in `l` to the tail of the window.\n- Return a list of elements in the window in every iteration.\n\nThe function should satisfy the following assertions:\n\n```rust\nlet sliding_window = SlidingWindow::new(2);\nassert_eq!(sliding_window.push_list(vec![10, 20, 30]), vec![10, 20]);\nassert_eq!(sliding_window.push_list(vec![40, 50]), vec![20, 30]);\nassert_eq!(sliding_window.push_list(vec![60, 70]), vec![30, 40]);\nassert_eq!(sliding_window.push_list(vec![80, 90]), vec![40, 50]);\nassert_eq!(sliding_window.push_list(vec![100]), vec![50, 60]);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async function implementation, function composition, response generation\n\n### Task", "fingerprint": null, "seed": "async fn fallback_route(_req: HttpRequest) -> impl Responder {\n    HttpResponse::NotFound().json(\"Route not found\")\n}", "id": 157, "concepts": ["async function implementation", "function composition", "response generation"], "instruction": "Develop a Rust function `async_get_git_commits` that takes a GitHub repository URL as an argument, and attempts to asynchronously fetch the latest commit messages for the default branch of the repository. The function should return a list of commit messages in the following format: `[author, message]`.\n\nThe function should be implemented as an asynchronous function using the async/await syntax, and should handle potential GitHub API rate limiting issues. Additionally, if the function cannot fetch the commits from the repository, it should return an empty list instead. The function should also handle potential network errors or issues with the GitHub API itself.\n\nBy utilizing async functions, the function can fetch commits for multiple repositories in parallel, and make efficient use of system resources and API calls. It is particularly suitable for tasks that require fetching large amounts of data concurrently."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: command-line argument parsing, string formatting and manipulation, string interpolation\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    let instruction: Vec<String> = std::env::args().collect();\n    let instruction: &String = &instruction[1];\n\n    println!(\"{}\", santa(instruction));\n}", "id": 158, "concepts": ["command-line argument parsing", "string formatting and manipulation", "string interpolation"], "instruction": "Write a Rust function `print_user_message` that takes an arbitrary number of arguments as strings. The function should have a default argument `message` that is the default message to be printed. The function should print the message with the following formatting:\n\n```text\nUser message: [message]\n```\n\nUse the `print!` function in this context."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: creating migration directories, migration directory entry retrieval, migration file retrieval, migration application\n\n### Task", "fingerprint": null, "seed": "fn listing_a_single_migration_name_should_work(api: TestApi) {\n    let dm = api.datamodel_with_provider(\n        r#\"\n        model Cat {\n            id Int @id\n            name String\n        }\n    \"#,\n    );\n\n    let migrations_directory = api.create_migrations_directory();\n\n    api.create_migration(\"init\", &dm, &migrations_directory).send_sync();\n\n    api.apply_migrations(&migrations_directory)\n        .send_sync()\n        .assert_applied_migrations(&[\"init\"]);\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[\"init\"]);\n}", "id": 159, "concepts": ["creating migration directories", "migration directory entry retrieval", "migration file retrieval", "migration application"], "instruction": "Design a Rust function that accepts a migration directory path as a string. The function should scan the directory recursively for migration files, which are files that have a name in the format of `YYYYMMDDHHMMSS_file_name`, and return a list of migration files with the latest file name first."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iterator usage for list comprehension, map usage for list iteration, defining new types, type alias usage\n\n### Task", "fingerprint": null, "seed": "fn de_timeline(raw: TimelineRaw, even: bool) -> game::Timeline {\n    let mut res = game::Timeline::new(\n        de_l(raw.index, even),\n        raw.width,\n        raw.height,\n        raw.begins_at,\n        raw.emerges_from.map(|x| de_l(x, even)),\n    );\n\n    let index = de_l(raw.index, even);\n    let begins_at = raw.begins_at;\n    let width = raw.width;\n    let height = raw.height;\n\n    res.states = raw\n        .states\n        .into_iter()\n        .enumerate()\n        .map(|(i, b)| de_board(b, begins_at + i as isize, index, width, height))\n        .collect();\n\n    res\n}", "id": 160, "concepts": ["iterator usage for list comprehension", "map usage for list iteration", "defining new types", "type alias usage"], "instruction": "Design a Rust program that creates a list of integers from 1 to `n` using the following rules:\n1. The elements in the list must be in ascending order.\n2. The elements in the list should be even numbers if `n` is even.\n3. The elements in the list should be odd numbers if `n` is odd.\n\nUse a list comprehension to generate the list of integers and then use map to iterate through the elements to apply the desired condition. The program should handle cases where `n` is less than 1."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: BTree map usage, nested data structures, hash map iteration, map mutation\n\n### Task", "fingerprint": null, "seed": "fn expect_money_conserved(table: &Table) {\n  let mut history: BTreeMap<u32, Vec<Row>> = BTreeMap::new();\n  for c in table.scan() {\n    history.entry(c.t).or_insert(Vec::new()).push(Row { k: c.k, v: c.v });\n  }\n  let mut tracker: HashMap<i32, i32> = HashMap::new();\n  for (_, rs) in history {\n    for r in rs {\n      tracker.insert(r.k, r.v);\n    }\n    let mut sum = 0;\n    for (_, v) in tracker.clone() {\n      sum += v;\n    }\n    assert! (sum == 0);\n  }\n}", "id": 162, "concepts": ["BTree map usage", "nested data structures", "hash map iteration", "map mutation"], "instruction": "Create a Rust function called `generate_matrix` that takes a number `n` as the parameter. The function should generate an `n x n` matrix consisting of numbers between 1 and `n * n`, where `n` is the input parameter. Each element in the matrix should be unique; i.e., no two elements in the same row or column should have the same value. The function should return the generated matrix as a nested list.\n\nFor example, if `n` is 3, the function should generate the following matrix:\n\n- 1 4 7\n- 2 5 8\n- 3 6 9"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: match error type identification, conditional assertion based on optional value, structured error handling\n\n### Task", "fingerprint": null, "seed": "fn assert_memory_store_empty_bytes<M: Memory>(memory: &mut M) {\n    assert!(memory.store_byte(0, 0, 42).is_ok());\n    assert!(memory.store_bytes(0, &[]).is_ok());\n}", "id": 163, "concepts": ["match error type identification", "conditional assertion based on optional value", "structured error handling"], "instruction": "Design a Rust program that throws a `ValueError` exception if a number is negative, or the parameter is not a number. Otherwise, the program should return the absolute value of the input number."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: async/await syntax, closure, DOM manipulation, thread communication, synchronization\n\n### Task", "fingerprint": null, "seed": "pub async fn render_window_wasm(subaction: brawllib_rs::high_level_fighter::HighLevelSubaction) {\n    use brawllib_rs::renderer::app::state::{AppEventIncoming, State};\n    use brawllib_rs::renderer::app::App;\n    use wasm_bindgen::prelude::*;\n    use web_sys::HtmlElement;\n\n    let document = web_sys::window().unwrap().document().unwrap();\n\n    let body = document.body().unwrap();\n    let parent_div = document.create_element(\"div\").unwrap();\n    parent_div\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .style()\n        .set_css_text(\"margin: auto; width: 80%; aspect-ratio: 4 / 2; background-color: black\");\n    body.append_child(&parent_div).unwrap();\n\n    let app = App::new_insert_into_element(parent_div, subaction).await;\n    let event_tx = app.get_event_tx();\n\n    let frame = document.create_element(\"p\").unwrap();\n    frame.set_inner_html(\"Frame: 0\");\n    body.append_child(&frame).unwrap();\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Run\");\n    let event_tx_move = event_tx.clone();\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Stop\" {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Pause))\n                .unwrap();\n            button_move.set_inner_html(\"Run\");\n        } else {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Play))\n                .unwrap();\n            button_move.set_inner_html(\"Stop\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Perspective\");\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Orthographic\" {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(false))\n                .unwrap();\n            button_move.set_inner_html(\"Perspective\");\n        } else {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(true))\n                .unwrap();\n            button_move.set_inner_html(\"Orthographic\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    app.get_event_tx()\n        .send(AppEventIncoming::SetState(State::Pause))\n        .unwrap();\n\n    app.run();\n}", "id": 164, "concepts": ["async/await syntax", "closure", "DOM manipulation", "thread communication", "synchronization"], "instruction": "Create a Rust function called `async_count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter. When the threads are ready to communicate with one another, use channels to send signals to each other to indicate when the traversal has finished and when the counts should be combined. This implementation uses async/await syntax and closures to manage the asynchronous communication between the two threads."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: symbol for success or failure, conditional logic, string concatenation, string comparison\n\n### Task", "fingerprint": null, "seed": "pub fn module<'a>(context: &'a Context) -> Option<Module<'a>> {\n    const SUCCESS_CHAR: &str = \"\u279c\";\n    const FAILURE_CHAR: &str = \"\u2716\";\n    let color_success = Color::Green.bold();\n    let color_failure = Color::Red.bold();\n\n    let mut module = context.new_module(\"character\")?;\n    module.get_prefix().set_value(\"\");\n\n    let arguments = &context.arguments;\n    let use_symbol = module\n        .config_value_bool(\"use_symbol_for_status\")\n        .unwrap_or(false);\n    let exit_success = arguments.value_of(\"status_code\").unwrap_or(\"0\") == \"0\";\n\n    /* If an error symbol is set in the config, use symbols to indicate\n    success/failure, in addition to color */\n    let symbol = if use_symbol && !exit_success {\n        module.new_segment(\"error_symbol\", FAILURE_CHAR)\n    } else {\n        module.new_segment(\"symbol\", SUCCESS_CHAR)\n    };\n\n    if exit_success {\n        symbol.set_style(color_success.bold());\n    } else {\n        symbol.set_style(color_failure.bold());\n    };\n\n    Some(module)\n}", "id": 166, "concepts": ["symbol for success or failure", "conditional logic", "string concatenation", "string comparison"], "instruction": "Write a Rust function called `check_password` that takes a string `password` as the parameter. The function should return `True` if the password is valid, and `False` otherwise. Define the following constraints for a valid password:\n\n- The password must be at least 8 characters long.\n- The password must contain at least one lowercase letter.\n- The password must contain at least one uppercase letter.\n- The password must contain at least one number.\n- The password must contain at least one special character (i.e., a symbol that is not a letter or a number).\n- The password must not contain consecutive repeated characters."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: pattern matching, function pointer, bitwise operations, generic function parameters\n\n### Task", "fingerprint": null, "seed": "fn handle_trame(trame: Trame) -> Option<Trame> {\n    match (\n        trame.id,\n        trame.cmd,\n        &trame.data[0..trame.data_length as usize],\n    ) {\n        (0...5, 0x0, [0x55]) => Some(trame!(trame.id, 0x00, [0xAA])),\n        (_, _, _) => None,\n    }\n}", "id": 167, "concepts": ["pattern matching", "function pointer", "bitwise operations", "generic function parameters"], "instruction": "Create a Rust class called `StringSet` that implements a set of strings. It should support the following operations:\n- `add(str)`: adds a string to the set if it does not exist, and returns true if successful\n- `remove(str)`: removes a string from the set if it exists, and returns true if successful\n- `contains(str)`: returns true if the string exists in the set\n- `size()`: returns the number of strings in the set\n- `union(other)`: returns a new set containing the union of the two sets\n- `intersection(other)`: returns a new set containing the intersection of the two sets\n- `difference(other)`: returns a new set containing the difference of the two sets\n- `symmetric_difference(other)`: returns a new set containing the symmetric difference of the two sets\n- `is_subset(other)`: returns true if the set is a subset of the other set\n\nThe class should provide a method `is_disjoint(other)` that returns true if the set has no elements in common with the other set. The class should also provide an operator overload for the `|` and `&` operations that return a new set from the union or intersection of the two sets, respectively."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: use of the `?` operator and `Result` generic type, string interpolation, conditional error handling, conditional execution of code\n\n### Task", "fingerprint": null, "seed": "fn\ntest_string\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\n\"\nhello\nworld\n!\n\"\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\ns\n.\nto_owned\n(\n)\n]\n)\n?\n;\nlet\nfrom\n:\nString\n=\ndb\n.\none_column\n(\n\"\nSELECT\nt\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nfrom\ns\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 168, "concepts": ["use of the `?` operator and `Result` generic type", "string interpolation", "conditional error handling", "conditional execution of code"], "instruction": "Create a Rust class called `Taxi` that implements a basic taxi trip simulation. The class should have a simple `drive` method that simulates a trip by printing the coordinates of the start and end location. Upon instantiation, the class should also have a field `speed` with a value of 10 miles per hour. The trip should have a random start and end location within a fixed bounding area.\n\nThe class should also implement a method `taxi_fare` that calculates the fare for the trip. The fare is a function of `speed` and `distance` traveled. It is $[4.50 \\times speed \\times distance] + 2.50$ if the trip is less than 100 miles. Otherwise, the fare is $[6.50 \\times speed \\times distance] + 2.50$.\n\nThe class should implement the following assertions:\n\n```rust\nlet taxi = Taxi::new();\nassert_eq!(format!(\"{}\", taxi), \"Taxi(speed=10, location_x=0, location_y=0, location_z=0)\");\n\nlet taxi = Taxi::new();\ntaxi.drive(1000);\nassert_eq!(format!(\"{}\", taxi), \"Taxi(speed=10, location_x=1000, location_y=0, location_z=0)\");\n\nlet taxi = Taxi::new();\ntaxi.drive(1000);\nassert_eq!(format!(\"{}\", taxi), \"Taxi(speed=10, location_x=1000, location_y=0, location_z=0)\");\nassert_eq!(format!(\"{:.2}\", taxi.taxi_fare()), \"1000.00\");\n\nlet taxi = Taxi::new();\ntaxi.drive(2000);\nassert_eq!(format!(\"{}\", taxi), \"Taxi(speed=10, location_x=2000, location_y=0, location_z=0)\");\nassert_eq!(format!(\"{:.2}\", taxi.taxi_fare()), \"1875.00\");\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: recursive directory traversal with a function that has multiple base cases and returns a result of type `Vec<DirEntry>`\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_read_dir(path: &str, recursive: bool) -> Result<Vec<DirEntry>, String> {\n    read_dir(path, recursive).map_err(|e| e.to_string())\n}", "id": 170, "concepts": ["recursive directory traversal with a function that has multiple base cases and returns a result of type `Vec<DirEntry>`"], "instruction": "Implement a Rust class called `FileTree` that maintains a structured representation of a folder hierarchy. The class should provide an interface to navigate through the tree and retrieve metadata about individual files. Implement a method `traverse` that traverses the entire folder hierarchy and returns a list of `DirEntry` objects for each file in the tree. The `DirEntry` class represents the metadata of a file or directory in the tree.\n\nFor example, suppose the root directory has the following structure:\n\n- root\n  - one.txt\n  - two.txt\n\n- root\n  - one.txt\n  - three.txt\n  - two.txt\n\n- root\n  - one.txt\n  - four.txt\n  - two.txt\n\nIf the method is invoked on the `root` directory, the traversal should return a list containing the file `one.txt` three times, the file `two.txt` three times, and the file `three.txt` once."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: recursive directory creation with a flag to determine behavior, generic error handling with match expression\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_create_dir(path: &str, recursive: bool) -> Result<(), String> {\n    if recursive {\n        fs::create_dir_all(path).map_err(|e| e.to_string())\n    } else {\n        fs::create_dir(path).map_err(|e| e.to_string())\n    }\n}", "id": 171, "concepts": ["recursive directory creation with a flag to determine behavior", "generic error handling with match expression"], "instruction": "Create a Rust program that recursively creates a directory structure by accepting a path as an argument. The directory structure should be created in the current working directory by default. The program should accept a flag '-p' to indicate whether to create the directory structure prior to creating the last directory in the path. The program should also accept a flag '-n' to specify the maximum number of directories to create in the path.\n\nFor example, if the path is `./test/example/test`, with the flag `-p`, the directory structure `./test/example` will be created and the directory `./test/example/test` will be created as the last directory in the path. If the path is `./test/example/test` with the flag `-n 2`, the program should only create the directory `./test` and `./test/example` without creating the directory `./test/example/test`.\n\nIf the path is `./test/example/test` with flag `-p` and `-n 2`, the program should print out an error message and exit if the directory `./test` already exists."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: image rendering, event handling, SDL2 library, generic type parameters\n\n### Task", "fingerprint": null, "seed": "fn show_image(image: &Image)\n{\n    let sdl             = sdl2::init().unwrap();\n    let video_subsystem = sdl.video().unwrap();\n    let display_mode    = video_subsystem.current_display_mode(0).unwrap();\n\n    let w = match display_mode.w as u32 > image.width {\n        true  => image.width,\n        false => display_mode.w as u32\n    };\n    let h = match display_mode.h as u32 > image.height {\n        true  => image.height,\n        false => display_mode.h as u32\n    };\n    \n    let window = video_subsystem\n        .window(\"Image\", w, h)\n        .build()\n        .unwrap();\n    let mut canvas = window\n        .into_canvas()\n        .present_vsync()\n        .build()\n        .unwrap();\n    let black = sdl2::pixels::Color::RGB(0, 0, 0);\n\n    let mut event_pump = sdl.event_pump().unwrap();\n    // render image\n        canvas.set_draw_color(black);\n        canvas.clear();\n\n        for r in 0..image.height {\n            for c in 0..image.width {\n                let pixel = &image.pixels[image.height as usize - r as usize - 1][c as usize];\n                canvas.set_draw_color(Color::RGB(pixel.R as u8, pixel.G as u8, pixel.B as u8));\n                canvas.fill_rect(Rect::new(c as i32, r as i32, 1, 1)).unwrap();\n            }\n        }\n        \n        canvas.present();\n\n    'main: loop \n    {        \n        for event in event_pump.poll_iter() {\n            match event {\n                sdl2::event::Event::Quit {..} => break 'main,\n                _ => {},\n            }\n        }\n\n        sleep(Duration::new(0, 250000000));\n    }\n    \n}", "id": 174, "concepts": ["image rendering", "event handling", "SDL2 library", "generic type parameters"], "instruction": "Design a Rust class that displays a simple image. The class should be utilized by a main method that renders a random image of your choice and manages events from the user. The class should support displaying the image at a specified resolution, the ability to resize the image, and the ability to handle different types of input events as a user browses the image."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file removal, function composition, error propagation\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_remove_file(path: &str) -> Result<(), String> {\n    fs::remove_file(path).map_err(|e| e.to_string())\n}", "id": 175, "concepts": ["file removal", "function composition", "error propagation"], "instruction": "Develop a Rust function that recursively removes all files (and directories) within a specified directory path. If encountering a file that is not allowed (e.g., a hidden file), the function should raise an exception."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: fuzzing, file input, fuzz target, generic function input\n\n### Task", "fingerprint": null, "seed": "fn run_a_few_inputs() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_few\");\n\n    let project = project(\"run_a_few_inputs\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_few\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() != 4);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"pass-0\"), \"\")\n        .file(corpus.join(\"pass-1\"), \"1\")\n        .file(corpus.join(\"pass-2\"), \"12\")\n        .file(corpus.join(\"pass-3\"), \"123\")\n        .file(corpus.join(\"fail\"), \"fail\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_few\")\n        .arg(corpus.join(\"pass-0\"))\n        .arg(corpus.join(\"pass-1\"))\n        .arg(corpus.join(\"pass-2\"))\n        .arg(corpus.join(\"pass-3\"))\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Running 4 inputs 1 time(s) each.\").and(\n                predicate::str::contains(\"Running: fuzz/corpus/run_few/pass\"),\n            ),\n        )\n        .success();\n}", "id": 176, "concepts": ["fuzzing", "file input", "fuzz target", "generic function input"], "instruction": "Design a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands. Utilize fuzzing to generate test data that covers all edge cases, including corner cases, missing input, and invalid input."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call, native library interfacing, platform-specific system call functionality\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_active(target: CAddr) {\n    system_call(SystemCall::TaskSetActive {\n        request: target\n    });\n}", "id": 178, "concepts": ["system call", "native library interfacing", "platform-specific system call functionality"], "instruction": "Design a Rust function that uses the `system` system call to execute a shell command on the system. The function should provide clear error handling and logging to manage exceptions that might occur during the execution of the command."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: USART peripheral, SPI communication, synchronous I/O, bit operations\n\n### Task", "fingerprint": null, "seed": "fn usart_pc() {}", "id": 179, "concepts": ["USART peripheral", "SPI communication", "synchronous I/O", "bit operations"], "instruction": "Design a Rust program that uses the USART (Universal Synchronous and Asynchronous Receiver and Transmitter) peripheral of an STM32 microcontroller to communicate with a Bluetooth module over serial communication. The program should send and receive data via SPI communication in a synchronous manner. The program should handle different data transmission speeds as well as a fixed data rate. It should be able to send and receive arbitrary lengths of data. Include support for different baud rates and data bits.\n\nTo achieve high performance, the program should use bitwise operations to access the USART register file and implement bit shifts and arithmetic shifts to shift data into/out of the registers."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: struct declaration, struct copy, struct mutability, struct assignment\n\n### Task", "fingerprint": null, "seed": "fn copy_test() {\n    {\n        /*\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number); // error\n        */\n\n        #[derive(Copy, Clone)]\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number);\n\n        /*\n        #[derive(Copy, Clone)]\n        struct StringLabel {\n            name: String,\n        }\n        */\n    }\n}", "id": 180, "concepts": ["struct declaration", "struct copy", "struct mutability", "struct assignment"], "instruction": "Design a Rust function that accepts a `Recipe` struct and returns a new `Recipe` struct that is a copy of the original struct with a new name and list of ingredients. The new recipe should be mutable, which means it can be changed after the copy is made.\n\nThe function should define a `Recipe` struct with a name and ingredient list as fields. The function should also accept a `Recipe` struct as an argument and return a new `Recipe` struct that is a copy of the original struct with a new name and ingredient list. The new recipe should be mutable, which means it can be changed after the copy is made.\n\nThe function should also support the following assertions:\n\n```rust\nlet recipe = Recipe {\n    name: \"\".to_string(),\n    ingredients: vec![\"flour\".to_string(), \"salt\".to_string(), \"eggs\".to_string(), \"butter\".to_string()],\n};\n\nlet new_recipe = copy_recipe(&recipe);\n\nassert_eq!(new_recipe.name, \"\");\nassert_eq!(new_recipe.ingredients, vec![\"flour\".to_string(), \"salt\".to_string(), \"eggs\".to_string(), \"butter\".to_string()]);\n\n// After the copy is made, the original recipe can be changed\nnew_recipe.name = \"New Name\".to_string();\nnew_recipe.ingredients.push(\"sugar\".to_string());\n\nassert_eq!(recipe.name, \"\");\nassert_eq!(recipe.ingredients, vec![\"flour\".to_string(), \"salt\".to_string(), \"eggs\".to_string(), \"butter\".to_string()]);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: creating a file with a file descriptor, writing to a file with a file descriptor, error handling with exceptions\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_write(file_path: &str, contents: &str) -> Result<(), String> {\n    let mut file = File::create(file_path).map_err(|e| e.to_string())?;\n    file.write_all(contents.as_bytes())\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}", "id": 181, "concepts": ["creating a file with a file descriptor", "writing to a file with a file descriptor", "error handling with exceptions"], "instruction": "Create a Rust program that opens a file in a specified path and prints the contents of the file to the standard output. The file path should be passed as a command line argument."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: memory check, buffer reading, error handling in Rust, return value from function\n\n### Task", "fingerprint": null, "seed": "pub fn test_jump0() {\n    let buffer = fs::read(\"tests/programs/jump0_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"jump0_64\".into()]);\n    assert!(result.is_err());\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 185, "concepts": ["memory check", "buffer reading", "error handling in Rust", "return value from function"], "instruction": "Design a Rust function that takes a `path` to a text file as input and returns the first 1000 or less characters from the file as a `str`. If there are fewer than 1000 characters, return all of them. Handle any errors that occur during the execution of the function and return `None`.\n\nHint: This function should use a `try` block and `?` operator."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: conditional branching, error handling with return values, nested function composition\n\n### Task", "fingerprint": null, "seed": "fn build_author_map(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    match build_author_map_(repo, reviewers, mailmap, from, to) {\n        Ok(o) => Ok(o),\n        Err(err) => Err(ErrorContext(\n            format!(\n                \"build_author_map(repo={}, from={:?}, to={:?})\",\n                repo.path().display(),\n                from,\n                to\n            ),\n            err,\n        ))?,\n    }\n}", "id": 186, "concepts": ["conditional branching", "error handling with return values", "nested function composition"], "instruction": "Design a Rust function that takes two integers as arguments and returns their sum, product, or average, depending on the input arguments. If the user specifies an invalid input, the function should return `None` to indicate that an error occurred. The function should use a conditional branch to handle different cases, including cases where both inputs are negative and the user specifies an invalid operation type."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: conditional branching, panic handling, return value destructuring\n\n### Task", "fingerprint": null, "seed": "pub fn channel_take_raw(target: CAddr) -> u64 {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Raw(v) => return v,\n        _ => panic!(),\n    };\n}", "id": 187, "concepts": ["conditional branching", "panic handling", "return value destructuring"], "instruction": "Write a Rust program that takes input from the command line and returns the length of the longest word in the input. The input for the program should be a sentence or a phrase, with each word separated by a single space. The output should be the length of the longest word in the input. If the input does not contain any words, the program should return 0."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: database query execution, string deserialization from database table, list comprehension in function call, string comparison\n\n### Task", "fingerprint": null, "seed": "fn\ntest_str\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\n\"\nhello\nworld\n!\n\"\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\ns\n]\n)\n?\n;\nlet\nfrom\n:\nString\n=\ndb\n.\none_column\n(\n\"\nSELECT\nt\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nfrom\ns\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 189, "concepts": ["database query execution", "string deserialization from database table", "list comprehension in function call", "string comparison"], "instruction": "Design a Rust program that queries a database table for a list of names in the format \"FirstName LastName\" and provides a list of unique names in the same format. The program should handle cases where both first and last names are not provided or duplicated names are present in the table."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: fuzzing with libFuzzer, command line options, reading from test case files, string comparison, assertions, error handling\n\n### Task", "fingerprint": null, "seed": "fn tmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"i_hate_zed\");\n    let test_case = corpus.join(\"test-case\");\n    let project = project(\"tmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"i_hate_zed\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let s = String::from_utf8_lossy(data);\n                    if s.contains('z') {\n                        panic!(\"nooooooooo\");\n                    }\n                });\n            \"#,\n        )\n        .file(&test_case, \"pack my box with five dozen liquor jugs\")\n        .build();\n    let test_case = project.root().join(test_case);\n    project\n        .cargo_fuzz()\n        .arg(\"tmin\")\n        .arg(\"i_hate_zed\")\n        .arg(\"--sanitizer=none\")\n        .arg(&test_case)\n        .assert()\n        .stderr(\n            predicates::str::contains(\"CRASH_MIN: minimizing crash input: \")\n                .and(predicate::str::contains(\"(1 bytes) caused a crash\"))\n                .and(predicate::str::contains(\n                    \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\\n                     \\n\\\n                     Minimized artifact:\\n\\\n                     \\n\\\n                     \\tfuzz/artifacts/i_hate_zed/minimized-from-\"))\n                .and(predicate::str::contains(\n                    \"Reproduce with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz run --sanitizer=none i_hate_zed fuzz/artifacts/i_hate_zed/minimized-from-\"\n                )),\n        )\n        .success();\n}", "id": 191, "concepts": ["fuzzing with libFuzzer", "command line options", "reading from test case files", "string comparison", "assertions", "error handling"], "instruction": "Design a Rust function that takes two strings as arguments and returns whether they are anagrams of each other. An anagram is a rearrangement of the letters in a word or phrase to produce a new word or phrase. For example, 'cinema' is an anagram of 'iceman', but 'car' is not. The program should accept user input to determine whether two strings are anagrams.\n\nThis function is intended to be used within a fuzzing framework, such as libFuzzer, to generate test cases for the anagram-checking function.\n\n- Run the program in a command line interface (CLI) with the `--help` flag, and determine the required command-line options to run the program.\n- Write assertions to test the program's functionality.\n- Design a test case generator for the function based on the command-line options and error handling."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: array element access, random access, in-place sorting\n\n### Task", "fingerprint": null, "seed": "pub fn pivot<T: PartialOrd>(v: &mut [T]) -> usize {\n    let mut p = rand::read(v.len());\n    v.swap(p, 0);\n    p = 0;\n    for i in 1..v.len() {\n        if v[i] < v[p] {\n            // move our pivot forward 1, and put this element before it\n            v.swap(p+1, i);\n            v.swap(p, p+1);\n            p += 1\n        }\n    }\n    p\n}", "id": 194, "concepts": ["array element access", "random access", "in-place sorting"], "instruction": "Design a Rust function that takes an array of integers and returns a boolean value indicating whether an array is sorted in ascending order. Your function should be able to process arrays of up to a million elements in constant time.\n\nFor example, the following assertions are expected to pass:\n\n```rust\nassert_eq!(is_sorted(vec![1, 2, 3, 4, 5]), true);\nassert_eq!(is_sorted(vec![1, 10]), true);\nassert_eq!(is_sorted(vec![5, 4, 3, 2, 1]), false);\nassert_eq!(is_sorted(vec![10000, 1000, 100, 10, 1]), true);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: bitwise operations, bitmasks, bitwise comparison, bitwise logical operators\n\n### Task", "fingerprint": null, "seed": "fn active_entity(entity: Entity, world: &World) -> bool {\n    return world.masks[entity] & VOXEL_PASS_MASK == VOXEL_PASS_MASK;\n}", "id": 195, "concepts": ["bitwise operations", "bitmasks", "bitwise comparison", "bitwise logical operators"], "instruction": "Write a Rust function that takes an integer `x` as an argument and returns a new integer `y`, where `y` is a copy of `x` with the least significant bit set to 1."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async-await, blocking io, async io, error handling, try-catch, task-based concurrency\n\n### Task", "fingerprint": null, "seed": "fn main() -> ! {\n    let mut robot = init_peripherals(\n        stm32f446::Peripherals::take().unwrap(),\n        cortex_m::Peripherals::take().unwrap(),\n    );\n\n    init_servo(&mut robot);\n\n    let mut reader = TrameReader::new();\n\n    loop {\n        let b = block!(robot.pc_rx.read()).unwrap();\n        reader.step(b);\n        if let Some(trame) = reader.pop_trame() {\n            asm::bkpt();\n        }\n\n        /*\n        let mess = servos[0x05].stat();\n        for b in mess {\n            block!(robot.servo_tx.write(b)).unwrap();\n        }\n\n        robot.delay.delay_ms(70 as u16);\n*/\n        /*\n        if let Ok(byte) = pc_rx.read() {\n            reader.step(byte);\n        }\n        if let Some(trame) = reader.pop_trame() {\n            if let Some(sent) = handle_trame(trame) {\n                let (arr, size): ([u8; 15], usize) = sent.into();\n                for b in arr[0..size].iter() {\n                    block!(pc_tx.write(*b)).unwrap();\n                }\n            }\n        }*/\n    }\n}", "id": 196, "concepts": ["async-await", "blocking io", "async io", "error handling", "try-catch", "task-based concurrency"], "instruction": "Write a Rust program that simulates a simple web server using the asynchronous I/O API and a task-based concurrency model. The program should support multiple concurrent connections.\n\nThe program should run on a local port specified by the user at the command line. The program should serve the contents of the current directory over HTTP. The server should support the following HTTP methods:\n- GET: to request a resource from the server\n- POST: to send a data payload to the server\n\nThe server should use the `async-std` crate for asynchronous I/O operations, and `tokio` or `async-std` for task-based concurrency. The program should handle HTTP errors gracefully."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: string parsing, string manipulation, file reading, input validation with assertions, error handling\n\n### Task", "fingerprint": null, "seed": "fn read_num(cursor: &mut Cursor<Vec<u8>>) -> Result<u32, Box<std::error::Error>> {\n    let mut v: Vec<u8> = vec![];\n    let mut c: [u8; 1] = [0];\n\n    // consume whitespace\n    loop {\n        cursor.read(&mut c)?;\n        match &c {\n            b\" \" | b\"\\t\" | b\"\\n\" => { },\n              _                  => { cursor.seek(std::io::SeekFrom::Current(-1)); break; }\n        }\n    }\n\n    // read number\n    loop {\n        cursor.read(&mut c)?;\n        match c[0] {\n            b'0' ... b'9'        => { v.push(c[0]); },\n            b' ' | b'\\t' | b'\\n' => { cursor.seek(std::io::SeekFrom::Current(-1)); break; },\n              _                  => { bail!(\"Parse error\") }\n        }\n    }\n\n    let num_str = std::str::from_utf8(&v)?;\n    let num     = num_str.parse::<u32>()?;\n    Ok(num)\n}", "id": 197, "concepts": ["string parsing", "string manipulation", "file reading", "input validation with assertions", "error handling"], "instruction": "Design a Rust function that reads a text file line by line and increments each line of the file by 1. The function should handle errors gracefully, such as:\n- File opening,\n- File reading,\n- File closing, and\n- Error handling.\n\nThe function should accept the path to the file as a string input via the command line. The function should parse each line, increment it by 1, and write it back to the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: process execution, asynchronous i/o, terminal handling, process output retrieval, process status handling, error handling\n\n### Task", "fingerprint": null, "seed": "async fn run_manpage(_args: Args) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing manpage\");\n\n\tlet man = Man::new(Args::command().long_version(None));\n\tlet mut buffer: Vec<u8> = Default::default();\n\tman.render(&mut buffer).into_diagnostic()?;\n\n\tif std::io::stdout().is_terminal() && which::which(\"man\").is_ok() {\n\t\tlet mut child = Command::new(\"man\")\n\t\t\t.arg(\"-l\")\n\t\t\t.arg(\"-\")\n\t\t\t.stdin(Stdio::piped())\n\t\t\t.stdout(Stdio::inherit())\n\t\t\t.stderr(Stdio::inherit())\n\t\t\t.group()\n\t\t\t.kill_on_drop(true)\n\t\t\t.spawn()\n\t\t\t.into_diagnostic()?;\n\t\tchild\n\t\t\t.inner()\n\t\t\t.stdin\n\t\t\t.as_mut()\n\t\t\t.unwrap()\n\t\t\t.write_all(&buffer)\n\t\t\t.await\n\t\t\t.into_diagnostic()?;\n\n\t\tif let Some(code) = child\n\t\t\t.wait()\n\t\t\t.await\n\t\t\t.into_diagnostic()?\n\t\t\t.code()\n\t\t\t.and_then(|code| if code == 0 { None } else { Some(code) })\n\t\t{\n\t\t\treturn Err(miette::miette!(\"Exited with status code {}\", code));\n\t\t}\n\t} else {\n\t\tstd::io::stdout()\n\t\t\t.lock()\n\t\t\t.write_all(&buffer)\n\t\t\t.into_diagnostic()?;\n\t}\n\n\tOk(())\n}", "id": 198, "concepts": ["process execution", "asynchronous i/o", "terminal handling", "process output retrieval", "process status handling", "error handling"], "instruction": "Write a Rust program that executes a specified command line program (e.g., `ls -a`), and prints its output to the screen. Retrieve the output in a non-blocking and non-blocking manner."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: return value handling for error cases, conditional return, error handling for null values, string conversion from path\n\n### Task", "fingerprint": null, "seed": "pub fn get_home() -> Result<String, ()> {\n    match dirs::home_dir() {\n        None => Ok(String::new()),\n        Some(path) => Ok(path.to_str().unwrap().to_string()),\n    }\n}", "id": 199, "concepts": ["return value handling for error cases", "conditional return", "error handling for null values", "string conversion from path"], "instruction": "Design a Rust program that searches for all files in a specified directory recursively. The program should follow a strict directory structure with two directories: \"data\" and \"processed\". The program should search for all txt files in \"data\" and store the file names in a list. The program should then parse each txt file and write the parsed content to a new file with a .csv extension in the \"processed\" directory. The program should save the parsed content in the data structure that is appropriate for the task.\n\nThe program should print out a list of all the filenames that have been successfully parsed. If an error occurs during the parsing process, the program should display an error message, and if the file cannot be found, the program should print the file path."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string concatenation, text parsing, file loading, function parameter deconstruction, function return value reassignment\n\n### Task", "fingerprint": null, "seed": "fn loadImageFromMaterial(model: &mut Model, materialPath: &str) {\r\n    model.albedo_map = materialPath + \"_albedo.png\";\r\n    model.normal_map = materialPath + \"_normal.png\";\r\n    model.ambient_ligth = materialPath + \"_ao.png\";\r\n    model.roughness_map = materialPath + \"_rough.png\"\r\n}", "id": 201, "concepts": ["string concatenation", "text parsing", "file loading", "function parameter deconstruction", "function return value reassignment"], "instruction": "Design a Rust program that extracts and displays the name of the product in each line of the given file. The program should also print a count of how many lines were processed. The program should handle missing or empty lines gracefully, as well as empty or misformatted input."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string parsing, string manipulation, creation of an instance of a data structure from an external source, error handling in Rust\n\n### Task", "fingerprint": null, "seed": "fn mailmap_from_repo(repo: &git2::Repository) -> Result<Mailmap, Box<dyn std::error::Error>> {\n    let file = String::from_utf8(\n        repo.revparse_single(\"master\")?\n            .peel_to_commit()?\n            .tree()?\n            .get_name(\".mailmap\")\n            .unwrap()\n            .to_object(&repo)?\n            .peel_to_blob()?\n            .content()\n            .into(),\n    )?;\n    Mailmap::from_string(file)\n}", "id": 202, "concepts": ["string parsing", "string manipulation", "creation of an instance of a data structure from an external source", "error handling in Rust"], "instruction": "Design a Rust class that enables reading and parsing data from a remote URL in a structured format and storing it in an internal data structure. The class should support loading data from a remote URL and parsing it into a custom data structure. The class should handle error conditions gracefully and provide a means of communicating errors to the calling code.\n\nThe class should have a method `get_data()` that returns the internal data structure containing the parsed data. This method should be able to handle errors, such as invalid URLs, connectivity issues, or parsing errors. The class should also have a method `get_raw_data()` that returns the raw response data received from the remote URL, in its original format.\n\nThe class should be able to handle data responses in different formats or structures, such as JSON, CSV, or XML. It should be able to handle errors gracefully, such as invalid URLs or connectivity issues. Additionally, the class should be able to parse data from a remote URL and store it in an internal data structure.\n\nThe class should handle various error conditions gracefully and provide a means of communicating errors to the calling code. The class should be flexible and able to handle errors in any format or structure, and should be able to handle connectivity issues and invalid URLs. This class allows developers to work with structured data from a remote URL in a robust and efficient way."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: custom error type, error handling, conditional return, error type conversions\n\n### Task", "fingerprint": null, "seed": "pub fn force_reset() -> Result<(), ()> {\n    let mut configurator = Configurator::new();\n    configurator.force_reset();\n    Ok(())\n}", "id": 203, "concepts": ["custom error type", "error handling", "conditional return", "error type conversions"], "instruction": "Create a custom error type that includes a `description` and `context` fields. The `description` should be a string describing the error, and the `context` a dictionary that contains additional information. Implement a function that raises the custom error type with the `description` and `context` as its arguments, and add a conditional return statement that handles the raised error based on its `description`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: version string parsing, text parsing, conditional logic, error handling\n\n### Task", "fingerprint": null, "seed": "fn get_versions(repo: &Repository) -> Result<Vec<VersionTag>, Box<dyn std::error::Error>> {\n    let tags = repo\n        .tag_names(None)?\n        .into_iter()\n        .filter_map(|v| v)\n        .map(|v| v.to_owned())\n        .collect::<Vec<_>>();\n    let mut versions = tags\n        .iter()\n        .filter_map(|tag| {\n            Version::parse(&tag)\n                .or_else(|_| Version::parse(&format!(\"{}.0\", tag)))\n                .ok()\n                .map(|v| VersionTag {\n                    name: format!(\"Rust {}\", v),\n                    version: v,\n                    raw_tag: tag.clone(),\n                    commit: repo\n                        .revparse_single(&tag)\n                        .unwrap()\n                        .peel_to_commit()\n                        .unwrap()\n                        .id(),\n                    in_progress: false,\n                })\n        })\n        .collect::<Vec<_>>();\n    versions.sort();\n    Ok(versions)\n}", "id": 204, "concepts": ["version string parsing", "text parsing", "conditional logic", "error handling"], "instruction": "Develop a program that parses a version string into a tuple of integers. The version string is a string of the form `major.minor.patch` or `major.minor.patch-suffix`, where `major`, `minor`, and `patch` are integers, and `suffix` is an optional string of the format `optional.identifier`. The program should return a tuple of integers `(major, minor, patch)`.\n\nFor example, given the version string `1.2.3-alpha`, the function should return the tuple (1, 2, 3) for the major, minor, and patch values, respectively. Similarly, given the version string `1.2.3`, the function should return the tuple (1, 2, 3), even if the version string is missing the suffix.\n\nUse error handling to ensure that the function handles invalid inputs and returns `None` when the version string is missing required components."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: conditional parsing logic, string slicing and traversal, string parsing, array slicing and traversal, string comparison, string matching, string manipulation, array slicing and traversal, string sorting, array deduplication\n\n### Task", "fingerprint": null, "seed": "fn parse_bors_reviewer(\n    reviewers: &Reviewers,\n    repo: &Repository,\n    commit: &Commit,\n) -> Result<Option<Vec<Author>>, ErrorContext> {\n    if commit.author().name_bytes() != b\"bors\" || commit.committer().name_bytes() != b\"bors\" {\n        if commit.committer().name_bytes() != b\"GitHub\" || !is_rollup_commit(commit) {\n            return Ok(None);\n        }\n    }\n\n    // Skip non-merge commits\n    if commit.parents().count() == 1 {\n        return Ok(None);\n    }\n\n    let to_author = |list: &str| -> Result<Vec<Author>, ErrorContext> {\n        list.trim_end_matches('.')\n            .split(|c| c == ',' || c == '+')\n            .map(|r| r.trim_start_matches('@'))\n            .map(|r| r.trim_end_matches('`'))\n            .map(|r| r.trim())\n            .filter(|r| !r.is_empty())\n            .filter(|r| *r != \"<try>\")\n            .inspect(|r| {\n                if !r.chars().all(|c| {\n                    c.is_alphabetic() || c.is_digit(10) || c == '-' || c == '_' || c == '='\n                }) {\n                    eprintln!(\n                        \"warning: to_author for {} contained non-alphabetic characters: {:?}\",\n                        commit.id(),\n                        r\n                    );\n                }\n            })\n            .map(|r| {\n                reviewers.to_author(r).map_err(|e| {\n                    ErrorContext(\n                        format!(\"reviewer: {:?}, commit: {}\", r, commit.id()),\n                        e.into(),\n                    )\n                })\n            })\n            .flat_map(|r| r.transpose())\n            .collect::<Result<Vec<_>, ErrorContext>>()\n    };\n\n    let message = commit.message().unwrap_or(\"\");\n    let mut reviewers = if let Some(line) = message.lines().find(|l| l.contains(\" r=\")) {\n        let start = line.find(\"r=\").unwrap() + 2;\n        let end = line[start..]\n            .find(' ')\n            .map(|pos| pos + start)\n            .unwrap_or(line.len());\n        to_author(&line[start..end])?\n    } else if let Some(line) = message.lines().find(|l| l.starts_with(\"Reviewed-by: \")) {\n        let line = &line[\"Reviewed-by: \".len()..];\n        to_author(&line)?\n    } else {\n        // old bors didn't include r=\n        if message != \"automated merge\\n\" {\n            panic!(\n                \"expected reviewer for bors merge commit {} in {:?}, message: {:?}\",\n                commit.id(),\n                repo.path(),\n                message\n            );\n        }\n        return Ok(None);\n    };\n    reviewers.sort();\n    reviewers.dedup();\n    Ok(Some(reviewers))\n}", "id": 205, "concepts": ["conditional parsing logic", "string slicing and traversal", "string parsing", "array slicing and traversal", "string comparison", "string matching", "string manipulation", "array slicing and traversal", "string sorting", "array deduplication"], "instruction": "Develop a Rust function that takes a string as input and returns the longest prefix that is not a palindrome. The function should return the prefix that is the shortest, in a case-insensitive manner. If there are multiple prefixes that meet this condition, return the lexicographically smaller one.\n\nFor example, given the string \"abAbaab\", the function should return the substring \"abAba\" (the prefix \"abAba\" is not a palindrome)."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file system operations, file creation, file deletion, file path manipulation, conditional file existence check\n\n### Task", "fingerprint": null, "seed": "fn build_one() {\n    let project = project(\"build_one\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_b\")\n        .assert()\n        .success();\n\n    // Build to ensure that the build directory is created and\n    // `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n    let a_bin = build_dir.join(\"build_one_a\");\n    let b_bin = build_dir.join(\"build_one_b\");\n\n    // Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    // Test that we can build one and not the other.\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n\n    assert!(a_bin.is_file());\n    assert!(!b_bin.is_file());\n}", "id": 206, "concepts": ["file system operations", "file creation", "file deletion", "file path manipulation", "conditional file existence check"], "instruction": "Create a Rust class called `File` that represents a file in the operating system. The class should have the following properties:\n\n- `self.path`: a string representing the path to the file.\n- `self.size`: an integer representing the size of the file in bytes.\n- `self.is_hidden`: a boolean flag indicating whether the file is hidden or not.\n- `self.is_read_only`: a boolean flag indicating whether the file is read-only.\n- `self.is_empty`: a boolean flag indicating whether the file is empty or not.\n\nThe class should also have the following methods:\n\n- `self.read()`: a method that reads the contents of the file and returns a string representing the contents.\n- `self.write(content: str)`: a method that writes the `content` to the file.\n- `self.append(content: str)`: a method that appends the `content` to the end of the file.\n- `self.delete()`: a method that deletes the file from the file system.\n\nThe class should be able to handle errors such as file not found, access denied, or invalid file path, and should ensure that the file operations are not performed on hidden or read-only files."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: time-based calculation, floating-point arithmetic, conditional branching, conditional variable usage\n\n### Task", "fingerprint": null, "seed": "fn docker_metric_entry_from_two_stats(time_diff: Duration, first: InstantDockerContainerMetricEntry, second: InstantDockerContainerMetricEntry) -> DockerContainerMetricEntry {\n    let diff = time_diff.num_milliseconds() as f64 / 1000.0; // seconds\n\n    DockerContainerMetricEntry {\n        name: second.name,\n        state: second.state,\n\n        cpu_usage: ((second.cpu_usage - first.cpu_usage) as f64 / (second.system_cpu_usage - first.system_cpu_usage) as f64) / diff,\n\n        memory_usage: second.memory_usage,\n        memory_cache: second.memory_cache,\n\n        network_tx: (second.network_tx - first.network_tx) as f64 / diff,\n        network_rx: (second.network_rx - first.network_rx) as f64 / diff\n    }\n}", "id": 207, "concepts": ["time-based calculation", "floating-point arithmetic", "conditional branching", "conditional variable usage"], "instruction": "Create a program that counts the number of seconds between two given time intervals, based on the time of day in the 24-hour format (e.g., 6:30 pm vs. 10:30 am). The solution should calculate the exact number of seconds between the two times and add 1 to the result if the second time is later than the first. For example, `18:30:00 19:30:00` should return 600 seconds, and `23:00:00 01:00:00` should return 79200 seconds."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: database connection, database query, empty vector initialization, assertion\n\n### Task", "fingerprint": null, "seed": "fn\ntest_empty_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nempty\n=\nvec\n!\n[\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nempty\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nempty\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 209, "concepts": ["database connection", "database query", "empty vector initialization", "assertion"], "instruction": "Develop a Rust function to connect to a PostgreSQL database and retrieve data from a table using the 'SELECT' query. The function should accept a table name and return a vector of rows from the table. If the table does not exist, the function should return an empty vector. Write assertions to check that the table name is a valid string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: checking file existence, file metadata access, file conversion to boolean\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_is_file(path: &str) -> bool {\n    fs::metadata(path)\n        .map(|metadata| metadata.is_file())\n        .unwrap_or(false)\n}", "id": 210, "concepts": ["checking file existence", "file metadata access", "file conversion to boolean"], "instruction": "Create a Rust function to check whether a given file name exists in the current directory. The function should return a boolean value based on the existence of the file. The function should also return a tuple of `(file_name, exists)` where `file_name` is the input string and `exists` is a boolean value representing the existence of the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: pattern matching, error handling, functional programming in Rust, trait implementation for Result types\n\n### Task", "fingerprint": null, "seed": "fn map_params(tok: IRCToken) -> Result<IRCToken, ~str> {\n    // Sequence(~[Sequence(~[Sequence(~[Ignored, Unparsed(~\"##codelab\")])]), Sequence(~[Sequence(~[Ignored, Unparsed(~\":\"), Unparsed(~\"hi\")])])])\n    match tok {\n        Sequence(args) => Ok(Params(args.map(|arg| {\n            match arg.clone() {\n                Sequence([Sequence([Ignored, Unparsed(param)])]) => param,\n                Sequence([Sequence([Ignored, Unparsed(~\":\"), Unparsed(param)])]) => param,\n                _ => ~\"\"\n            }\n        }))),\n        _ => Err(~\"Malformed parameters\")\n    }\n}", "id": 211, "concepts": ["pattern matching", "error handling", "functional programming in Rust", "trait implementation for Result types"], "instruction": "Develop a Rust class that implements a simple calculator. The class should support various arithmetic operations such as addition, subtraction, multiplication, division, and mod. The class should handle errors such as division by zero and invalid operands.\n\nThe class should provide a simple REPL environment for users to enter expressions, such as `1 + 1 * 2` or `10 / 2`. The REPL should parse the input expression into tokens, and then evaluate the expression using the following rules:\n\n- Operators such as '+' and '*' are supported.\n- Operands are integers represented as strings.\n- Expressions can be nested, such as `1 + 1 * 2`.\n- The expression can contain whitespace characters to improve readability, such as `1 + 1 * 2  `.\n- The operator symbols must be surrounded by spaces to distinguish them from operands, such as `1 + 1 * 2`.\n- Expressions can be surrounded by parentheses, such as `(1 + 1) * 2`.\n- Parentheses can be nested, such as `((1 + 1) * 2) + 1`.\n- Operators with the same precedence are processed from left to right.\n- Invalid expressions are reported as syntax errors and the calculator does not continue processing.\n- The calculator should handle division by zero and invalid operands and report the appropriate errors.\n\nThe class should provide an interface for users to evaluate expressions. The interface should receive the input expression in the form of a string as an argument and return the evaluation result as a `Result<i32, String>`. If the expression is valid, the result should be an `Option<i32>`. Otherwise, it should return an error message indicating the type of error and the location within the input string where the error occurred.\n\nThe class should provide a `main()` function that provides a simple REPL environment where users can enter expressions and receive the evaluation results."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: mutating a slice, default parameter initialization in functions, input validation for parameter types\n\n### Task", "fingerprint": null, "seed": "fn get_disjoint<T>(ts: &mut [T], a: usize, b: usize) -> (&mut T, &mut T) {\n    assert!(a != b, \"a ({}) and b ({}) must be disjoint\", a, b);\n    assert!(a < ts.len(), \"a ({}) is out of bounds\", a);\n    assert!(b < ts.len(), \"b ({}) is out of bounds\", b);\n    if a < b {\n        let (al, bl) = ts.split_at_mut(b);\n        (&mut al[a], &mut bl[0])\n    } else {\n        let (bl, al) = ts.split_at_mut(a);\n        (&mut al[0], &mut bl[b])\n    }\n}", "id": 212, "concepts": ["mutating a slice", "default parameter initialization in functions", "input validation for parameter types"], "instruction": "Implement a Rust program that reads an integer array from the command line and returns the average value of all odd elements. Provide clear error handling and logging for invalid user input."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: function application in functional programming, functional programming in Rust, trait implementation for function application\n\n### Task", "fingerprint": null, "seed": "pub fn ap(f: Value, arg: Value) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::Apply(f, arg),\n        computed: false,\n    }))\n}", "id": 213, "concepts": ["function application in functional programming", "functional programming in Rust", "trait implementation for function application"], "instruction": "Design a Rust function `add_n_to_all` that takes a list of numbers and adds the same number `n` to each of them. The function should be implemented as a trait `AddN` that can be applied to a list of numbers. The trait should also allow for the addition of an arbitrary number `n` to each number in the list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: system call function, system call Rust module\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_instruction_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetInstructionPointer {\n        request: (target, ptr),\n    });\n}", "id": 214, "concepts": ["system call function", "system call Rust module"], "instruction": "Write a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\nFor example, this program should read the text file `/tmp/command.txt` and execute its commands successfully:\n\n```bash\n/usr/bin/chmod 755 /tmp/command.txt\n/usr/bin/chown root:root /tmp/command.txt\n/usr/bin/ls -l /tmp/command.txt\n/usr/bin/cat /tmp/command.txt\n/usr/bin/rm /tmp/command.txt\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: thread communication, synchronization primitives, Rust ownership model, ownership of shared state\n/Text_Programming_Concepts/README.md\n# Text Programming Concepts Exercises\n\nThis repository contains exercise solutions for:\n\n- [Text Programming Concepts](https://github.com/denniskuenzi/Text_Programming_Concepts)\n\n## Solutions\n\n#\n\n### Task", "fingerprint": null, "seed": "pub fn channel_put<T: Any + Clone>(target: CAddr, value: T) {\n    system_call_put_payload(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Payload)\n    }, value);\n}", "id": 216, "concepts": ["thread communication", "synchronization primitives", "Rust ownership model", "ownership of shared state\n/Text_Programming_Concepts/README.md\n# Text Programming Concepts Exercises\n\nThis repository contains exercise solutions for:\n\n- [Text Programming Concepts](https://github.com/denniskuenzi/Text_Programming_Concepts)\n\n## Solutions\n\n#"], "instruction": "Design a Rust function that takes a string and returns the length of the longest substring that is composed of unique characters.\n\nFor example, given the input \"abcabcabc\", the function should return 3."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: file reading, line iteration, Rust match statement, input validation with assertions\n/Text_Programming_Concepts/README.md\n# Text Programming Concepts Exercises\n\nThis repository contains exercise solutions for:\n\n- [Text Programming Concepts](https://github.com/denniskuenzi/Text_Programming_Concepts)\n\n## Solutions\n\n#\n\n### Task", "fingerprint": null, "seed": "fn parse_file(file_name: &str) -> Vec<Instruction> {\n    let f = File::open(file_name).expect(\"Could not open the specified file.\");\n    let reader = BufReader::new(f);\n    \n    reader\n        .lines()\n        .map(|lr| lr.expect(\"Could not read a line.\"))\n        .map(|l| parse_instruction(&l))\n        .collect()\n}", "id": 222, "concepts": ["file reading", "line iteration", "Rust match statement", "input validation with assertions\n/Text_Programming_Concepts/README.md\n# Text Programming Concepts Exercises\n\nThis repository contains exercise solutions for:\n\n- [Text Programming Concepts](https://github.com/denniskuenzi/Text_Programming_Concepts)\n\n## Solutions\n\n#"], "instruction": "1\n### Properties\ncategory: class implementation\nlanguage: Python\ndifficulty: easy\nconcepts: class composition, basic string formatting, string interpolation, string formatting with placeholders\n\n### Task\nWrite a Python class called `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: Rust's boxing, Rc, RefCell, Value, Value_ enum, BTreeMap, mutex, environment variable access, conditional compilation\n\n### Task", "fingerprint": null, "seed": "pub fn b(b: BuiltIn) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::BuiltIn(b),\n        computed: true,\n    }))\n}", "id": 223, "concepts": ["Rust's boxing", "Rc", "RefCell", "Value", "Value_ enum", "BTreeMap", "mutex", "environment variable access", "conditional compilation"], "instruction": "Create a Rust function `is_prime_number` that determines whether an integer is prime. The function should use the Sieve of Eratosthenes algorithm to determine if a number is prime."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: Rust's const function, ptr::null, ptr::null_mut, no-op\n\n### Task", "fingerprint": null, "seed": "const fn null_ble_gatt_svc_def() -> ble_gatt_svc_def {\n    return ble_gatt_svc_def {\n        type_: BLE_GATT_SVC_TYPE_END as u8,\n        uuid: ptr::null(),\n        includes: ptr::null_mut(),\n        characteristics: ptr::null(),\n    };\n}", "id": 224, "concepts": ["Rust's const function", "ptr::null", "ptr::null_mut", "no-op"], "instruction": "Design a Rust class `SharedContext` with two methods, `new_shared_context` and `get_context`, that both accept a function `f` as an argument. The `new_shared_context` method should store the given function in a field and return a shared pointer to this function. The `get_context` method should return the stored function, and generate a new shared pointer if necessary.\n\nThe `main` function should create a new shared context and use the `get_context` method to retrieve the stored function. It should then call the function with no arguments and print the returned value.\n\n### Gist\nhttps://gist.github.com/eric255/f0559859136dc155163178f0f59b629a"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: Rust's boxing, error handling, two-phase construction, SQLite transactions, SQLite database management\n\n### Task", "fingerprint": null, "seed": "fn\nchecked_memory_handle\n(\n)\n-\n>\nResult\n<\nConnection\n>\n{\nlet\ndb\n=\nConnection\n:\n:\nopen_in_memory\n(\n)\n?\n;\ndb\n.\nexecute_batch\n(\n\"\nCREATE\nTABLE\nfoo\n(\nb\nBLOB\nt\nTEXT\ni\nINTEGER\nf\nFLOAT\nn\n)\n\"\n)\n?\n;\nOk\n(\ndb\n)\n}", "id": 225, "concepts": ["Rust's boxing", "error handling", "two-phase construction", "SQLite transactions", "SQLite database management"], "instruction": "Implement a Rust class named `Notes` that supports adding, deleting, and searching for notes in a SQLite database. The class should have the following methods:\n- `add_note(title, body)`: adds a new note to the database with the specified title and body text, returning a unique ID for the note\n- `delete_note(id)`: deletes the note with the specified ID from the database\n- `search_notes(query)`: searches for notes matching the specified query string and returns a list of matching IDs\n\nThe class should also handle error conditions and validate user input. For example, `add_note(title, body)` should check if the title is already present in the database and return an error if so. To ensure data integrity, the class should use transactions to perform database operations."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: using the Window API, opening a window's devtools\n\n### Task", "fingerprint": null, "seed": "pub fn open_devtools(window: Window) {\n    window.open_devtools()\n}", "id": 226, "concepts": ["using the Window API", "opening a window's devtools"], "instruction": "Implement a Rust function that creates a new window of specified width and height and opens its DevTools. The function should receive the dimensions as input parameters and return the handle of the window object."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: Rust-specific system call, print function, byte array manipulation\n\n### Task", "fingerprint": null, "seed": "pub fn print(buffer: [u8; 32], size: usize) {\n    let _ = system_call(SystemCall::Print {\n        request: (buffer, size)\n    });\n}", "id": 227, "concepts": ["Rust-specific system call", "print function", "byte array manipulation"], "instruction": "Implement a Rust function that prints a list of integers as a string with each integer separated by commas, beginning and ending with brackets. The function should take a single argument that is a list of integers. You can use the `print!` macro similar to Python's `print` function to print the list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: fuzz tests, fuzzing directory creation, fuzzing build, fuzzing run\n\n### Task", "fingerprint": null, "seed": "fn run_with_different_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\n        \"project_likes_to_move_it\",\n        Some(\"dir_likes_to_move_it_move_it\"),\n    );\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"you_like_to_move_it\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|_data: &[u8]| {\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"you_like_to_move_it\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 2 runs\"))\n        .success();\n}", "id": 228, "concepts": ["fuzz tests", "fuzzing directory creation", "fuzzing build", "fuzzing run"], "instruction": "Implement a Rust class that creates a new directory called `fuzz_test_dir` and copies the contents of the `fuzz_test_dir` directory into the newly created `fuzz_test_dir`. The class should also create a similar `fuzz_build_dir` and a `fuzz_run_dir` and run the fuzz testing with these directories. Include error handling for invalid inputs.\n\nFor example, if the `fuzz_test_dir` is not a directory in the current working directory, the class should raise an error."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: OS-level file system operations, Git repository operations, locking and mutability of variables, string manipulation, IO operations, refactor, conditional mutation of values\n\n### Task", "fingerprint": null, "seed": "fn update_repo(url: &str) -> Result<PathBuf, Box<dyn std::error::Error>> {\n    let mut slug = url;\n    let prefix = \"https://github.com/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let prefix = \"git://github.com/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let prefix = \"https://git.chromium.org/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let suffix = \".git\";\n    if slug.ends_with(suffix) {\n        slug = &slug[..slug.len() - suffix.len()];\n    }\n\n    let path_s = format!(\"repos/{}\", slug);\n    let path = PathBuf::from(&path_s);\n    if !UPDATED.lock().unwrap().insert(slug.to_string()) {\n        return Ok(path);\n    }\n    if path.exists() {\n        if should_update() {\n            // we know for sure the path_s does *not* contain .git as we strip it, so this is a safe\n            // temp directory\n            let tmp = format!(\"{}.git\", path_s);\n            std::fs::rename(&path, &tmp)?;\n            git(&[\n                \"clone\",\n                \"--bare\",\n                \"--dissociate\",\n                \"--reference\",\n                &tmp,\n                &url,\n                &path_s,\n            ])?;\n            std::fs::remove_dir_all(&tmp)?;\n        }\n    } else {\n        git(&[\"clone\", \"--bare\", &url, &path_s])?;\n    }\n    Ok(path)\n}", "id": 231, "concepts": ["OS-level file system operations", "Git repository operations", "locking and mutability of variables", "string manipulation", "IO operations", "refactor", "conditional mutation of values"], "instruction": "Implement a class that supports the file system operations like `ls`, `cd`, `mkdir`, `touch`, `rm`, `vim` and `cat`. Given the path to a file, the class should be able to return the content of the file if it exists. The class should also have a `home` variable that stores the absolute path to the user's top-level directory."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async function execution, window creation, renderer creation, window and renderer execution\n\n### Task", "fingerprint": null, "seed": "pub fn init(\n    src: String,\n    dst: String,\n    width: u32,\n) -> std::io::Result<()> {\n    let mut logger = env_logger::Builder::new();\n    logger.init();\n\n    let mut window = Window::new((width, 200)).unwrap();\n    let mut popup = Popup::new(width, window.hidpi);\n    let mut renderer = popup.get_renderer(&mut window.handle);\n    window.run(&mut popup, &mut renderer);\n\n    Ok(())\n}", "id": 232, "concepts": ["async function execution", "window creation", "renderer creation", "window and renderer execution"], "instruction": "Implement a Rust program that creates a window with a renderer, and handles user-input events such as window resizing and user-input key presses. The user should be able to exit the program by pressing the \"ESC\" key, similar to the game \"Tetris\".\n\nWrite a Rust program that creates a window with a renderer, and handles user-input events such as window resizing and user-input key presses. The user should be able to exit the program by pressing the \"ESC\" key, similar to the game \"Tetris\"."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async function call, file system read/write/delete, error handling\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_remove_dir(path: &str) -> Result<(), String> {\n    fs::remove_dir_all(path).map_err(|e| e.to_string())\n}", "id": 234, "concepts": ["async function call", "file system read/write/delete", "error handling"], "instruction": "Develop a Rust function that reads from a file and replaces a phrase with a new phrase, within a given time limit. If the file is locked, the function should wait and re-check until the file becomes available again. Write assertions to ensure the method works as expected. The function should also return a `Result` object to confirm the outcome."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: conditional branching, file existence checking, string manipulation, project management\n\n### Task", "fingerprint": null, "seed": "fn add_twice() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"could not add target\")\n                .and(predicate::str::contains(\"File exists (os error 17)\")),\n        )\n        .failure();\n}", "id": 235, "concepts": ["conditional branching", "file existence checking", "string manipulation", "project management"], "instruction": "Develop a Rust function that reads a Git repository and returns a list of all the files that have not been committed yet. The function should recursively search for files in the given repository, and should only return the paths of files relative to the repository root.\n\nThe function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo1\"),\n    vec![\"testfile1.txt\", \"testfile2.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo1/subrepo1\"),\n    vec![\"testfile3.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo2\"),\n    vec![\"testfile1.txt\", \"testfile2.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo2/subrepo1\"),\n    vec![\"testfile3.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo2/subrepo2\"),\n    vec![\"testfile4.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo3\"),\n    vec![\"testfile1.txt\", \"testfile2.txt\", \"testfile3.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo3/subrepo1\"),\n    vec![\"testfile4.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo3/subrepo2\"),\n    vec![\"testfile4.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo4\"),\n    vec![\"testfile1.txt\", \"testfile2.txt\", \"testfile3.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo4/subrepo1\"),\n    vec![\"testfile4.txt\"]\n);\nassert_eq!(\n    get_uncommitted_files_list(\"tests/repo4/subrepo2\"),\n    vec![\"testfile4.txt\"]\n);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: async function execution, async runtime, async monad, traits and associated functions, async trait, async function call\n\n### Task", "fingerprint": null, "seed": "async fn init() -> Nash {\n    dotenv().ok();\n\n    let parameters = NashParameters {\n        credentials: Some(NashCredentials {\n            secret: env::var(\"NASH_API_SECRET\").unwrap(),\n            session: env::var(\"NASH_API_KEY\").unwrap(),\n        }),\n        environment: Environment::Sandbox,\n        client_id: 1,\n        timeout: 1000,\n    };\n\n    OpenLimits::instantiate(parameters).await\n}", "id": 237, "concepts": ["async function execution", "async runtime", "async monad", "traits and associated functions", "async trait", "async function call"], "instruction": "Develop a Rust function that takes two integers `a` and `b` and returns the result of `a + b`. The function should execute asynchronously, using the `tokio` runtime, and return a `Future` with a type of `u32`. Utilize the `async` and `await` keywords to implement the function."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: async/await syntax, futures, async monad, traits\n\n### Task", "fingerprint": null, "seed": "async fn get_historic_trades() {\n    let exchange = init().await;\n    let req = GetHistoricTradesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        paginator: Some(Paginator {\n            limit: Some(100),\n            ..Default::default()\n        }),\n    };\n    let resp = exchange.get_historic_trades(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 238, "concepts": ["async/await syntax", "futures", "async monad", "traits"], "instruction": "Develop a Rust function that takes two arguments: `a`, a list of integers, and `b`, a list of integer ranges. The function should return a list of integers, the product of all the integers in `a` that are not present in any of the ranges in `b`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: bitwise arithmetic operations, binary arithmetic, monadic composition, asserts\n\n### Task", "fingerprint": null, "seed": "fn align_to(size: uint, align: uint) -> uint {\n\t    assert!(align != 0);\n\t\t    (size + align - 1) & !(align - 1)\n}", "id": 239, "concepts": ["bitwise arithmetic operations", "binary arithmetic", "monadic composition", "asserts"], "instruction": "Develop a Rust program that reads two 32-bit integers, `x` and `y`, from a binary file, adds `x` and `y`, and writes the result to the same file. The program should take two command-line arguments, `input_file` and `output_file`, denoting the names of the input and output files, respectively. The program should raise an error if the input file does not exist or if the input file is not a valid binary file, or if the input file is not a 32-bit integer."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file I/O, error handling, string parsing\n\n### Task", "fingerprint": null, "seed": "pub fn acrn_read(file_path: &str) -> Result<String, String> {\n    let mut file = File::open(file_path).map_err(|e| e.to_string())?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)\n        .map_err(|e| e.to_string())?;\n    Ok(contents)\n}", "id": 240, "concepts": ["file I/O", "error handling", "string parsing"], "instruction": "Write a Rust function that reads from a file line by line and extracts the rows that match a given regular expression. The function should return a list of matching rows or an empty list if there are no matching rows. In addition to the file name and the regular expression, the function should also take a flag `invert` to determine whether the opposite logic (return non-matching rows) should be used."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: tuple unpacking, string splitting, string indexing\n\n### Task", "fingerprint": null, "seed": "fn tuple_test() {\n    let text = \"I see the eigenvalue in thine eye\";\n    let (head, tail) = text.split_at(21);\n    assert_eq!(head, \"I see the eigenvalue \");\n    assert_eq!(tail, \"in thine eye\");\n}", "id": 242, "concepts": ["tuple unpacking", "string splitting", "string indexing"], "instruction": "Develop a Rust function that takes two arguments: `s`, a string; and `n`, an integer. The function should split the string into words and rearrange the word order so that the first word becomes the last word. Each word is separated by a space in the original string. The function should return the new string.\n\nFor example, given the input `s = \"We wish to rearrange our words so that the first word becomes the last one.\"` and `n = 2`, the function should return `s = \"rearrange our words so that the first word becomes the last one. We\"`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call and stdin/stdout process communication, parsing command output, string manipulation, option handling, list comprehension\n\n### Task", "fingerprint": null, "seed": "pub async fn dump_wifi_passwords() -> Option<WifiLogins> {\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    let mut wifi_logins = WifiLogins::new();\n\n    let list_of_process = String::from_utf8_lossy(&output.stdout);\n    for line in list_of_process.lines() {\n        if line\n            .to_lowercase()\n            .contains(obfstr::obfstr!(\"all user profile\"))\n            && line.contains(\":\")\n        {\n            let ssid = line.split(':').nth(1)?.trim();\n            let profile = get_wifi_profile(ssid).await?;\n            for pline in profile.lines() {\n                if pline\n                    .to_lowercase()\n                    .contains(obfstr::obfstr!(\"key content\"))\n                    && pline.contains(\":\")\n                {\n                    let key = pline.split(\": \").nth(1)?;\n                    wifi_logins.insert(ssid.to_string(), key.to_string());\n                }\n            }\n        }\n    }\n\n    Some(wifi_logins)\n}", "id": 243, "concepts": ["system call and stdin/stdout process communication", "parsing command output", "string manipulation", "option handling", "list comprehension"], "instruction": "Develop a Rust program that reads from standard input and prints to standard output. The program should process the standard input line by line, and print the output of each command in the standard output. The program should handle the following exceptions:\n\n- IOError: An error occurred while reading from or writing to standard input or output.\n- ValueError: The command output is invalid.\n- SyntaxError: The command output cannot be parsed as JSON, or the JSON object cannot be parsed as a dictionary."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call, function signature, process communication\n\n### Task", "fingerprint": null, "seed": "pub fn channel_put_raw(target: CAddr, value: u64) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Raw(value))\n    });\n}", "id": 244, "concepts": ["system call", "function signature", "process communication"], "instruction": "Create a Rust program that creates two processes, `A` and `B`. The program should pass a message from `A` to `B` and print the result."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call implementation, dynamic memory allocation, mutable and non-mutable references\n\n### Task", "fingerprint": null, "seed": "fn system_call_take_payload<T: Any + Clone>(message: SystemCall) -> (SystemCall, T) {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        system_call_raw();\n\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &*payload_addr;\n        assert!(buffer.payload_length != 0 && buffer.payload_length == size_of::<T>());\n\n        (buffer.call.take().unwrap(), payload_data.clone())\n    }\n}", "id": 245, "concepts": ["system call implementation", "dynamic memory allocation", "mutable and non-mutable references"], "instruction": "Create a Rust function `malloc(size)` that allocates and returns a pointer to a region of memory of size `size` bytes. The function should dynamically allocate memory using the Rust implementation of the `mmap` system call and return a pointer to the allocated memory. The function should handle the case when `size` is 0 or when there is an error from the system call. Include error handling to manage invalid inputs such as negative size or memory allocation errors."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: creating a new column in the tree view, accessing its attributes, adding cells to the column, adding the column to the tree view\n\n### Task", "fingerprint": null, "seed": "fn append_text_column(tree: &mut gtk::TreeView) {\n    let column = gtk::TreeViewColumn::new().unwrap();\n    let cell = gtk::CellRendererText::new().unwrap();\n\n    column.pack_start(&cell, true);\n    column.add_attribute(&cell, \"text\", 0);\n    tree.append_column(&column);\n}", "id": 246, "concepts": ["creating a new column in the tree view", "accessing its attributes", "adding cells to the column", "adding the column to the tree view"], "instruction": "Write a Rust function that creates a column in the tree view in the `Qt`, and manipulates its attributes and data. Utilize the `Vec` to store the column names and their corresponding values. Additionally, create a new column named `Class` and add it to the tree view. Ensure the function handles invalid inputs such as empty column names or duplicate column names."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: system call and assembly\n\n### Task", "fingerprint": null, "seed": "unsafe fn system_call_raw() {\n    asm!(\"int 80h\"\n         ::\n         : \"rax\", \"rbx\", \"rcx\", \"rdx\",\n         \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n         : \"volatile\", \"intel\");\n}", "id": 247, "concepts": ["system call and assembly"], "instruction": "Create a Rust function to validate the correctness of a password by checking it against a set of rules:\n\n- The password must meet the requirements specified by the password policy, which consists of a minimum length and at least one uppercase letter and one number.\n- The password must not contain the username.\n- The password must not contain any common words.\n\nThe function should accept a password string and return a boolean value indicating whether the password is valid or not. The password policy is defined as a set of regular expressions that are checked against the password in a loop, and the function returns true only when all the regular expressions match."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: struct initialization and field initialization, iterator usage in loops, conditional branches based on types, field access, order of operations\n\n### Task", "fingerprint": null, "seed": "pub fn parse(raw: &str) -> Option<game::Game> {\n    let game_raw: GameRaw = serde_json::from_str(raw).ok()?;\n\n    let even_initial_timelines = game_raw\n        .timelines\n        .iter()\n        .any(|tl| tl.index == -0.5 || tl.index == 0.5);\n\n    let min_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .min_by_key(|x| (*x) as isize)?;\n    let max_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .max_by_key(|x| (*x) as isize)?;\n\n    let timeline_width = ((-min_timeline).min(max_timeline) + 1.0).round();\n    let active_timelines = game_raw.timelines\n        .iter()\n        .filter(|tl| tl.index.abs() <= timeline_width);\n    let present = active_timelines\n        .map(|tl| tl.begins_at + (tl.states.len() as isize) - 1)\n        .min()?;\n\n    let mut res = game::Game::new(game_raw.width, game_raw.height);\n\n    res.info.present = present;\n    res.info.min_timeline = de_l(min_timeline, even_initial_timelines);\n    res.info.max_timeline = de_l(max_timeline, even_initial_timelines);\n    res.info.active_player = game_raw.active_player;\n    res.info.even_initial_timelines = even_initial_timelines;\n\n    for tl in game_raw.timelines.into_iter() {\n        res.timelines.insert(\n            de_l(tl.index, even_initial_timelines),\n            de_timeline(tl, even_initial_timelines),\n        );\n    }\n\n    Some(res)\n}", "id": 248, "concepts": ["struct initialization and field initialization", "iterator usage in loops", "conditional branches based on types", "field access", "order of operations"], "instruction": "Create a Rust function to validate a list of `Vec3`s (from a 3D vector space) as a set of non-intersecting polygons. A polygon is considered valid if it has three or more vertices and doesn't share a vertex with another polygon.\n\nFor example, given the following vector space:\n```\n[\n  Vec3([0.0, 0.0, 0.0]),\n  Vec3([1.0, 1.0, 0.0]),\n  Vec3([0.0, 1.0, 0.0]),\n  Vec3([0.0, 0.0, 1.0]),\n]\n```\nThe function should return `true` since the polygon set has no non-intersecting edges (the edges of the polygon are all distinct).\n\nGiven the following vector space:\n```\n[\n  Vec3([0.0, 0.0, 0.0]),\n  Vec3([1.0, 1.0, 0.0]),\n  Vec3([0.0, 1.0, 0.0]),\n  Vec3([0.0, 0.0, 1.0]),\n  Vec3([0.0, 1.0, 1.0]),\n]\n```\nThe function should return `false` since the polygon set does have a non-intersecting edge."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: async/await syntax, error handling, I/O with futures\n\n### Task", "fingerprint": null, "seed": "async fn get_historic_rates() {\n    let exchange = init().await;\n    let req = GetHistoricRatesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        interval: Interval::OneHour,\n        paginator: None,\n    };\n    let resp = exchange.get_historic_rates(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 249, "concepts": ["async/await syntax", "error handling", "I/O with futures"], "instruction": "Construct a Rust async function `get_stock_prices(ticker: &str)` that fetches the current stock price from a real-time stock price service. The function should return the current price as a floating-point value in USD. It should handle both network error and invalid ticker. Ensure that the function returns a `Result<f32, String>` type."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: channel communication, thread sleep, shared-memory concurrency, channel buffering\n\n### Task", "fingerprint": null, "seed": "fn handle_task(client: &mut Client, main_out_c: Sender<String>) {\n    let (channel_out, channel_in) = unbounded();\n    let task_types = TaskCommandTypes::new();\n\n    // walk over the task queue. For any task_queue.state == 0, handle it.\n    for task in &mut client.task_queue {\n        // all tasks will have at least 1 iteration, but may have more. We also may have a sleep\n        // between iterations\n        let duration = (task.iteration_delay * 1000) as u64;\n        let sleep_duration = time::Duration::from_millis(duration);\n        for _iteration in 0..task.iterations {\n            let task_type = task_types.determine_task_type(task.command_type);\n            if task_type == \"filesystem\" {\n                // start the filesystem thread and go go go\n                let out_c = channel_out.clone();\n                filesystem::handle_filesystem(task, out_c);\n                task.state = 1;\n            }\n            // peek into the channel from our thread to see if there is data\n            // if there is, send it back\n            if let Ok(resp_from_thread) = channel_in.try_recv() {\n                println!(\"handle_task got something: {}\", &resp_from_thread);\n                // should send the task ID back out if successful. Otherwise, an err string\n                main_out_c.send(resp_from_thread).unwrap();\n                task.state = 2;\n            }\n            thread::sleep(sleep_duration);\n        }\n    }\n}", "id": 250, "concepts": ["channel communication", "thread sleep", "shared-memory concurrency", "channel buffering"], "instruction": "Create a Rust class that implements a simple semaphore with a single channel. The class should be able to allow a thread to acquire a semaphore (a permit) by waiting for the semaphore to be available, and allows another thread to release a semaphore (a permit) after it has done its work. Ensure the thread can acquire the semaphore only if the semaphore is available."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: error handling, serialization and deserialization, error handling with error messages\n\n### Task", "fingerprint": null, "seed": "fn serializer(msg: String) -> Result<Task, Error> {\n    let v = match serde_json::from_str::<Task>(&msg){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}", "id": 251, "concepts": ["error handling", "serialization and deserialization", "error handling with error messages"], "instruction": "Write a Rust function that transforms JSON data into a Python dictionary. The input data is a valid JSON string. Each JSON object consists of key-value pairs, where the keys are strings and the values can be any data type (e.g., integer, string, list, or dictionary). The function should return a Python dictionary with the same structure and values.\n\nFor example, given the following JSON input:\n\n```json\n{\n\t\"name\": \"\",\n\t\"age\": 26,\n\t\"address\": {\n\t\t\"city\": \"New York\",\n\t\t\"state\": \"NY\"\n\t},\n\t\"hobbies\": [\"music\", \"reading\", \"travelling\"]\n}\n```\n\nThe function should return the following Python dictionary:\n\n```python\n{\n\t'name': '',\n\t'age': 26,\n\t'address': {\n\t\t'city': 'New York',\n\t\t'state': 'NY'\n\t},\n\t'hobbies': ['music', 'reading', 'travelling']\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: string formatting, conditional string concatenation, number incrementation\n\n### Task", "fingerprint": null, "seed": "fn project_with_fuzz_dir(\n    project_name: &str,\n    fuzz_dir_opt: Option<&str>,\n) -> (String, ProjectBuilder) {\n    let fuzz_dir = fuzz_dir_opt.unwrap_or(\"custom_dir\");\n    let next_root = next_root();\n    let fuzz_dir_pb = next_root.join(fuzz_dir);\n    let fuzz_dir_sting = fuzz_dir_pb.display().to_string();\n    let pb = project_with_params(project_name, next_root, fuzz_dir_pb);\n    (fuzz_dir_sting, pb)\n}", "id": 252, "concepts": ["string formatting", "conditional string concatenation", "number incrementation"], "instruction": "Create a Rust function that takes a string as input and returns the string converted to camel case, where each word is capitalized and spaces are removed. The function should handle both single- and multi-word inputs.\n\nFor example, given the input \"hello world\", the function should return \"HelloWorld\"."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: binary code serialization, unsafe code execution, panic handling, error handling\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    std::panic::set_hook(Box::new(console_error_panic_hook::hook));\n    console_log::init_with_level(log::Level::Warn).expect(\"could not initialize logger\");\n\n    let fighter_bytes = include_bytes!(\"subaction_data.bin\");\n    let subaction = bincode::deserialize(fighter_bytes).unwrap();\n    wasm_bindgen_futures::spawn_local(render_window_wasm(subaction));\n}", "id": 253, "concepts": ["binary code serialization", "unsafe code execution", "panic handling", "error handling"], "instruction": "Create a Rust function that converts a decimal integer to its binary representation. The function should handle negative numbers as well. For instance, `to_binary(12)` should return `1100`, while `to_binary(-12)` should return the string `11111111111111111111111111111100`.\n\nThe challenge is to design the function so that it handles negative integers properly without implementing the conversion to a string first."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: CLI parsing, function composition, default arguments\n\n### Task", "fingerprint": null, "seed": "fn main() {}", "id": 254, "concepts": ["CLI parsing", "function composition", "default arguments"], "instruction": "Create a Rust function that parses CLI arguments in a command-line interface (CLI) for a calculator. The function should accept two inputs, `a` and `b`, and return the sum of the two. The function should be able to accept integer or float values for `a` and `b`, and handle string and boolean input."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation, unsigned integer comparison, number alignment, type definition\n\n### Task", "fingerprint": null, "seed": "fn is_aligned(value: usize, alignment: usize) -> bool {\n    (value & (alignment - 1)) == 0\n}", "id": 255, "concepts": ["bitwise operation", "unsigned integer comparison", "number alignment", "type definition"], "instruction": "Create a Rust function that reverses an unsigned integer in the bit representation. You should implement an efficient algorithm that does not involve any additional data structures or indices, and should work for any input value. You should use bitwise operators such as `<<` and `>>` to manipulate bits, and the `is_power_of_two` method to check if a given number is a power of two."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: spawn child threads, sleeping functionality, number conversion, channel communication\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    // let name = String::from(\"rust\");\n    let mut client = Client::new();\n\n    // now loop forever getting tasks every now and then\n    let duration = (&client.interval * 1000.0) as u64;\n\n    let sleep_duration = time::Duration::from_millis(duration);\n\n    let (channel_out, channel_in) = unbounded();\n    // sleep for duration given by server, every interval wake up and ask for new tasks\n    loop {\n        thread::sleep(sleep_duration);\n\n        // get new tasks from the server\n        // need to return success/failure so we know if we should send something into the thread or not\n        client.get_task();\n        // fuck me\n        let mut c = client.clone();\n        let out_c = channel_out.clone();\n        // spawn a thread to deal with the new tasks\n        let thread_hndl = thread::spawn(move || {\n            handle_task(&mut c, out_c);\n        });\n        if let Ok(resp_from_thread) = channel_in.try_recv() {\n            println!(\"yayyy from main {}\", &resp_from_thread);\n            // need to send resp to server, and remvoe task from the queue\n            let resp_task_id = resp_from_thread.parse::<i32>().unwrap();\n            client.task_queue.retain(|x| x.task_id != resp_task_id);\n        }\n    }\n}", "id": 256, "concepts": ["spawn child threads", "sleeping functionality", "number conversion", "channel communication"], "instruction": "Create a Rust program that spawns multiple child threads that perform the following tasks:\n\n- Sleep for a specified amount of time\n- Convert a number from base 10 to base 2\n- Pass the resulting number to a main thread\n\nThe main thread should wait for each child to finish, then read and print the binary representation of the number. The final result should be a string that contains all the binary representations received from the child threads joined by a space, like so:\n\n```\n0 0 1 1 0 1 1 1 1 1 1 0 1 1 1 0\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: database interaction using SQLite, database interaction using SQLite with parameterized data, list comprehension, list extension, conditional list comprehension\n\n### Task", "fingerprint": null, "seed": "fn\ntest_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nv1234\n=\nvec\n!\n[\n1u8\n2\n3\n4\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nv1234\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nv1234\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 257, "concepts": ["database interaction using SQLite", "database interaction using SQLite with parameterized data", "list comprehension", "list extension", "conditional list comprehension"], "instruction": "Create a Rust class that interacts with an SQLite database. The class should be initialized with a path to an SQLite database file, and have methods that are used to query the database. The class should support the following operations:\n- query for all rows in a table\n- query for rows with specific selection criteria\n- insert new rows into the table\n- delete rows from the table\n\nThe methods should return the results in the form of a list of tuples."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: command execution using `Command` builder, `Output` value and `status` check, `std::error::Error` implementation\n\n### Task", "fingerprint": null, "seed": "fn git(args: &[&str]) -> Result<String, Box<dyn std::error::Error>> {\n    let mut cmd = Command::new(\"git\");\n    cmd.args(args);\n    cmd.stdout(Stdio::piped());\n    let out = cmd.spawn();\n    let mut out = match out {\n        Ok(v) => v,\n        Err(err) => {\n            panic!(\"Failed to spawn command `{:?}`: {:?}\", cmd, err);\n        }\n    };\n\n    let status = out.wait().expect(\"waited\");\n\n    if !status.success() {\n        eprintln!(\"failed to run `git {:?}`: {:?}\", args, status);\n        return Err(std::io::Error::from(std::io::ErrorKind::Other).into());\n    }\n\n    let mut stdout = Vec::new();\n    out.stdout.unwrap().read_to_end(&mut stdout).unwrap();\n    Ok(String::from_utf8_lossy(&stdout).into_owned())\n}", "id": 258, "concepts": ["command execution using `Command` builder", "`Output` value and `status` check", "`std::error::Error` implementation"], "instruction": "Create a Rust function that executes a system command and returns its output as a string. The function should use the `Command` builder from the `std::process` module to create a command object from the system command string and the `Output` type to read the output from the command. The function should include a check to ensure the command executed successfully and return an error if not."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: system call function, tuple deconstruction, function argument passing\n\n### Task", "fingerprint": null, "seed": "pub fn task_set_cpool(target: CAddr, cpool: CAddr) {\n    system_call(SystemCall::TaskSetCPool {\n        request: (target, cpool),\n    });\n}", "id": 259, "concepts": ["system call function", "tuple deconstruction", "function argument passing"], "instruction": "Create a Rust function that calls the system `date` command to retrieve the current date. Extract the day and month values from the output of the command, and return them as a tuple of integers."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: hashmap and hashmap mutability, value type, value data type, value traits, value conversions, value comparisons\n\n### Task", "fingerprint": null, "seed": "fn a_table_should_read_0_for_any_key() {\n  let mut table = HashMapOfTreeMap::new();\n  let mut vs = [Value::default(); 1];\n  table.read (0, &[0], &mut vs);\n  match vs {\n    [Value { v: 0, t: 0}] => (),\n    _ => assert!(false)\n  }\n}", "id": 260, "concepts": ["hashmap and hashmap mutability", "value type", "value data type", "value traits", "value conversions", "value comparisons"], "instruction": "Design a Rust class that stores a collection of key-value pairs where the key and value are both integers. The key is an identifier that is unique within the class. The value is a string representation of another integer. Provide functions that retrieve values given a key or keys, and that add a new value to the collection."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: async function execution, query building with SQLx, database access with SQLx\n\n### Task", "fingerprint": null, "seed": "async fn save_metric_entry(mut database: &Database, hostname: &str, timestamp: &DateTime<Utc>, entry: DockerContainerMetricEntry) -> Result<(), MetricSaveError> {\n    sqlx::query!(\n        \"insert into metric_docker_containers (hostname, timestamp, name, state, cpu_usage, memory_usage, memory_cache, network_tx, network_rx) values ($1, $2, $3, $4, $5, $6, $7, $8, $9) returning name\",\n        hostname.to_string(), *timestamp, entry.name, entry.state, entry.cpu_usage, entry.memory_usage as i64, entry.memory_cache as i64, entry.network_tx, entry.network_rx\n    ).fetch_one(&mut database).await?;\n\n    Ok(())\n}", "id": 261, "concepts": ["async function execution", "query building with SQLx", "database access with SQLx"], "instruction": "Implement a Rust function that takes a SQL query as a string, executes it, and returns the results as a vector of rows. The function should work asynchronously, using the `async` feature of Rust. It should be built using the [sqlx](https://docs.rs/sqlx/latest/sqlx/) crate to handle database connectivity. The output should be a vector of rows in the format of a `HashMap` where the keys are column names and the values are column values."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: enum pattern matching, function composition\n\n### Task", "fingerprint": null, "seed": "fn map_ignored(_: IRCToken) -> Result<IRCToken, ~str> {\n    Ok(Ignored)\n}", "id": 262, "concepts": ["enum pattern matching", "function composition"], "instruction": "Design a Rust function to evaluate a boolean expression given as an infix string expression. The expression contains only the operators `and`, `or`, `not`. The operator precedence is `and` > `or` > `not`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: string comparison and manipulation, bag-of-character approach\n\n### Task", "fingerprint": null, "seed": "fn find_common_id() -> Option<String> {\n    let input = fs::File::open(\"input.txt\")\n        .expect(\"Something went wrong reading the file\");\n    let reader = io::BufReader::new(input);\n    let mut box_ids: Vec<String> = reader.lines().map(|l| l.unwrap()).collect();\n    box_ids.sort();\n\n    for i in 0..box_ids.len() {\n        let mut diff = 0;\n        if i != box_ids.len() - 1 {\n            for (a, b) in box_ids[i].chars().zip(box_ids[i+1].chars()) {\n                if a != b {\n                    diff += 1;\n                }\n            }\n            if diff == 1 {\n                return Some(get_common_chars(&box_ids[i], &box_ids[i+1]));\n            }\n        }\n    }\n    None\n}", "id": 263, "concepts": ["string comparison and manipulation", "bag-of-character approach"], "instruction": "Design a Rust class `RideMatching` for ride matching. This class should support two main operations:\n- `add_ride(self, customer: str, destination: str, ride_time: float)`: adds a new ride to the list of rides with the details of the customer, destination, and ride time.\n- `find_rides(self, customer: str)`: finds all the rides matching the customer ID and returns them as a list of tuples (destination, ride_time).\n\nThe class should also support additional operations that are used in the actual matching process. These operations are:\n- `get_matched_ride(self, customer: str)`: finds a ride from the list of all rides and returns it.\n- `get_unmatched_rides(self)`: returns a list of all unmatched rides.\n- `unmatch_ride(self, ride: str)`: removes a ride from the list of all rides and returns it.\n\nThe class should also handle errors as appropriate, such as when the customer ID is not found in the list of rides or when the ride is not found among all the unmatched rides."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: hashmap and hashmap iteration, guarded execution, time measurements, floating point accuracy\n\n### Task", "fingerprint": null, "seed": "fn main() {\n\n  let nhits = 20;\n  let ntrials = 2000;\n  let nnanos = 60 * 1000 * 1000 * 1000;\n  let ntransfers = 1000;\n  let nbrokers = 8;\n  let tolerance = 0.05;\n  let ops = (ntransfers * nbrokers) as f64;\n  let million = (1000 * 1000) as f64;\n\n  let mut sum = 0.0;\n\n  let mut hits = 0;\n  let mut trial = 0;\n  let limit = time::precise_time_ns() + nnanos;\n  while hits < nhits && trial < ntrials && time::precise_time_ns() < limit {\n    let mut table = HashMapOfTreeMap::new();\n    let start = time::precise_time_ns();\n    for _ in 0..nbrokers {\n      broker(&mut table, ntransfers);\n    }\n    let end = time::precise_time_ns();\n    let ns = (end - start) as f64;\n    let x = ops / ns * million;\n    sum += x;\n    let n = (trial + 1) as f64;\n    let mean = sum / n;\n    let dev = (x - mean).abs() / mean;\n    if dev <= tolerance {\n      println!(\"{:5} {:8.2} ops/ms ({:8.2})\", trial, x, mean);\n      hits += 1;\n    }\n    trial += 1;\n  }\n}", "id": 264, "concepts": ["hashmap and hashmap iteration", "guarded execution", "time measurements", "floating point accuracy"], "instruction": "Implement a Rust function `find_missing_number` that finds the first missing non-negative integer in an array of non-negative integers. Ensure that the function uses a hashmap to store the presence of each number, and that it measures the function's time complexity."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 8\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: deserialization of a JSON string, error handling, JSON parsing\n\n### Task", "fingerprint": null, "seed": "fn desearlizer_client(req: &mut reqwest::Response) -> Result<Client, Error> {\n    let mut buffer = String::new();\n    match req.read_to_string(&mut buffer) {\n        Ok(_) => (),\n        Err(e) => println!(\"error : {}\", e.to_string())\n    };\n    println!(\"buffer before serializaztion: {}\", buffer);\n\n    let v = match serde_json::from_str::<Client>(&buffer){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}", "id": 265, "concepts": ["deserialization of a JSON string", "error handling", "JSON parsing"], "instruction": "Design a Rust class that takes a JSON string as input and returns a dictionary of its key-value pairs. The JSON string argument may contain arrays or nested objects, but the output dictionary should not.\n\nThe class should handle parsing of strings and converting them to proper data types, including handling errors such as missing or invalid JSON syntax or malformed JSON strings."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n### Task\nImplement a Rust program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.\n\nFor example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: initialization of a servo and its operations, usage of an iterator, writing data to a servo, reading data from a servo\n\n### Task", "fingerprint": null, "seed": "fn init_servo(robot: &mut Robot) {\n    let servos = ServoManager::new();\n\n    let m2 = servos[0xFE].reboot();\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    for _ in 0..5 {\n        robot.delay.delay_ms(70 as u32);\n    }\n\n    let m2 = servos[0xFE].ram_write(WritableRamAddr::AckPolicy(2));\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    let m1 = servos[0xFE].enable_torque();\n\n    for b in m1 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n}", "id": 267, "concepts": ["initialization of a servo and its operations", "usage of an iterator", "writing data to a servo", "reading data from a servo"], "instruction": "Design a Rust program that initializes a servo motor and controls it using the [servo-rs](https://docs.rs/servo-rs/0.2.0/servo_rs/) crate. The program should provide functions that allow setting the servo position to a specific angle, changing the servo speed, or querying the current position of the servo. The output should include information about the position of the servo and the current speed of the motor, as well as error handling and logging for exceptions."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: cargo package management, executing cargo commands, process spawning, writing to files\n\n### Task", "fingerprint": null, "seed": "fn init() {\n    let project = project(\"init\").build();\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"fuzz_target_1\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}", "id": 269, "concepts": ["cargo package management", "executing cargo commands", "process spawning", "writing to files"], "instruction": "Design a Rust function to run a cargo command. The function should take a string argument, `command`, that represents the cargo argument and options. The function should run the cargo command using ProcessBuilder.spawn(). The function should write the standard output and standard error to a temporary file, and return the file path to the caller."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: slice initialization, type conversions, Rust's bytemuck crate, buffer creation with device and queue\n\n### Task", "fingerprint": null, "seed": "fn create_mesh_buffer_verts(\n    chunk: &Chunk,\n    device: &wgpu::Device,\n    queue: &wgpu::Queue,\n) -> MeshBufferVerts {\n    // Calculate total length of buffer e.g. a full chunk of different voxels. This way a new buffer only has to be created when the voxel capacity is changed.\n\n    let verts = Mesh::verts(chunk);\n    let vert_len = verts.len();\n\n    let single_cube_verts = Mesh::cube_verts().len();\n    let single_cube_color_verts = (single_cube_verts / 3) * std::mem::size_of::<PaletteIndexType>(); // One PaletteIndexType per 3 verts\n\n    let max_voxels = {\n        let (x, y, z) = chunk.capacity();\n        x * y * z\n    };\n\n    let max_buf_size =\n        (single_cube_verts + single_cube_color_verts) * max_voxels * std::mem::size_of::<f32>();\n\n    let buffer = device.create_buffer(&wgpu::BufferDescriptor {\n        label: None,\n        mapped_at_creation: false,\n        size: max_buf_size as u64,\n        usage: wgpu::BufferUsage::VERTEX | wgpu::BufferUsage::COPY_DST,\n    });\n\n    if vert_len > 0 {\n        queue.write_buffer(&buffer, 0, bytemuck::cast_slice(&verts));\n    }\n\n    MeshBufferVerts {\n        buffer,\n        vert_len,\n        max_capacity: chunk.capacity(),\n    }\n}", "id": 270, "concepts": ["slice initialization", "type conversions", "Rust's bytemuck crate", "buffer creation with device and queue"], "instruction": "Create a Rust class that represents a two-dimensional array with data types that can be accessed or modified by a slice. The class should have methods that implement the following operations:\n\n* `fill(value)` fills the array with `value`\n* `fill_diagonal(value)` fills the main diagonal with `value`, and the rest with `0`\n* `fill_triangular(value)` fills the upper triangular part with `value`, and the lower triangular part with `0`\n* `is_lower_triangular()` returns `true` if the matrix is lower triangular; otherwise `false`\n* `is_symmetric()` returns `true` if the matrix is symmetric; otherwise `false`\n* `is_diag_dominant()` returns `true` if the matrix is diagonally dominant; otherwise `false`\n* `is_sym_diag_dominant()` returns `true` if the matrix is symmetric and diagonally dominant; otherwise `false`"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 3\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: hashmap, nested and recursive data structure access, mutable reference usage\n\n### Task", "fingerprint": null, "seed": "fn a_table_should_read_and_write_batches() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }, Row { k: 1, v: 2 }]);\n  let mut vs = [Value::default(); 2];\n  table.read (1, &[0, 1], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }, Value { v: 2, t: 1 }]);\n}", "id": 271, "concepts": ["hashmap", "nested and recursive data structure access", "mutable reference usage"], "instruction": "Create a Rust class that represents a two-dimensional array with data types that can be accessed or modified by a key pair of coordinates in the form of an integer. The class should also provide a method for reading the entire array as a list of strings.\n\nThe key of a coordinate pair in the class should be a tuple of integers, where the first integer represents the row index and the second integer represents the column index. The value of a coordinate pair should be a string that represents the data stored at that coordinate.\n\nThe class should have the following properties and methods:\n- `get_keys`: A method that returns a list of keys in the form of tuples of integers. Each key represents a coordinate pair.\n- `get(x)`: A method that returns the value at a given coordinate pair. The input argument should be a tuple of integers, where the first integer represents the row index and the second integer represents the column index.\n- `set(x, value)`: A method that sets the value at a given coordinate pair. The input arguments should be a tuple of integers, where the first integer represents the row index and the second integer represents the column index, and a string representing the value to be set.\n- `list`: A method that returns a list of strings, where each string represents a row of the array as a single string.\n\nFor example, given the following two-dimensional array with three rows and four columns:\n\n```rust\n[[\"a\", \"b\", \"c\", \"d\"], [\"e\", \"f\", \"g\", \"h\"], [\"i\", \"j\", \"k\", \"l\"]]\n```\n\nThe class should provide the following functionality:\n\n```rust\nlet arr = TwoDimensionalArray::from_list(vec![\n    vec![\"a\", \"b\", \"c\", \"d\"],\n    vec![\"e\", \"f\", \"g\", \"h\"],\n    vec![\"i\", \"j\", \"k\", \"l\"],\n]);\nassert_eq!(arr.get_keys(), vec![(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]);\nassert_eq!(arr.get((0, 1)), \"b\");\nassert_eq!(arr.get((1, 2)), \"k\");\nassert_eq!(arr.list(), vec![\"a b c d\", \"e f g h\", \"i j k l\"]);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: random number generation, memory access check, error handling with assertions\n\n### Task", "fingerprint": null, "seed": "fn assert_memory_load_bytes<R: Rng, M: Memory>(\n    rng: &mut R,\n    memory: &mut M,\n    buffer_size: usize,\n    addr: u64,\n) {\n    let mut buffer_store = Vec::<u8>::new();\n    buffer_store.resize(buffer_size, 0);\n    rng.fill(buffer_store.as_mut_slice());\n\n    memory\n        .store_bytes(addr, &buffer_store.as_slice())\n        .expect(\"store bytes failed\");\n\n    let buffer_load = memory\n        .load_bytes(addr, buffer_store.len() as u64)\n        .expect(\"load bytes failed\")\n        .to_vec();\n\n    assert!(buffer_load.cmp(&buffer_store).is_eq());\n\n    // length out of bound\n    let outofbound_size = if buffer_store.is_empty() {\n        memory.memory_size() + 1\n    } else {\n        buffer_store.len() + memory.memory_size()\n    };\n    let ret = memory.load_bytes(addr, outofbound_size as u64);\n    assert!(ret.is_err());\n    assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n\n    // address out of bound\n    let ret = memory.load_bytes(\n        addr + memory.memory_size() as u64 + 1,\n        buffer_store.len() as u64,\n    );\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok())\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n\n    // addr + size is overflow\n    let ret = memory.load_bytes(addr + (0xFFFFFFFFFFFFFF - addr), buffer_store.len() as u64);\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok());\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n}", "id": 272, "concepts": ["random number generation", "memory access check", "error handling with assertions"], "instruction": "Create a Rust class `RandomNumberGenerator` that provides access to random numbers. The class should generate random numbers using the standard Python `random` module.\n\nThe class should also provide a `check_memory` method that returns `true` if the random number generator is initialized in memory, `false` if it is initialized in a file. Random number generation can be disabled by setting the `memory_initialization` attribute to false.\n\nThe class should raise a `RuntimeError` when random number generation is disabled and the generator is accessed."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: unsafe code, global variables, input validation\n\n### Task", "fingerprint": null, "seed": "pub fn set_working_folder(working_folder: String) -> Result<(), ()> {\n    unsafe {\n        WORKING_FOLDER = working_folder;\n    }\n    Ok(())\n}", "id": 273, "concepts": ["unsafe code", "global variables", "input validation"], "instruction": "Create a Rust class `SecureCalculator` that offers advanced tools for performing arithmetic operations on a given number. The class should maintain an internal state that is initially 0. The class should support adding, subtracting, multiplying, and dividing the state with the provided number. The class should support checking the current value of the state and managing memory safety through only allowing values between 0 and 255. All the member functions are communicated through a central method: `apply_operation(self, operation: str, num: int)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Addition: `apply_operation(\"add:\", 10)`\n- Subtraction: `apply_operation(\"sub:\", 25)`\n- Multiplication: `apply_operation(\"mul:\", 2)`\n- Division: `apply_operation(\"div:\", 2)`\n\nThe class should handle erroneous inputs gracefully, such as invalid inputs like negative numbers or non-integer values. Additionally, implement the `__str__` method to return a formatted string showing the current value of the state and a list of operations that have been applied to it."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: file system access, file read operations, file iteration, file read into memory, file seek, reading a file into memory\n\n### Task", "fingerprint": null, "seed": "fn main() \n{\n    let args: Vec<String> = std::env::args().collect();\n\n    if args.len() < 2 {\n        eprintln!(\"Syntax: {} <filename>\", args[0]);\n        return;\n    }\n\n    let path    = Path::new(&args[1]);\n    let display = path.display();\n\n    let mut file = match File::open(&path)    {\n        Err(why) => panic!(\"Could not open file: {} (Reason: {})\", \n            display, why.description()),\n        Ok(file) => file\n    };\n\n    // read the full file into memory. panic on failure\n    let mut raw_file = Vec::new();\n    file.read_to_end(&mut raw_file).unwrap();\n\n    // construct a cursor so we can seek in the raw buffer\n    let mut cursor = Cursor::new(raw_file);\n    let mut image  = match decode_ppm_image(&mut cursor) {\n        Ok (img) => img,\n        Err(why) => panic!(\"Could not parse PPM file - Desc: {}\", why.description()),\n    };\n\n    show_image(&image);\n}", "id": 274, "concepts": ["file system access", "file read operations", "file iteration", "file read into memory", "file seek", "reading a file into memory"], "instruction": "Create a Rust function that returns a list of the files with specific extensions in the current working directory. The function should accept the following arguments: `path`, which is a string representing the path of the directory to search; `extension`, which is a string specifying the extension of the files to return, without the dot (.) character. Try to implement the function using only standard library functions."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: string manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n### Task\nCreate a concise Rust function that transforms a string into a list of individual items. The input string contains a list of items separated by commas and the last item preceded by an optional \"and\". For example:\n- Input: \"Eeeny, Meeny, Miney, Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"Eeeny, Meeny, Miney, and Moe\" --> Output: ['Eeeny', 'Meeny', 'Miney', 'Moe']\n- Input: \"San Francisco and San Mateo\" --> Output: ['San Francisco', 'San Mateo']\nRemove any leading or trailing whitespace.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: result value handling, database operations, error handling, assertion\n\n### Task", "fingerprint": null, "seed": "fn\ntest_value\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\ni\n)\nVALUES\n(\n?\n1\n)\n\"\n[\nValue\n:\n:\nInteger\n(\n10\n)\n]\n)\n?\n;\nassert_eq\n!\n(\n10i64\ndb\n.\none_column\n:\n:\n<\ni64\n>\n(\n\"\nSELECT\ni\nFROM\nfoo\n\"\n)\n?\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 275, "concepts": ["result value handling", "database operations", "error handling", "assertion"], "instruction": "Design a function that retrieves product information from a database using the data in a `Product` struct. The function should utilize the following fields: `name`, `price`, `discount`, `quantity` wherein the `discount` field should be a percentage. The function should return a `Result` type where the first element is an `Option` of the `Product` struct.\n\nThe function should handle the following scenarios:\n- The product does not exist in the database. The function should return a `Err` with an appropriate error message.\n- The price is negative. The function should return a `Err` with an appropriate error message.\n- The quantity is negative. The function should return a `Err` with an appropriate error message.\n- The discount is not in the range of [0, 1]. The function should return a `Err` with an appropriate error message.\n\nThe function should handle erroneous inputs gracefully, such as negative values for `price` and `discount`, and negative values for `quantity`. Additionally, implement the `__str__` method to return a formatted string showing the product details."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: low-level memory manipulation, error handling, type checking\n\n### Task", "fingerprint": null, "seed": "pub fn test_load_elf_crash_64() {\n    let buffer = fs::read(\"tests/programs/load_elf_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"load_elf_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 276, "concepts": ["low-level memory manipulation", "error handling", "type checking"], "instruction": "Create a function `sort_by_length` that takes a list of strings as input and returns a new list where the strings in the original list are sorted by length. If multiple strings have the same length, they are sorted in the order of their first appearance (i.e., `['a', 'aa']` is considered to be the same as `'aa', 'a'` for sorting purposes).\n\nUse assertions to ensure the input type is a list of strings. The function should return a new sorted list that is not simply sorted by in-place sorting. A solution can make use of a helper function `sort_by`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: deserialization using the serde library, error handling, string to JSON conversion with serde_json\n\n### Task", "fingerprint": null, "seed": "fn desearlizer_task(req: &mut reqwest::Response) -> Result<Task, Error> {\n    let mut buffer = String::new();\n    match req.read_to_string(&mut buffer) {\n        Ok(_) => (),\n        Err(e) => println!(\"error : {}\", e.to_string())\n    };\n    println!(\"buffer before serializaztion: {}\", buffer);\n\n    let v = match serde_json::from_str::<Task>(&buffer){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}", "id": 277, "concepts": ["deserialization using the serde library", "error handling", "string to JSON conversion with serde_json"], "instruction": "Create a function `from_json(json_str)` that accepts a JSON string as input and returns a dictionary representation of the JSON data. Use the `serde` library for JSON serialization and deserialization. If the input is not a valid JSON string, the function should return a `ValueError` with a descriptive message."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a Rust function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```rust\nassert_eq!(\n        create_folds_list(&(0..12).collect::<Vec<_>>(), 2),\n        vec![(0..6).collect::<Vec<_>>(), (6..12).collect::<Vec<_>>()]\n    );\n    assert_eq!(\n        create_folds_list(&(0..8).collect::<Vec<_>>(), 2),\n        vec![(0..4).collect::<Vec<_>>(), (4..8).collect::<Vec<_>>()]\n    );\n    assert_eq!(create_folds_list(&(0..25).collect::<Vec<_>>(), -5), vec![]);\n    assert_eq!(\n        create_folds_list(&(0..6).collect::<Vec<_>>(), 2),\n        vec![(0..3).collect::<Vec<_>>(), (3..6).collect::<Vec<_>>()]\n    );\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: hashmap usage, map iteration, tuple unpacking, vector computation\n\n### Task", "fingerprint": null, "seed": "pub fn star1(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let (&sleepiest_guard_id, sleepiest_guard_days) = guard_map.iter()\n        .max_by_key(|(_, v)| v.iter()\n            .map(|day| 60 - day.minutes_awake)\n            .sum::<i32>()\n    ).unwrap();\n    let mut sleepiest_guard_awake_by_minutes = vec![0; 60];\n    for day in sleepiest_guard_days {\n        // println!(\"Day: {:?}\", day);\n        for minute in 0..60 {\n            sleepiest_guard_awake_by_minutes[minute] += i32::from(day.minutes[minute]);\n        }\n    }\n    let (max_minute, _) = sleepiest_guard_awake_by_minutes.iter().enumerate().min_by_key(|(_, times)| *times).unwrap();\n\n    println!(\"Min minute: {}, max guard: {}\", max_minute, sleepiest_guard_id);\n\n    (sleepiest_guard_id * max_minute as i32).to_string()\n}", "id": 279, "concepts": ["hashmap usage", "map iteration", "tuple unpacking", "vector computation"], "instruction": "Develop a Rust program that takes user input to create a word frequency map. It should print the word with the highest frequency in the map. Use a hashmap to store the word and its frequency as key-value pairs. Utilize a loop to iterate over the map and update the frequency count whenever a word is encountered. Finally, print the word with the highest frequency from the map."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: iteration with a while loop, index-based data access, conditional branching, nested loops\n\n### Task\nCreate a Rust function that identifies all pairs of elements within a list of integers where the second element of the pair is at least greater than the first by `growth_ratio` and the indices of the elements are within a specified `maximum_distance` from each other.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: regex parsing, iterator usage, input validation, iterative list extension\n\n### Task", "fingerprint": null, "seed": "fn initialize(lines: &Vec<String>) -> Vec<Day> {\n    let regex = Regex::new(r\"(\\d\\d-\\d\\d) ((?:23|00):\\d\\d)\\] (Guard #(\\d*)|wakes|falls)\").expect(\"Building Regex failed\");\n    let mut events = lines.iter().map(|l| GuardEvent::from_line(l, &regex)).collect::<Vec<GuardEvent>>();\n    events.sort_by(|GuardEvent {date: date1, minute: minute1, ..}, GuardEvent {date: date2, minute: minute2, ..}| {\n        date1.cmp(date2).then(minute1.cmp(minute2))\n    });\n\n    let mut days = Vec::new();\n    let mut events_iter = events.iter();\n    let mut event_option = events_iter.next();\n    while event_option.is_some() {\n        let event = event_option.unwrap();\n        assert_eq!(event.action, BeginsShift);\n        let mut current_day = Day::new(event.guard_id.unwrap());\n        let mut is_awake = true;\n        event_option = events_iter.next();\n        for minute in 0..60 {\n            if event_option.map_or(false, |e| e.action != BeginsShift && e.minute == minute) {\n                is_awake = !is_awake;\n                event_option = events_iter.next();\n            }\n            current_day.set_next_minute(is_awake);\n        }\n        days.push(current_day);\n    }\n    days\n}", "id": 280, "concepts": ["regex parsing", "iterator usage", "input validation", "iterative list extension"], "instruction": "Develop a Rust function that takes a string as input and returns a list of strings that matches the following pattern: `[<int>|<int>-<int>]`. The main requirement is that each string can be parsed by the `regex` crate without any errors.\n\nFor example, given the following input:\n- `10`\n- `10-20`\n- `100-105`\n- `20.5-25.0`\n- `15-20,25`\n\nthe function should return the following list:\n- `[\"10\"]`\n- `[\"10-20\"]`\n- `[\"100-105\"]`\n- `[\"20.5-25.0\"]`\n- `[\"15-20\",\"25\"]`"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: 2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n### Task\nWrite a Rust function called `count_conditional_matches` that takes two strings, `str1` and `str2`, as well as a boolean flag `strict` as arguments. The function should count how many times characters from the end of `str1` match with characters from the beginning of `str2` when both strings are traversed simultaneously. The traversal should continue until a pair of characters do not match or until a specific condition influenced by the `strict` flag is met:\n\n- If `strict` is `True`, stop counting as soon as a non-matching pair is found.\n- If `strict` is `False`, skip the non-matching character in `str1` and continue matching with the next character.\n\nThe function should return the total count of matching characters. This implementation requires managing two pointers for the characters in `str1` and `str2`, respectively, and using a conditional loop to handle different stopping criteria based on the `strict` parameter.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a Rust function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a Rust function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a Rust function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a Rust function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```rust\nassert_eq!(parse_duration(\"15s\").unwrap(), 15);\nassert_eq!(parse_duration(\"2min\").unwrap(), 120);\nassert_eq!(parse_duration(\"1h\").unwrap(), 3600);\nassert_eq!(parse_duration(\"1d\").unwrap(), 86400);\nassert!(parse_duration(\"30\").is_err());\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: concurrency, threads, channels, RAII, command-line argument parsing, binary search, ray tracing, image output, texture sampling, Monte Carlo sampling, random number generation\n\n### Task", "fingerprint": null, "seed": "fn main() -> Result<()> {\n    let args = Args::parse();\n    let Args {\n        aspect_ratio,\n        image_width,\n        image_height,\n        samples_per_pixel,\n        outfile,\n        max_depth,\n    } = args;\n\n    let (stats_tx, stats_rx) = unbounded();\n    let (render_tx, render_rx) = bounded(1024);\n\n    let look_from = Point3::new(13.0, 2.0, 3.0);\n    let look_at = Point3::new(0.0, 0.0, 0.0);\n\n    // Camera\n    let camera = Camera::new(\n        look_from,\n        look_at,\n        Vec3::new(0.0, 1.0, 0.0),\n        20.0,\n        aspect_ratio,\n        0.1,\n        10.0,\n    );\n\n    // World\n    let world = World::get_world(true);\n\n    let color_handle = thread::spawn(move || {\n        pixels::pixel_loop(\n            &camera,\n            &world,\n            image_width,\n            image_height,\n            samples_per_pixel,\n            max_depth,\n            stats_tx,\n            render_tx,\n        )\n    });\n\n    let stats_handle = thread::spawn(move || {\n        stats::stats_loop(\n            stats_rx,\n            ((image_width as f32 * image_height as f32 * 11.3) as usize + 24) as usize,\n        )\n    });\n    let render_handle = thread::spawn(move || render::render_loop(&outfile, render_rx));\n\n    let color_io_result = color_handle.join().unwrap();\n    let stats_io_result = stats_handle.join().unwrap();\n    let render_io_result = render_handle.join().unwrap();\n\n    color_io_result?;\n    stats_io_result?;\n    render_io_result?;\n\n    Ok(())\n}", "id": 281, "concepts": ["concurrency", "threads", "channels", "RAII", "command-line argument parsing", "binary search", "ray tracing", "image output", "texture sampling", "Monte Carlo sampling", "random number generation"], "instruction": "This task is a continuation of the 2D ray tracer from [example 6](./examples/06-ray-tracing-2d.py). This time, you will add the following:\n\n- Add the ability to load the image as a texture.\n- Add the ability to generate a random gradient texture based on the image's color.\n- Use the Monte Carlo method to compute the color of the ray as an average.\n- Add the ability to use `ray_cast()` to compute the color of the ray."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n### Task\nWrite a Rust function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a Rust class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a Rust function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: binary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n### Task\nImplement a Rust function that computes different types of hash values for the binary content of a file whose path is defined by an input string. You should calculate 'md5', 'sha1', 'sha256', and 'sha512' and return a `namedtuple` of these fields. When the input string does not correspond to a file, the function should directly compute the hash values of path itself.\n\n## Example 6\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 7\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: error handling using the `?` operator, pattern matching, result chaining\n\n### Task", "fingerprint": null, "seed": "fn main() {\n    if let Err(err) = Config::new().and_then(|conf| ui::user_menu(conf)) {\n        eprintln!(\"{}\", err);\n        process::exit(1);\n    }\n}", "id": 282, "concepts": ["error handling using the `?` operator", "pattern matching", "result chaining"], "instruction": "Develop a Rust program that takes a list of strings from user input, and returns a list of strings that are either in lowercase or uppercase. Use `Result<T, E>` to represent the program's output. The program should handle `String` conversion errors gracefully by returning an error message through a `Result<T, E>` type and integrating error handling into the program's execution flow using the `?` operator."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: linear search with recursion, default parameter initialization, multiple base cases in recursion\n\n### Task\nDesign a Rust program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: case-insensitive string matching, controlled case matching based on an option, list comprehension\n\n### Task\nConstruct a Rust program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.\n\nFor example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: top-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n### Task\nCreate a Rust function `calculate_top_k_accuracy` using PyTorch that calculates the top-k accuracy from a batch of predictions and actual labels. It should accept two tensors, `predictions` and `targets`, and an integer `k` (default 3). The function should return the average top-k accuracy as a float, determining if the true label is within the top `k` predictions for each input.\n\n## Example 4\n### Properties\ncategory: program implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: iterating over file lines, command execution from file input, new line character removal\n\n### Task\nDevelop a Rust program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a Rust function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: hard\nconcepts: object-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n### Task\nDevelop a Rust class `StringEnhancer` that offers advanced tools for managing a string. The class should maintain an internal state that is initially an empty string. The class should support extending the string with additional prefix or suffix, converting the entire string to lowercase or uppercase, and altering specific characters within the string. All the operations are communicated through a central method: `apply_operation(self, operation: str)`.\n\nThe method `apply_operation` interprets the operations specified in the form of `\"[opname]:[arg]\"`. Here are the detailed formats for each operation, explained through examples:\n- Prefix addition: `apply_operation(\"prefix:Hello, \")`\n- Suffix addition: `apply_operation(\"suffix: World!\")`\n- Lowercase conversion: `apply_operation(\"lower:\")`\n- Uppercase conversion: `apply_operation(\"upper:\")`\n- Character replacement: `apply_operation(\"replace:a->e\")`\n\nThe class should handle erroneous inputs gracefully, such as incorrect operation formats or arguments. Additionally, implement the `__str__` method to return a formatted string showing the current value of the string and a list of operations that have been applied to it.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a Rust function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a Rust function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: Rust\ndifficulty: easy\nconcepts: recursion, file type checking, directory traversal, iterating over directory contents with directory traversal\n\n### Task", "fingerprint": null, "seed": "fn read_dir<P: AsRef<Path>>(path: P, recursive: bool) -> io::Result<Vec<DirEntry>> {\n    let path = path.as_ref();\n    let mut entries = Vec::new();\n    for entry in fs::read_dir(path)? {\n        let entry = entry?;\n        let path = entry.path().to_str().unwrap().to_string();\n        let children = if recursive && entry.file_type()?.is_dir() {\n            Some(read_dir(&path, true)?)\n        } else {\n            None\n        };\n        entries.push(DirEntry { path, children });\n    }\n    Ok(entries)\n}", "id": 283, "concepts": ["recursion", "file type checking", "directory traversal", "iterating over directory contents with directory traversal"], "instruction": "Develop a Rust class `DirectoryTraversal` to recursively traverse a directory structure and list all files with the given file extension in every subdirectory. Provide an option to list all files regardless of file extension.\n\nFor example, given the following directory structure:\n\n```python\nroot/\n    dir1/\n        file1.txt\n    dir2/\n        file2.txt\n        file3.py\n    dir3/\n        file4.txt\n    dir4/\n        file5.py\n```\n\nIf we specify the extension to be `.txt`, the class should list the following output:\n\n```python\nroot/dir1/file1.txt\nroot/dir2/file2.txt\nroot/dir2/file3.py\nroot/dir3/file4.txt\nroot/dir4/file5.py\n```\n\nIf we specify the extension to be `.py`, the class should list the following output:\n\n```python\nroot/dir2/file2.txt\nroot/dir2/file3.py\nroot/dir4/file5.py\n```"}
