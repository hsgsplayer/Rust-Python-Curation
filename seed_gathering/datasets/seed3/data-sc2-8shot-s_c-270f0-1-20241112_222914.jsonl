{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef format_size(num):\n    \"\"\"http://stackoverflow.com/a/1094933\n    \"\"\"\n    for x in ['bytes', 'KB', 'MB', 'GB']:\n        if num < 1024.0 and num > -1024.0:\n            return \"%3.1f%s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f%s\" % (num, 'TB')\nassert format_size(1024**2 - 1) == '1024.0KB'\nassert format_size(1024*512) == '512.0KB'\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\ndef unify_stringlist(L: list):\n    \"\"\" Adds asterisks to strings that appear multiple times, so the resulting\n    list has only unique strings but still the same length, order, and meaning.\n    For example:\n        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\n    \"\"\"\n    assert(all([isinstance(l,str) for l in L]))\n    return [L[i]+\"*\"*L[:i].count(L[i]) for i in range(len(L))]\nassert unify_stringlist(list(\"abc\")) == list(\"abc\")\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nif match_case == 'auto':\n    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):\n        match_case = True\n    else:\n        match_case = False\n\nif match_case:\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\nelse:\n    ch_names = [ch_name.lower() for ch_name in ch_names]\n    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\n\nreturn picks\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\ndef decompress(self):\n    source = self.compressed\n    if isinstance(source, (bytes, bytearray)):\n        return self.decompress_bytes()\n    pos = 0\n    node = self.root\n    res = bytearray()\n\n    while pos < len(source):\n        code = int(source[pos])\n        child = node.children[code]\n        if child.is_leaf:\n            res.append(child)\n            node = self.root\n        else:\n            node = child\n        pos += 1\n\n    return bytes(res)\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\ndef wheelMoves_fixture(func):\n    \"\"\"Decorator to save some dummy wheelMoves ALF files for extraction tests\"\"\"\n    @functools.wraps(func)\n    def wrapper(obj=None):\n        # Save some wheelMoves ALF files\n        attr_list = ['training_lt5',\n                     'training_ge5',\n                     'biased_lt5',\n                     'biased_ge5']\n        alf_paths = [getattr(obj, p)['path'] / 'alf' for p in attr_list]\n        n_trials = [getattr(obj, p)['ntrials'] for p in attr_list]\n        for p, n in zip(alf_paths, n_trials):\n            p.mkdir()\n            np.save(str(p / '_ibl_wheelMoves.intervals.npy'), np.zeros((n, 2)))\n            np.save(str(p / '_ibl_wheelMoves.peakAmplitude.npy'), np.zeros(n))\n\n        # Run method\n        func(obj)\n\n        # Teardown; delete the files\n        for p in alf_paths:\n            shutil.rmtree(p)\n    return wrapper\n\n### Concepts", "fingerprint": null, "seed": "def wheelMoves_fixture(func):\n    \"\"\"Decorator to save some dummy wheelMoves ALF files for extraction tests\"\"\"\n    @functools.wraps(func)\n    def wrapper(obj=None):\n        # Save some wheelMoves ALF files\n        attr_list = ['training_lt5',\n                     'training_ge5',\n                     'biased_lt5',\n                     'biased_ge5']\n        alf_paths = [getattr(obj, p)['path'] / 'alf' for p in attr_list]\n        n_trials = [getattr(obj, p)['ntrials'] for p in attr_list]\n        for p, n in zip(alf_paths, n_trials):\n            p.mkdir()\n            np.save(str(p / '_ibl_wheelMoves.intervals.npy'), np.zeros((n, 2)))\n            np.save(str(p / '_ibl_wheelMoves.peakAmplitude.npy'), np.zeros(n))\n\n        # Run method\n        func(obj)\n\n        # Teardown; delete the files\n        for p in alf_paths:\n            shutil.rmtree(p)\n    return wrapper", "id": 1, "concepts": ["decorator", "function wrapping", "function decoration", "directory traversal", "file management"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\nfrom collections import Counter\n\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(k for k, v in Counter(nums).items() if v == 1)\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\n    isprime = n >= 2 and 1 or 0\n    for prime in prime_list:                    # Check for factors with all primes\n        if prime * prime > n: break             # ... up to sqrt(n)\n        if not n % prime:\n            isprime = 0\n            break\n    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup\n    return isprime\ndef prime(x):\n    ''' Returns the xth prime '''\n    lastn = prime_list[-1]\n    while len(prime_list) <= x:                 # Keep working until we've got the xth prime\n        lastn = lastn + 1                       # Check the next number\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\nif match_case == 'auto':\n    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):\n        match_case = True\n    else:\n        match_case = False\n\nif match_case:\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\nelse:\n    ch_names = [ch_name.lower() for ch_name in ch_names]\n    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\n\nreturn picks\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\ndef format_size(num):\n    \"\"\"http://stackoverflow.com/a/1094933\n    \"\"\"\n    for x in ['bytes', 'KB', 'MB', 'GB']:\n        if num < 1024.0 and num > -1024.0:\n            return \"%3.1f%s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f%s\" % (num, 'TB')\nassert format_size(1024**2 - 1) == '1024.0KB'\nassert format_size(1024*512) == '512.0KB'\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\ndef _mine_heuristic(bot, problem):\n    \"\"\"Return the mining heuristic.\n\n    bot is an _ImaginaryBot.\n    \"\"\"\n    if bot.contains(problem.get_block_id()):\n        return 0\n\n    bot_pos = bot.get_pos()\n    dest_pos = problem.get_block_loc()\n\n    # If man == dy: return man + 1\n    # If man > dy: return man\n    # If man < dy: return dy?\n    man_dist = _manhattan((bot_pos.x, bot_pos.z), (dest_pos.x, dest_pos.z))\n    y_diff = bot_pos.y - dest_pos.y\n    if y_diff < 0:\n        y_diff += 1\n\n    if y_diff == 0:\n        return man_dist\n\n    # Transform so that it's only dropping\n    drop = _DROP if y_diff > 0 else 1\n    y_diff = abs(y_diff)\n\n    drops = _drops(y_diff, drop)\n\n    if man_dist > drops:\n        return man_dist\n    if man_dist == drops:\n        return man_dist + 1\n    if drop == 1:\n        return drops\n    if y_diff % drop == 1:\n        return drops\n    return drops + 1\n\n### Concepts", "fingerprint": null, "seed": "def _mine_heuristic(bot, problem):\n    \"\"\"Return the mining heuristic.\n\n    bot is an _ImaginaryBot.\n    \"\"\"\n    if bot.contains(problem.get_block_id()):\n        return 0\n\n    bot_pos = bot.get_pos()\n    dest_pos = problem.get_block_loc()\n\n    # If man == dy: return man + 1\n    # If man > dy: return man\n    # If man < dy: return dy?\n    man_dist = _manhattan((bot_pos.x, bot_pos.z), (dest_pos.x, dest_pos.z))\n    y_diff = bot_pos.y - dest_pos.y\n    if y_diff < 0:\n        y_diff += 1\n\n    if y_diff == 0:\n        return man_dist\n\n    # Transform so that it's only dropping\n    drop = _DROP if y_diff > 0 else 1\n    y_diff = abs(y_diff)\n\n    drops = _drops(y_diff, drop)\n\n    if man_dist > drops:\n        return man_dist\n    if man_dist == drops:\n        return man_dist + 1\n    if drop == 1:\n        return drops\n    if y_diff % drop == 1:\n        return drops\n    return drops + 1", "id": 2, "concepts": ["heuristic-based search", "heuristic functions", "return values", "input validation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\ndef unify_stringlist(L: list):\n    \"\"\" Adds asterisks to strings that appear multiple times, so the resulting\n    list has only unique strings but still the same length, order, and meaning.\n    For example:\n        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\n    \"\"\"\n    assert(all([isinstance(l,str) for l in L]))\n    return [L[i]+\"*\"*L[:i].count(L[i]) for i in range(len(L))]\nassert unify_stringlist(list(\"abc\")) == list(\"abc\")\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\ndef _validate_shuffle_split_init(test_size, train_size):\n    \"\"\"Validation helper to check the test_size and train_size at init\"\"\"\n    if test_size is None and train_size is None:\n        raise ValueError('test_size and train_size can not both be None')\n\n    if test_size is not None:\n        if np.asarray(test_size).dtype.kind == 'f':\n            if test_size >= 1.:\n                raise ValueError(\n                    'test_size=%f should be smaller '\n                    'than 1.0 or be an integer' % test_size)\n        elif np.asarray(test_size).dtype.kind != 'i':\n            raise ValueError('Invalid value for test_size: %r' % test_size)\n\n    if train_size is not None:\n        if np.asarray(train_size).dtype.kind == 'f':\n            if train_size >= 1.:\n                raise ValueError(\n                    'train_size=%f should be smaller '\n                    'than 1.0 or be an integer' % test_size)\n            elif (np.asarray(test_size).dtype.kind == 'f' and\n                    (train_size + test_size) > 1.):\n                raise ValueError('The sum of test_size and train_size = %f'\n                                 'should be smaller than 1.0. Reduce test_size '\n                                 'and/or train_size.' % (train_size + test_size))\n        elif np.asarray(train_size).dtype.kind != 'i':\n            raise ValueError('Invalid value for train_size: %r' % train_size)\n\n### Concepts", "fingerprint": null, "seed": "def _validate_shuffle_split_init(test_size, train_size):\n    \"\"\"Validation helper to check the test_size and train_size at init\"\"\"\n    if test_size is None and train_size is None:\n        raise ValueError('test_size and train_size can not both be None')\n\n    if test_size is not None:\n        if np.asarray(test_size).dtype.kind == 'f':\n            if test_size >= 1.:\n                raise ValueError(\n                    'test_size=%f should be smaller '\n                    'than 1.0 or be an integer' % test_size)\n        elif np.asarray(test_size).dtype.kind != 'i':\n            raise ValueError('Invalid value for test_size: %r' % test_size)\n\n    if train_size is not None:\n        if np.asarray(train_size).dtype.kind == 'f':\n            if train_size >= 1.:\n                raise ValueError(\n                    'train_size=%f should be smaller '\n                    'than 1.0 or be an integer' % test_size)\n            elif (np.asarray(test_size).dtype.kind == 'f' and\n                    (train_size + test_size) > 1.):\n                raise ValueError('The sum of test_size and train_size = %f'\n                                 'should be smaller than 1.0. Reduce test_size '\n                                 'and/or train_size.' % (train_size + test_size))\n        elif np.asarray(train_size).dtype.kind != 'i':\n            raise ValueError('Invalid value for train_size: %r' % train_size)", "id": 3, "concepts": ["validation helper function", "validation function implementation", "input validation", "type checking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n    isprime = n >= 2 and 1 or 0\n    for prime in prime_list:                    # Check for factors with all primes\n        if prime * prime > n: break             # ... up to sqrt(n)\n        if not n % prime:\n            isprime = 0\n            break\n    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup\n    return isprime\ndef prime(x):\n    ''' Returns the xth prime '''\n    lastn = prime_list[-1]\n    while len(prime_list) <= x:                 # Keep working until we've got the xth prime\n        lastn = lastn + 1                       # Check the next number\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\ndef format_size(num):\n    \"\"\"http://stackoverflow.com/a/1094933\n    \"\"\"\n    for x in ['bytes', 'KB', 'MB', 'GB']:\n        if num < 1024.0 and num > -1024.0:\n            return \"%3.1f%s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f%s\" % (num, 'TB')\nassert format_size(1024**2 - 1) == '1024.0KB'\nassert format_size(1024*512) == '512.0KB'\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nfp=open('cmd.sh','r')\nlines=fp.readlines()\nfor i,line in enumerate(lines):\n    cmd=line.replace('\\n','')\n    print i,cmd\n    p=os.popen(cmd)\n    x=p.read()\n    p.close()\nfp.close\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\nfrom collections import Counter\n\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(k for k, v in Counter(nums).items() if v == 1)\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\ndef check_cv(cv=3):\n    \"\"\"Checks the ``cv`` parameter to determine\n    whether it's a valid int or H2OBaseCrossValidator.\n\n    Parameters\n    ----------\n\n    cv : int or H2OBaseCrossValidator, optional (default=3)\n        The number of folds or the H2OBaseCrossValidator\n        instance.\n\n    Returns\n    -------\n\n    cv : H2OBaseCrossValidator\n        The instance of H2OBaseCrossValidator\n    \"\"\"\n    if cv is None:\n        cv = 3\n\n    if isinstance(cv, numbers.Integral):\n        return H2OKFold(cv)\n\n    if not isinstance(cv, H2OBaseCrossValidator):\n        raise ValueError('expected int or instance of '\n                         'H2OBaseCrossValidator but got %s'\n                         % type(cv))\n\n    return cv\n\n### Concepts", "fingerprint": null, "seed": "def check_cv(cv=3):\n    \"\"\"Checks the ``cv`` parameter to determine\n    whether it's a valid int or H2OBaseCrossValidator.\n\n    Parameters\n    ----------\n\n    cv : int or H2OBaseCrossValidator, optional (default=3)\n        The number of folds or the H2OBaseCrossValidator\n        instance.\n\n    Returns\n    -------\n\n    cv : H2OBaseCrossValidator\n        The instance of H2OBaseCrossValidator\n    \"\"\"\n    if cv is None:\n        cv = 3\n\n    if isinstance(cv, numbers.Integral):\n        return H2OKFold(cv)\n\n    if not isinstance(cv, H2OBaseCrossValidator):\n        raise ValueError('expected int or instance of '\n                         'H2OBaseCrossValidator but got %s'\n                         % type(cv))\n\n    return cv", "id": 4, "concepts": ["input validation with exceptions", "function signature", "type hints", "type checking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\ndef unify_stringlist(L: list):\n    \"\"\" Adds asterisks to strings that appear multiple times, so the resulting\n    list has only unique strings but still the same length, order, and meaning.\n    For example:\n        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\n    \"\"\"\n    assert(all([isinstance(l,str) for l in L]))\n    return [L[i]+\"*\"*L[:i].count(L[i]) for i in range(len(L))]\nassert unify_stringlist(list(\"abc\")) == list(\"abc\")\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\ndef decompress(self):\n    source = self.compressed\n    if isinstance(source, (bytes, bytearray)):\n        return self.decompress_bytes()\n    pos = 0\n    node = self.root\n    res = bytearray()\n\n    while pos < len(source):\n        code = int(source[pos])\n        child = node.children[code]\n        if child.is_leaf:\n            res.append(child)\n            node = self.root\n        else:\n            node = child\n        pos += 1\n\n    return bytes(res)\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\ndef alternatingCharacters(s):\n    i = 0\n    j = 1\n    count = 0\n    while j<len(s):\n        if s[j] == s[i]:\n            while j<len(s) and s[j] == s[i]:\n                j+=1\n            count += j-i-1\n        i = j\n        j += 1\n    return count\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 9\n### Snippet\ndef _player_loc():\n    \"\"\"Return the player's location.\"\"\"\n    return _to_my_vec3(_get_mc().player.getTilePos())\n\n### Concepts", "fingerprint": null, "seed": "def _player_loc():\n    \"\"\"Return the player's location.\"\"\"\n    return _to_my_vec3(_get_mc().player.getTilePos())", "id": 5, "concepts": ["conversion from Minecraft vector to 3D coordinates", "access to player's location"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\ndef unify_stringlist(L: list):\n    \"\"\" Adds asterisks to strings that appear multiple times, so the resulting\n    list has only unique strings but still the same length, order, and meaning.\n    For example:\n        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\n    \"\"\"\n    assert(all([isinstance(l,str) for l in L]))\n    return [L[i]+\"*\"*L[:i].count(L[i]) for i in range(len(L))]\nassert unify_stringlist(list(\"abc\")) == list(\"abc\")\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\nif match_case == 'auto':\n    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):\n        match_case = True\n    else:\n        match_case = False\n\nif match_case:\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\nelse:\n    ch_names = [ch_name.lower() for ch_name in ch_names]\n    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\n\nreturn picks\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\ndef decompress(self):\n    source = self.compressed\n    if isinstance(source, (bytes, bytearray)):\n        return self.decompress_bytes()\n    pos = 0\n    node = self.root\n    res = bytearray()\n\n    while pos < len(source):\n        code = int(source[pos])\n        child = node.children[code]\n        if child.is_leaf:\n            res.append(child)\n            node = self.root\n        else:\n            node = child\n        pos += 1\n\n    return bytes(res)\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\ndef save_data(dataframe, database_filename):\n    \"\"\"\n   Take the input dataframe and save it into sqlite database\n    \"\"\"\n    # Creating sqlite engine and save the dataframe with the name message\n    engine_process = create_engine('sqlite:///Messages.db')\n    dataframe.to_sql('messaging', engine_process, index=False,if_exists='replace')\n\n### Concepts", "fingerprint": null, "seed": "def save_data(dataframe, database_filename):\n    \"\"\"\n   Take the input dataframe and save it into sqlite database\n    \"\"\"\n    # Creating sqlite engine and save the dataframe with the name message\n    engine_process = create_engine('sqlite:///Messages.db')\n    dataframe.to_sql('messaging', engine_process, index=False,if_exists='replace')", "id": 6, "concepts": ["sql database creation", "sqlite engine creation", "dataframe to sql table load"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\nif match_case == 'auto':\n    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):\n        match_case = True\n    else:\n        match_case = False\n\nif match_case:\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\nelse:\n    ch_names = [ch_name.lower() for ch_name in ch_names]\n    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\n\nreturn picks\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\ndef alternatingCharacters(s):\n    i = 0\n    j = 1\n    count = 0\n    while j<len(s):\n        if s[j] == s[i]:\n            while j<len(s) and s[j] == s[i]:\n                j+=1\n            count += j-i-1\n        i = j\n        j += 1\n    return count\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\n    isprime = n >= 2 and 1 or 0\n    for prime in prime_list:                    # Check for factors with all primes\n        if prime * prime > n: break             # ... up to sqrt(n)\n        if not n % prime:\n            isprime = 0\n            break\n    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup\n    return isprime\ndef prime(x):\n    ''' Returns the xth prime '''\n    lastn = prime_list[-1]\n    while len(prime_list) <= x:                 # Keep working until we've got the xth prime\n        lastn = lastn + 1                       # Check the next number\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\ndef _to_my_vec3(vec):\n    \"\"\"Return the _Vec3 alternative of the Vec3.\"\"\"\n    return _Vec3(vec.x, vec.y, vec.z)\n\n### Concepts", "fingerprint": null, "seed": "def _to_my_vec3(vec):\n    \"\"\"Return the _Vec3 alternative of the Vec3.\"\"\"\n    return _Vec3(vec.x, vec.y, vec.z)", "id": 7, "concepts": ["conversion from other types to _Vec3"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\nData = np.zeros([break_points[-1],size_blocks])\nData_stacked = np.zeros([break_points[-1]-num_blocks+1, size_blocks*num_blocks])\ncluster_point_list = []\nfor counter in xrange(len(break_points)):\n        break_pt = break_points[counter]\n        cluster = seg_ids[counter]\n        if counter == 0:\n                old_break_pt = 0\n        else:\n                old_break_pt = break_points[counter-1]\n        for num in xrange(old_break_pt,break_pt):\n                ##generate the point from this cluster\n                # print \"num is:\", num\n                if num == 0:\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nfp=open('cmd.sh','r')\nlines=fp.readlines()\nfor i,line in enumerate(lines):\n    cmd=line.replace('\\n','')\n    print i,cmd\n    p=os.popen(cmd)\n    x=p.read()\n    p.close()\nfp.close\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 6\n### Snippet\nif match_case == 'auto':\n    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):\n        match_case = True\n    else:\n        match_case = False\n\nif match_case:\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\nelse:\n    ch_names = [ch_name.lower() for ch_name in ch_names]\n    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\n\nreturn picks\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\ndef _all_dirs():\n    \"\"\"Return all adjacent directions.\"\"\"\n    return _adj_dirs() + [_Vec3(0, 1, 0), _Vec3(0, -1, 0)]\n\n### Concepts", "fingerprint": null, "seed": "def _all_dirs():\n    \"\"\"Return all adjacent directions.\"\"\"\n    return _adj_dirs() + [_Vec3(0, 1, 0), _Vec3(0, -1, 0)]", "id": 8, "concepts": ["iterating over adjacent directions", "vector addition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nData = np.zeros([break_points[-1],size_blocks])\nData_stacked = np.zeros([break_points[-1]-num_blocks+1, size_blocks*num_blocks])\ncluster_point_list = []\nfor counter in xrange(len(break_points)):\n        break_pt = break_points[counter]\n        cluster = seg_ids[counter]\n        if counter == 0:\n                old_break_pt = 0\n        else:\n                old_break_pt = break_points[counter-1]\n        for num in xrange(old_break_pt,break_pt):\n                ##generate the point from this cluster\n                # print \"num is:\", num\n                if num == 0:\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\ndef busca_linear_recursiva(array,elemento):\n    i = -1\n    return busca_recursiva(array,elemento, i)\n\ndef busca_recursiva(array,elemento, i):\n    i += 1\n    if(i == len(array)):\n       return -1\n    if(array[i] == elemento):\n        return i\n    return busca_recursiva(array,elemento,i)\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\n    isprime = n >= 2 and 1 or 0\n    for prime in prime_list:                    # Check for factors with all primes\n        if prime * prime > n: break             # ... up to sqrt(n)\n        if not n % prime:\n            isprime = 0\n            break\n    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup\n    return isprime\ndef prime(x):\n    ''' Returns the xth prime '''\n    lastn = prime_list[-1]\n    while len(prime_list) <= x:                 # Keep working until we've got the xth prime\n        lastn = lastn + 1                       # Check the next number\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\ndef decompress(self):\n    source = self.compressed\n    if isinstance(source, (bytes, bytearray)):\n        return self.decompress_bytes()\n    pos = 0\n    node = self.root\n    res = bytearray()\n\n    while pos < len(source):\n        code = int(source[pos])\n        child = node.children[code]\n        if child.is_leaf:\n            res.append(child)\n            node = self.root\n        else:\n            node = child\n        pos += 1\n\n    return bytes(res)\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nfrom collections import Counter\n\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(k for k, v in Counter(nums).items() if v == 1)\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\ndef string_id(length=8):\n    \"\"\" Generate Random ID.\n\n    Random ID contains ascii letters and digitis.\n\n    Args:\n        length (int): Character length of id.\n\n    Returns:\n        Random id string.\n    \"\"\"\n    return ''.join(random.choice(string.ascii_letters +\n                                 string.digits)\n                   for _ in range(length))\n\n### Concepts", "fingerprint": null, "seed": "def string_id(length=8):\n    \"\"\" Generate Random ID.\n\n    Random ID contains ascii letters and digitis.\n\n    Args:\n        length (int): Character length of id.\n\n    Returns:\n        Random id string.\n    \"\"\"\n    return ''.join(random.choice(string.ascii_letters +\n                                 string.digits)\n                   for _ in range(length))", "id": 9, "concepts": ["random character generation with random.choice()", "string concatenation with join()", "list comprehension", "iteration"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nif match_case == 'auto':\n    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):\n        match_case = True\n    else:\n        match_case = False\n\nif match_case:\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\nelse:\n    ch_names = [ch_name.lower() for ch_name in ch_names]\n    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\n\nreturn picks\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\ndef format_size(num):\n    \"\"\"http://stackoverflow.com/a/1094933\n    \"\"\"\n    for x in ['bytes', 'KB', 'MB', 'GB']:\n        if num < 1024.0 and num > -1024.0:\n            return \"%3.1f%s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f%s\" % (num, 'TB')\nassert format_size(1024**2 - 1) == '1024.0KB'\nassert format_size(1024*512) == '512.0KB'\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nfrom collections import Counter\n\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(k for k, v in Counter(nums).items() if v == 1)\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\n    isprime = n >= 2 and 1 or 0\n    for prime in prime_list:                    # Check for factors with all primes\n        if prime * prime > n: break             # ... up to sqrt(n)\n        if not n % prime:\n            isprime = 0\n            break\n    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup\n    return isprime\ndef prime(x):\n    ''' Returns the xth prime '''\n    lastn = prime_list[-1]\n    while len(prime_list) <= x:                 # Keep working until we've got the xth prime\n        lastn = lastn + 1                       # Check the next number\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nfp=open('cmd.sh','r')\nlines=fp.readlines()\nfor i,line in enumerate(lines):\n    cmd=line.replace('\\n','')\n    print i,cmd\n    p=os.popen(cmd)\n    x=p.read()\n    p.close()\nfp.close\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\ndef _get_mc():\n    \"\"\"Return the Minecraft instance.\"\"\"\n    return minecraft.Minecraft.create()\n\n### Concepts", "fingerprint": null, "seed": "def _get_mc():\n    \"\"\"Return the Minecraft instance.\"\"\"\n    return minecraft.Minecraft.create()", "id": 10, "concepts": ["object instantiation", "data retrieval", "class instantiation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left<len(arr) and ryt >= start and left <= ryt:\n        mid = (left+ryt)//2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] > target:\n            ryt = mid-1\n        else:\n            left = mid+1\n    return left\ndef tripletsSorting(nums, t):\n    # TimeComplexity = O((n^2)logn)\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nif match_case == 'auto':\n    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):\n        match_case = True\n    else:\n        match_case = False\n\nif match_case:\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\nelse:\n    ch_names = [ch_name.lower() for ch_name in ch_names]\n    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\n\nreturn picks\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\n    isprime = n >= 2 and 1 or 0\n    for prime in prime_list:                    # Check for factors with all primes\n        if prime * prime > n: break             # ... up to sqrt(n)\n        if not n % prime:\n            isprime = 0\n            break\n    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup\n    return isprime\ndef prime(x):\n    ''' Returns the xth prime '''\n    lastn = prime_list[-1]\n    while len(prime_list) <= x:                 # Keep working until we've got the xth prime\n        lastn = lastn + 1                       # Check the next number\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nfrom collections import Counter\n\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(k for k, v in Counter(nums).items() if v == 1)\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\ndef busca_linear_recursiva(array,elemento):\n    i = -1\n    return busca_recursiva(array,elemento, i)\n\ndef busca_recursiva(array,elemento, i):\n    i += 1\n    if(i == len(array)):\n       return -1\n    if(array[i] == elemento):\n        return i\n    return busca_recursiva(array,elemento,i)\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\ndef alternatingCharacters(s):\n    i = 0\n    j = 1\n    count = 0\n    while j<len(s):\n        if s[j] == s[i]:\n            while j<len(s) and s[j] == s[i]:\n                j+=1\n            count += j-i-1\n        i = j\n        j += 1\n    return count\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\ndef matrix_divided(matrix, div):\n    \"\"\"Divides a Matrix\n\n    Args:\n    matrix: A list of lists of ints or floats\n    div: a non zero int or float\n\n    Exceptions:\n    TypeError: if the matrix and/or div is not as stated or the matrix elements\n               are not of the same size\n    ZeroDivisionError: if div is zero\n\n    Returns: a new matrix holding the results\n\n    \"\"\"\n    workmat = []\n    WrongType = False\n    TooLong = False\n    i = 0\n    if isinstance(matrix, list):\n        if matrix == []:\n            WrongType = True\n        for x in range(len(matrix)):\n            if isinstance(matrix[x], list):\n                workmat.append([])\n                for y in range(len(matrix[x])):\n                    if matrix[x] == []:\n                        WrongType = True\n                    if (\n                            isinstance(matrix[x][y], int) or\n                            isinstance(matrix[x][y], int)\n                    ):\n                        workmat[x].append(matrix[x][y])\n                    else:\n                        WrongType = True\n                    if x == 0 and y == 0:\n                        i = len(matrix[x])\n                    else:\n                        if not i == len(matrix[x]):\n                            TooLong = True\n            else:\n                WrongType = True\n    else:\n        WrongType = True\n    if WrongType:\n        raise TypeError(\n            \"matrix must be a matrix (list of lists) of integers/floats\")\n    if TooLong:\n        raise TypeError(\n            \"Each row of the matrix must have the same size\")\n    if not isinstance(div, float) and not isinstance(div, int):\n        raise TypeError(\n            \"div must be a number\")\n    if div == 0:\n        raise ZeroDivisionError(\n            \"division by zero\")\n\n    for x in range(len(workmat)):\n        for y in range(len(workmat[x])):\n            workmat[x][y] = round((workmat[x][y] / div), 2)\n    return workmat\n\n### Concepts", "fingerprint": null, "seed": "def matrix_divided(matrix, div):\n    \"\"\"Divides a Matrix\n\n    Args:\n    matrix: A list of lists of ints or floats\n    div: a non zero int or float\n\n    Exceptions:\n    TypeError: if the matrix and/or div is not as stated or the matrix elements\n               are not of the same size\n    ZeroDivisionError: if div is zero\n\n    Returns: a new matrix holding the results\n\n    \"\"\"\n    workmat = []\n    WrongType = False\n    TooLong = False\n    i = 0\n    if isinstance(matrix, list):\n        if matrix == []:\n            WrongType = True\n        for x in range(len(matrix)):\n            if isinstance(matrix[x], list):\n                workmat.append([])\n                for y in range(len(matrix[x])):\n                    if matrix[x] == []:\n                        WrongType = True\n                    if (\n                            isinstance(matrix[x][y], int) or\n                            isinstance(matrix[x][y], int)\n                    ):\n                        workmat[x].append(matrix[x][y])\n                    else:\n                        WrongType = True\n                    if x == 0 and y == 0:\n                        i = len(matrix[x])\n                    else:\n                        if not i == len(matrix[x]):\n                            TooLong = True\n            else:\n                WrongType = True\n    else:\n        WrongType = True\n    if WrongType:\n        raise TypeError(\n            \"matrix must be a matrix (list of lists) of integers/floats\")\n    if TooLong:\n        raise TypeError(\n            \"Each row of the matrix must have the same size\")\n    if not isinstance(div, float) and not isinstance(div, int):\n        raise TypeError(\n            \"div must be a number\")\n    if div == 0:\n        raise ZeroDivisionError(\n            \"division by zero\")\n\n    for x in range(len(workmat)):\n        for y in range(len(workmat[x])):\n            workmat[x][y] = round((workmat[x][y] / div), 2)\n    return workmat", "id": 11, "concepts": ["exception handling techniques", "flow control techniques", "2D list traversal"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef unify_stringlist(L: list):\n    \"\"\" Adds asterisks to strings that appear multiple times, so the resulting\n    list has only unique strings but still the same length, order, and meaning.\n    For example:\n        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\n    \"\"\"\n    assert(all([isinstance(l,str) for l in L]))\n    return [L[i]+\"*\"*L[:i].count(L[i]) for i in range(len(L))]\nassert unify_stringlist(list(\"abc\")) == list(\"abc\")\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\ndef decompress(self):\n    source = self.compressed\n    if isinstance(source, (bytes, bytearray)):\n        return self.decompress_bytes()\n    pos = 0\n    node = self.root\n    res = bytearray()\n\n    while pos < len(source):\n        code = int(source[pos])\n        child = node.children[code]\n        if child.is_leaf:\n            res.append(child)\n            node = self.root\n        else:\n            node = child\n        pos += 1\n\n    return bytes(res)\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n    isprime = n >= 2 and 1 or 0\n    for prime in prime_list:                    # Check for factors with all primes\n        if prime * prime > n: break             # ... up to sqrt(n)\n        if not n % prime:\n            isprime = 0\n            break\n    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup\n    return isprime\ndef prime(x):\n    ''' Returns the xth prime '''\n    lastn = prime_list[-1]\n    while len(prime_list) <= x:                 # Keep working until we've got the xth prime\n        lastn = lastn + 1                       # Check the next number\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\ndef h2o_train_test_split(frame, test_size=None, train_size=None, random_state=None, stratify=None):\n    \"\"\"Splits an H2OFrame into random train and test subsets\n\n    Parameters\n    ----------\n\n    frame : H2OFrame\n        The h2o frame to split\n\n    test_size : float, int, or None (default=None)\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the dataset to include in the test split. If\n        int, represents the absolute number of test samples. If None,\n        the value is automatically set to the complement of the train size.\n        If train size is also None, test size is set to 0.25\n\n    train_size : float, int, or None (default=None)\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the dataset to include in the train split. If\n        int, represents the absolute number of train samples. If None,\n        the value is automatically set to the complement of the test size.\n\n    random_state : int or RandomState\n        Pseudo-random number generator state used for random sampling.\n\n    stratify : str or None (default=None)\n        The name of the target on which to stratify the sampling\n\n    Returns\n    -------\n\n    out : tuple, shape=(2,)\n        training_frame : H2OFrame\n            The training fold split\n\n        testing_frame : H2OFrame\n            The testing fold split\n    \"\"\"\n    frame = check_frame(frame, copy=False)\n    if test_size is None and train_size is None:\n        test_size = 0.25\n\n    if stratify is not None:\n        CVClass = H2OStratifiedShuffleSplit\n    else:\n        CVClass = H2OShuffleSplit\n\n    cv = CVClass(n_splits=2,\n                 test_size=test_size,\n                 train_size=train_size,\n                 random_state=random_state)\n\n    # for the h2o one, we only need iter 0\n    tr_te_tuples = [(tr, te) for tr, te in cv.split(frame, stratify)][0]\n\n    # h2o \"doesn't reorder rows\" so we need to keep these sorted...\n    train, test = sorted(list(tr_te_tuples[0])), sorted(list(tr_te_tuples[1]))\n    out = (\n        frame[train, :],\n        frame[test, :]\n    )\n\n    return out\n\n### Concepts", "fingerprint": null, "seed": "def h2o_train_test_split(frame, test_size=None, train_size=None, random_state=None, stratify=None):\n    \"\"\"Splits an H2OFrame into random train and test subsets\n\n    Parameters\n    ----------\n\n    frame : H2OFrame\n        The h2o frame to split\n\n    test_size : float, int, or None (default=None)\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the dataset to include in the test split. If\n        int, represents the absolute number of test samples. If None,\n        the value is automatically set to the complement of the train size.\n        If train size is also None, test size is set to 0.25\n\n    train_size : float, int, or None (default=None)\n        If float, should be between 0.0 and 1.0 and represent the\n        proportion of the dataset to include in the train split. If\n        int, represents the absolute number of train samples. If None,\n        the value is automatically set to the complement of the test size.\n\n    random_state : int or RandomState\n        Pseudo-random number generator state used for random sampling.\n\n    stratify : str or None (default=None)\n        The name of the target on which to stratify the sampling\n\n    Returns\n    -------\n\n    out : tuple, shape=(2,)\n        training_frame : H2OFrame\n            The training fold split\n\n        testing_frame : H2OFrame\n            The testing fold split\n    \"\"\"\n    frame = check_frame(frame, copy=False)\n    if test_size is None and train_size is None:\n        test_size = 0.25\n\n    if stratify is not None:\n        CVClass = H2OStratifiedShuffleSplit\n    else:\n        CVClass = H2OShuffleSplit\n\n    cv = CVClass(n_splits=2,\n                 test_size=test_size,\n                 train_size=train_size,\n                 random_state=random_state)\n\n    # for the h2o one, we only need iter 0\n    tr_te_tuples = [(tr, te) for tr, te in cv.split(frame, stratify)][0]\n\n    # h2o \"doesn't reorder rows\" so we need to keep these sorted...\n    train, test = sorted(list(tr_te_tuples[0])), sorted(list(tr_te_tuples[1]))\n    out = (\n        frame[train, :],\n        frame[test, :]\n    )\n\n    return out", "id": 12, "concepts": ["random sampling", "data partitioning", "conditional branching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nData = np.zeros([break_points[-1],size_blocks])\nData_stacked = np.zeros([break_points[-1]-num_blocks+1, size_blocks*num_blocks])\ncluster_point_list = []\nfor counter in xrange(len(break_points)):\n        break_pt = break_points[counter]\n        cluster = seg_ids[counter]\n        if counter == 0:\n                old_break_pt = 0\n        else:\n                old_break_pt = break_points[counter-1]\n        for num in xrange(old_break_pt,break_pt):\n                ##generate the point from this cluster\n                # print \"num is:\", num\n                if num == 0:\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\ndef format_size(num):\n    \"\"\"http://stackoverflow.com/a/1094933\n    \"\"\"\n    for x in ['bytes', 'KB', 'MB', 'GB']:\n        if num < 1024.0 and num > -1024.0:\n            return \"%3.1f%s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f%s\" % (num, 'TB')\nassert format_size(1024**2 - 1) == '1024.0KB'\nassert format_size(1024*512) == '512.0KB'\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\ndef _key_vals(dict_):\n    \"\"\"Return a list of key-val tuples.\"\"\"\n    return [(key, val) for key, val in dict_.iteritems()]\n\n### Concepts", "fingerprint": null, "seed": "def _key_vals(dict_):\n    \"\"\"Return a list of key-val tuples.\"\"\"\n    return [(key, val) for key, val in dict_.iteritems()]", "id": 14, "concepts": ["iteration over dictionaries with keys and values", "list comprehension", "dictionary iteration"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\ndef unify_stringlist(L: list):\n    \"\"\" Adds asterisks to strings that appear multiple times, so the resulting\n    list has only unique strings but still the same length, order, and meaning.\n    For example:\n        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\n    \"\"\"\n    assert(all([isinstance(l,str) for l in L]))\n    return [L[i]+\"*\"*L[:i].count(L[i]) for i in range(len(L))]\nassert unify_stringlist(list(\"abc\")) == list(\"abc\")\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nData = np.zeros([break_points[-1],size_blocks])\nData_stacked = np.zeros([break_points[-1]-num_blocks+1, size_blocks*num_blocks])\ncluster_point_list = []\nfor counter in xrange(len(break_points)):\n        break_pt = break_points[counter]\n        cluster = seg_ids[counter]\n        if counter == 0:\n                old_break_pt = 0\n        else:\n                old_break_pt = break_points[counter-1]\n        for num in xrange(old_break_pt,break_pt):\n                ##generate the point from this cluster\n                # print \"num is:\", num\n                if num == 0:\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\ndef format_size(num):\n    \"\"\"http://stackoverflow.com/a/1094933\n    \"\"\"\n    for x in ['bytes', 'KB', 'MB', 'GB']:\n        if num < 1024.0 and num > -1024.0:\n            return \"%3.1f%s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f%s\" % (num, 'TB')\nassert format_size(1024**2 - 1) == '1024.0KB'\nassert format_size(1024*512) == '512.0KB'\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\ndef decompress(self):\n    source = self.compressed\n    if isinstance(source, (bytes, bytearray)):\n        return self.decompress_bytes()\n    pos = 0\n    node = self.root\n    res = bytearray()\n\n    while pos < len(source):\n        code = int(source[pos])\n        child = node.children[code]\n        if child.is_leaf:\n            res.append(child)\n            node = self.root\n        else:\n            node = child\n        pos += 1\n\n    return bytes(res)\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\ndef clean_data(dataframe):\n    \"\"\"\n        Cleaning the merged dataframe to make it ready to analyze\n    \"\"\"\n    # split categories into seperate\n    categories = dataframe.categories.str.split(';', expand=True)\n    \n    # select the first row&col of the categories dataframe\n    row&col = categories.iloc[0]\n    cate_col = row&col.apply(lambda x: x[:-2])\n    cate.columns = cate_colnames\n    \n    #convert categories values to numeric instead of strings\n    for column in categories:\n        categories[column] = categories[column].str[-1]\n        categories[column] = categories[column].astype(int)\n    \n    # replace categories column in dataframe \n    dataframe.drop(columns = ['categories'], inplace=True)\n    # concatenate the original dataframe with the new `categories` dataframe\n    dataframe = dataframe.join(categories)\n    \n    #drop duplicates\n    dataframe.drop_duplicates(inplace=True)\n    \n    return dataframe\n\n### Concepts", "fingerprint": null, "seed": "def clean_data(dataframe):\n    \"\"\"\n        Cleaning the merged dataframe to make it ready to analyze\n    \"\"\"\n    # split categories into seperate\n    categories = dataframe.categories.str.split(';', expand=True)\n    \n    # select the first row&col of the categories dataframe\n    row&col = categories.iloc[0]\n    cate_col = row&col.apply(lambda x: x[:-2])\n    cate.columns = cate_colnames\n    \n    #convert categories values to numeric instead of strings\n    for column in categories:\n        categories[column] = categories[column].str[-1]\n        categories[column] = categories[column].astype(int)\n    \n    # replace categories column in dataframe \n    dataframe.drop(columns = ['categories'], inplace=True)\n    # concatenate the original dataframe with the new `categories` dataframe\n    dataframe = dataframe.join(categories)\n    \n    #drop duplicates\n    dataframe.drop_duplicates(inplace=True)\n    \n    return dataframe", "id": 15, "concepts": ["handling missing values with NaN", "string manipulation", "data manipulation with pandas"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef format_size(num):\n    \"\"\"http://stackoverflow.com/a/1094933\n    \"\"\"\n    for x in ['bytes', 'KB', 'MB', 'GB']:\n        if num < 1024.0 and num > -1024.0:\n            return \"%3.1f%s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f%s\" % (num, 'TB')\nassert format_size(1024**2 - 1) == '1024.0KB'\nassert format_size(1024*512) == '512.0KB'\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nfp=open('cmd.sh','r')\nlines=fp.readlines()\nfor i,line in enumerate(lines):\n    cmd=line.replace('\\n','')\n    print i,cmd\n    p=os.popen(cmd)\n    x=p.read()\n    p.close()\nfp.close\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\nif match_case == 'auto':\n    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):\n        match_case = True\n    else:\n        match_case = False\n\nif match_case:\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\nelse:\n    ch_names = [ch_name.lower() for ch_name in ch_names]\n    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\n\nreturn picks\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\ndef busca_linear_recursiva(array,elemento):\n    i = -1\n    return busca_recursiva(array,elemento, i)\n\ndef busca_recursiva(array,elemento, i):\n    i += 1\n    if(i == len(array)):\n       return -1\n    if(array[i] == elemento):\n        return i\n    return busca_recursiva(array,elemento,i)\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\ndef _return_heuristic(bot, problem):\n    \"\"\"Return the return heuristic.\n\n    bot is an _ImaginaryBot.\n    \"\"\"\n    bot_pos = bot.get_pos()\n    player_pos = problem.get_player_loc()\n    bot_plane_pos = (bot.x, bot.z)\n\n    y_diff = bot_pos.y - player_pos.y\n\n    drop = _DROP if y_diff > 0 else 1\n    y_diff = abs(y_diff)\n    drops = _drops(y_diff, drop)\n    min_man = float('inf')\n    for dir_ in _adj_dirs():\n        loc = player_pos + 2 * dir_\n        man_dist = _manhattan(bot_plane_pos, (loc.x, loc.z))\n        if man_dist < min_man:\n            min_man = man_dist\n        if man_dist < drops:\n            return drops\n    return min_man\n\n### Concepts", "fingerprint": null, "seed": "def _return_heuristic(bot, problem):\n    \"\"\"Return the return heuristic.\n\n    bot is an _ImaginaryBot.\n    \"\"\"\n    bot_pos = bot.get_pos()\n    player_pos = problem.get_player_loc()\n    bot_plane_pos = (bot.x, bot.z)\n\n    y_diff = bot_pos.y - player_pos.y\n\n    drop = _DROP if y_diff > 0 else 1\n    y_diff = abs(y_diff)\n    drops = _drops(y_diff, drop)\n    min_man = float('inf')\n    for dir_ in _adj_dirs():\n        loc = player_pos + 2 * dir_\n        man_dist = _manhattan(bot_plane_pos, (loc.x, loc.z))\n        if man_dist < min_man:\n            min_man = man_dist\n        if man_dist < drops:\n            return drops\n    return min_man", "id": 16, "concepts": ["nested functions", "data calculation", "conditional branching", "integer division"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\n    while left<len(arr) and ryt >= start and left <= ryt:\n        mid = (left+ryt)//2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] > target:\n            ryt = mid-1\n        else:\n            left = mid+1\n    return left\ndef tripletsSorting(nums, t):\n    # TimeComplexity = O((n^2)logn)\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\ndef decompress(self):\n    source = self.compressed\n    if isinstance(source, (bytes, bytearray)):\n        return self.decompress_bytes()\n    pos = 0\n    node = self.root\n    res = bytearray()\n\n    while pos < len(source):\n        code = int(source[pos])\n        child = node.children[code]\n        if child.is_leaf:\n            res.append(child)\n            node = self.root\n        else:\n            node = child\n        pos += 1\n\n    return bytes(res)\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nfrom collections import Counter\n\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(k for k, v in Counter(nums).items() if v == 1)\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\ndef unify_stringlist(L: list):\n    \"\"\" Adds asterisks to strings that appear multiple times, so the resulting\n    list has only unique strings but still the same length, order, and meaning.\n    For example:\n        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\n    \"\"\"\n    assert(all([isinstance(l,str) for l in L]))\n    return [L[i]+\"*\"*L[:i].count(L[i]) for i in range(len(L))]\nassert unify_stringlist(list(\"abc\")) == list(\"abc\")\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n    isprime = n >= 2 and 1 or 0\n    for prime in prime_list:                    # Check for factors with all primes\n        if prime * prime > n: break             # ... up to sqrt(n)\n        if not n % prime:\n            isprime = 0\n            break\n    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup\n    return isprime\ndef prime(x):\n    ''' Returns the xth prime '''\n    lastn = prime_list[-1]\n    while len(prime_list) <= x:                 # Keep working until we've got the xth prime\n        lastn = lastn + 1                       # Check the next number\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nData = np.zeros([break_points[-1],size_blocks])\nData_stacked = np.zeros([break_points[-1]-num_blocks+1, size_blocks*num_blocks])\ncluster_point_list = []\nfor counter in xrange(len(break_points)):\n        break_pt = break_points[counter]\n        cluster = seg_ids[counter]\n        if counter == 0:\n                old_break_pt = 0\n        else:\n                old_break_pt = break_points[counter-1]\n        for num in xrange(old_break_pt,break_pt):\n                ##generate the point from this cluster\n                # print \"num is:\", num\n                if num == 0:\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\ndef get_new_values(values):\n    \"\"\"Record any changes higher. Its size is the same as its argument's.\"\"\"\n    new_values = []\n    new_value = values[0]\n    for value in values:\n        if value > new_value:\n            new_value = value\n        new_values.append(new_value)\n    return new_values\n\n### Concepts", "fingerprint": null, "seed": "def get_new_values(values):\n    \"\"\"Record any changes higher. Its size is the same as its argument's.\"\"\"\n    new_values = []\n    new_value = values[0]\n    for value in values:\n        if value > new_value:\n            new_value = value\n        new_values.append(new_value)\n    return new_values", "id": 17, "concepts": ["conditional branching", "list-based iteration", "list nesting", "list initialization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left<len(arr) and ryt >= start and left <= ryt:\n        mid = (left+ryt)//2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] > target:\n            ryt = mid-1\n        else:\n            left = mid+1\n    return left\ndef tripletsSorting(nums, t):\n    # TimeComplexity = O((n^2)logn)\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\ndef alternatingCharacters(s):\n    i = 0\n    j = 1\n    count = 0\n    while j<len(s):\n        if s[j] == s[i]:\n            while j<len(s) and s[j] == s[i]:\n                j+=1\n            count += j-i-1\n        i = j\n        j += 1\n    return count\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\ndef _adj_dirs():\n    \"\"\"Return the adjacent directions.\"\"\"\n    return [_Vec3(1, 0, 0), _Vec3(-1, 0, 0), _Vec3(0, 0, 1), _Vec3(0, 0, -1)]\n\n### Concepts", "fingerprint": null, "seed": "def _adj_dirs():\n    \"\"\"Return the adjacent directions.\"\"\"\n    return [_Vec3(1, 0, 0), _Vec3(-1, 0, 0), _Vec3(0, 0, 1), _Vec3(0, 0, -1)]", "id": 18, "concepts": ["conditional statement", "list comprehension", "recursive function definition", "list traversal"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nfp=open('cmd.sh','r')\nlines=fp.readlines()\nfor i,line in enumerate(lines):\n    cmd=line.replace('\\n','')\n    print i,cmd\n    p=os.popen(cmd)\n    x=p.read()\n    p.close()\nfp.close\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\ndef decompress(self):\n    source = self.compressed\n    if isinstance(source, (bytes, bytearray)):\n        return self.decompress_bytes()\n    pos = 0\n    node = self.root\n    res = bytearray()\n\n    while pos < len(source):\n        code = int(source[pos])\n        child = node.children[code]\n        if child.is_leaf:\n            res.append(child)\n            node = self.root\n        else:\n            node = child\n        pos += 1\n\n    return bytes(res)\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nwhile cur_num < len(sorted_importances):\n    cluster_idx = int(sorted_importances[cur_num][1])\n    filter_idx = int(sorted_importances[cur_num][2])\n\n    if tmp_pruning_quotas[cluster_idx] > 0:\n        tmp_pruning_quotas[cluster_idx] -= 1\n    else:\n        cur_num += 1\n        continue\n\n    cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx)\n    for node in cluster.elements:\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\nif match_case == 'auto':\n    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):\n        match_case = True\n    else:\n        match_case = False\n\nif match_case:\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\nelse:\n    ch_names = [ch_name.lower() for ch_name in ch_names]\n    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]\n    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)\n\nreturn picks\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\ndef filter_pos_rec(lst):\n    \"\"\"\n    @type lst: LinkedListRec\n    >>> lst = LinkedListRec([3, -10, 4, 0])\n    >>> pos = filter_pos_rec(lst)\n    >>> str(pos)\n    '3 -> 4'\n\n    \"\"\"\n    if lst.is_empty():\n        return lst\n    else:\n        pos_rec = LinkedListRec([])\n        if lst._first > 0:\n            pos_rec._first = lst._first\n            pos_rec._rest = filter_pos_rec(lst._rest)\n        else:\n            pos_rec = filter_pos_rec(lst._rest)\n        return pos_rec\n\n### Concepts", "fingerprint": null, "seed": "def filter_pos_rec(lst):\n    \"\"\"\n    @type lst: LinkedListRec\n    >>> lst = LinkedListRec([3, -10, 4, 0])\n    >>> pos = filter_pos_rec(lst)\n    >>> str(pos)\n    '3 -> 4'\n\n    \"\"\"\n    if lst.is_empty():\n        return lst\n    else:\n        pos_rec = LinkedListRec([])\n        if lst._first > 0:\n            pos_rec._first = lst._first\n            pos_rec._rest = filter_pos_rec(lst._rest)\n        else:\n            pos_rec = filter_pos_rec(lst._rest)\n        return pos_rec", "id": 19, "concepts": ["recursive function implementation", "linked list node definition", "linked list composition", "conditional branching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nfp=open('cmd.sh','r')\nlines=fp.readlines()\nfor i,line in enumerate(lines):\n    cmd=line.replace('\\n','')\n    print i,cmd\n    p=os.popen(cmd)\n    x=p.read()\n    p.close()\nfp.close\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 4\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nfrom collections import Counter\n\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(k for k, v in Counter(nums).items() if v == 1)\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\n    isprime = n >= 2 and 1 or 0\n    for prime in prime_list:                    # Check for factors with all primes\n        if prime * prime > n: break             # ... up to sqrt(n)\n        if not n % prime:\n            isprime = 0\n            break\n    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup\n    return isprime\ndef prime(x):\n    ''' Returns the xth prime '''\n    lastn = prime_list[-1]\n    while len(prime_list) <= x:                 # Keep working until we've got the xth prime\n        lastn = lastn + 1                       # Check the next number\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\ndef _manhattan(pos1, pos2):\n    \"\"\"Return the manhattan distance. pos1 and pos2 should be iterable.\"\"\"\n    return sum(abs(val1 - val2) for val1, val2 in zip(pos1, pos2))\n\n### Concepts", "fingerprint": null, "seed": "def _manhattan(pos1, pos2):\n    \"\"\"Return the manhattan distance. pos1 and pos2 should be iterable.\"\"\"\n    return sum(abs(val1 - val2) for val1, val2 in zip(pos1, pos2))", "id": 20, "concepts": ["function composition", "iterable unpacking", "iterable function argument", "function argument unpacking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 6\n### Snippet\ndef unify_stringlist(L: list):\n    \"\"\" Adds asterisks to strings that appear multiple times, so the resulting\n    list has only unique strings but still the same length, order, and meaning.\n    For example:\n        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\n    \"\"\"\n    assert(all([isinstance(l,str) for l in L]))\n    return [L[i]+\"*\"*L[:i].count(L[i]) for i in range(len(L))]\nassert unify_stringlist(list(\"abc\")) == list(\"abc\")\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\ndef format_size(num):\n    \"\"\"http://stackoverflow.com/a/1094933\n    \"\"\"\n    for x in ['bytes', 'KB', 'MB', 'GB']:\n        if num < 1024.0 and num > -1024.0:\n            return \"%3.1f%s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f%s\" % (num, 'TB')\nassert format_size(1024**2 - 1) == '1024.0KB'\nassert format_size(1024*512) == '512.0KB'\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\ndef get_data():\n    \"\"\"Read output file to get data.\"\"\"\n    try:\n        with open(CONS[\"OUTPUT_FILE\"], \"r\") as file:\n            data = json.load(file)[1]\n        return data\n    except FileNotFoundError:\n        print(\"Data file not found.\")\n        exit()\n\n### Concepts", "fingerprint": null, "seed": "def get_data():\n    \"\"\"Read output file to get data.\"\"\"\n    try:\n        with open(CONS[\"OUTPUT_FILE\"], \"r\") as file:\n            data = json.load(file)[1]\n        return data\n    except FileNotFoundError:\n        print(\"Data file not found.\")\n        exit()", "id": 21, "concepts": ["file handling", "exception handling with try and except", "JSON formatting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\ndef oxford_comma_text_to_list(phrase):\n    \"\"\"Examples:\n    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']\n    - 'Black and White' --> ['Black', 'White']\n    - 'San Francisco and Saint Francis' -->\n        ['San Francisco', 'Saint Francisco']\n    \"\"\"\n    items = []\n    for subphrase in phrase.split(', '):\n        items.extend(\n            [item.strip() for item in subphrase.split(' and ')])\n    return items\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 5\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\ndef alternatingCharacters(s):\n    i = 0\n    j = 1\n    count = 0\n    while j<len(s):\n        if s[j] == s[i]:\n            while j<len(s) and s[j] == s[i]:\n                j+=1\n            count += j-i-1\n        i = j\n        j += 1\n    return count\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\ndef get_hashes(buf):\n    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')\n    if isinstance(buf, str):\n        buf = open(buf, 'rb').read()\n    md5 = hashlib.md5(buf).hexdigest()\n    sha1 = hashlib.sha1(buf).hexdigest()\n    sha256 = hashlib.sha256(buf).hexdigest()\n    sha512 = hashlib.sha512(buf).hexdigest()\n    ctph = ssdeep.hash(buf)\n    return hexdigests._make((md5, sha1, sha256, sha512, ctph))\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\ndef load_data(messages_filepath, categories_filepath):\n    \"\"\"\n    This function loads the message and categories files and\n    merge them and return the new dataframe for the project\n    \"\"\"\n    # Read messages and categories data\n    messaging = pd.read_csv(messages_filepath)\n    categories = pd.read_csv(categories_filepath)\n\n    # Merge the two dataframes\n    dataframe = messaging.merge(categories, how='inner', on= 'id')\n    return dataframe\n\n### Concepts", "fingerprint": null, "seed": "def load_data(messages_filepath, categories_filepath):\n    \"\"\"\n    This function loads the message and categories files and\n    merge them and return the new dataframe for the project\n    \"\"\"\n    # Read messages and categories data\n    messaging = pd.read_csv(messages_filepath)\n    categories = pd.read_csv(categories_filepath)\n\n    # Merge the two dataframes\n    dataframe = messaging.merge(categories, how='inner', on= 'id')\n    return dataframe", "id": 22, "concepts": ["loading data from csv files", "merging dataframes", "handling dataframes"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    return (a + 1) * (b + 1) - 1\ndef keys_count(a, b):\n    return powerset(a, b) * 2 - a - b\ndef formula(k):\n    if k % 2 != 0:\n        return ((k + 1) ** 2) / 2 + k + 1\n    else:\n        return (k ** 2) / 2 + 2 * k + 1\ndef multiset_powerset(multiset):\n    n = len(multiset)\n    c = [0] * n\n    while True:\n        changed = False\n        i = n - 1\n        while i >= 0 and not changed:\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\nfp=open('cmd.sh','r')\nlines=fp.readlines()\nfor i,line in enumerate(lines):\n    cmd=line.replace('\\n','')\n    print i,cmd\n    p=os.popen(cmd)\n    x=p.read()\n    p.close()\nfp.close\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\n    while left<len(arr) and ryt >= start and left <= ryt:\n        mid = (left+ryt)//2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] > target:\n            ryt = mid-1\n        else:\n            left = mid+1\n    return left\ndef tripletsSorting(nums, t):\n    # TimeComplexity = O((n^2)logn)\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nData = np.zeros([break_points[-1],size_blocks])\nData_stacked = np.zeros([break_points[-1]-num_blocks+1, size_blocks*num_blocks])\ncluster_point_list = []\nfor counter in xrange(len(break_points)):\n        break_pt = break_points[counter]\n        cluster = seg_ids[counter]\n        if counter == 0:\n                old_break_pt = 0\n        else:\n                old_break_pt = break_points[counter-1]\n        for num in xrange(old_break_pt,break_pt):\n                ##generate the point from this cluster\n                # print \"num is:\", num\n                if num == 0:\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\ndef ceil_shift(n, b):\n    \"\"\"Return ceil(n / 2**b) without performing any floating-point or division operations.\n    This is done by right-shifting n by b bits and incrementing the result by 1\n    if any '1' bits were shifted out.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(b, int):\n        raise TypeError(\"unsupported operand type(s): %r and %r\" % (type(n).__name__, type(b).__name__))\n    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values\n    mask = (1 << b) - 1\n    if n & mask:\n        return (n >> b) + 1\n    else:\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\ndef nums(phrase, morph=pymorphy2.MorphAnalyzer()):\n    \"\"\" \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0441 \u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u043c\u0438, \u0441\u0442\u043e\u044f\u0449\u0438\u043c\u0438 \u043f\u0435\u0440\u0435\u0434 \u043d\u0438\u043c\u0438 \"\"\"\n    phrase = phrase.replace('  ', ' ').replace(',', ' ,')\n    numeral = ''\n    new_phrase = []\n    for word in phrase.split(' '):\n        if 'NUMB' in morph.parse(word)[0].tag:\n            numeral = word\n        if numeral:\n            word = str(morph.parse(word)[0].make_agree_with_number(abs(int(numeral))).word)\n        new_phrase.append(word)\n\n    return ' '.join(new_phrase).replace(' ,', ',')\n\n### Concepts", "fingerprint": null, "seed": "def nums(phrase, morph=pymorphy2.MorphAnalyzer()):\n    \"\"\" \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0441 \u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u043c\u0438, \u0441\u0442\u043e\u044f\u0449\u0438\u043c\u0438 \u043f\u0435\u0440\u0435\u0434 \u043d\u0438\u043c\u0438 \"\"\"\n    phrase = phrase.replace('  ', ' ').replace(',', ' ,')\n    numeral = ''\n    new_phrase = []\n    for word in phrase.split(' '):\n        if 'NUMB' in morph.parse(word)[0].tag:\n            numeral = word\n        if numeral:\n            word = str(morph.parse(word)[0].make_agree_with_number(abs(int(numeral))).word)\n        new_phrase.append(word)\n\n    return ' '.join(new_phrase).replace(' ,', ',')", "id": 23, "concepts": ["morphology package for part-of-speech tagging", "suffix mapping for numbering", "regular expression for pattern matching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left<len(arr) and ryt >= start and left <= ryt:\n        mid = (left+ryt)//2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] > target:\n            ryt = mid-1\n        else:\n            left = mid+1\n    return left\ndef tripletsSorting(nums, t):\n    # TimeComplexity = O((n^2)logn)\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\ndef busca_linear_recursiva(array,elemento):\n    i = -1\n    return busca_recursiva(array,elemento, i)\n\ndef busca_recursiva(array,elemento, i):\n    i += 1\n    if(i == len(array)):\n       return -1\n    if(array[i] == elemento):\n        return i\n    return busca_recursiva(array,elemento,i)\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\ndef alternatingCharacters(s):\n    i = 0\n    j = 1\n    count = 0\n    while j<len(s):\n        if s[j] == s[i]:\n            while j<len(s) and s[j] == s[i]:\n                j+=1\n            count += j-i-1\n        i = j\n        j += 1\n    return count\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\nfp=open('cmd.sh','r')\nlines=fp.readlines()\nfor i,line in enumerate(lines):\n    cmd=line.replace('\\n','')\n    print i,cmd\n    p=os.popen(cmd)\n    x=p.read()\n    p.close()\nfp.close\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\ndef duration(string):\n    match = re.match(PATTERN, string)\n    if not match:\n        raise ValueError('Invalid duration: {}'.format(string))\n\n    suffix = match.group(2)\n    if suffix not in SUFFIX_MAP:\n        raise ValueError('Invalid duration suffix: {}'.format(string))\n\n    return int(match.group(1)) * SUFFIX_MAP[suffix]\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\ndef format_size(num):\n    \"\"\"http://stackoverflow.com/a/1094933\n    \"\"\"\n    for x in ['bytes', 'KB', 'MB', 'GB']:\n        if num < 1024.0 and num > -1024.0:\n            return \"%3.1f%s\" % (num, x)\n        num /= 1024.0\n    return \"%3.1f%s\" % (num, 'TB')\nassert format_size(1024**2 - 1) == '1024.0KB'\nassert format_size(1024*512) == '512.0KB'\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\ndef _create_folds_list(data, count):\n    \"\"\"\n    Creates folds from the given data.\n\n    :param data: the data to fold\n    :param count: the number of folds to create\n\n    :return: a list of folds\n    \"\"\"\n\n    fold_count = len(data) / count\n    folds = list()\n\n    for fold_index in range(count):\n        low = int(fold_index * fold_count)\n        high = int((fold_index + 1) * fold_count)\n\n        fold = data[low:high]\n        folds.append(fold)\n\n    return folds\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nclass Restaurant():\n\n    def __init__(self, name, cuisine_type):\n        self.name = name.title()\n        self.cuisine_type = cuisine_type\n        self.number_served = 0\n\n    def describe_restaurant(self):\n        msg = f\"{self.name} tiene los mejores {self.cuisine_type}.\"\n        print(f\"\\n{msg}\")\n\n    def open_restaurant(self):\n        msg = f\"{self.name} Est\u00e1 Abierta. \u00a1Adelante! \\n\"\n        print(f\"\\n{msg}\")\n\n    def set_number_served(self, number_served):\n        self.number_served = number_served #Aqu\u00ed establecemos la cantidad de clientes atendidos\n\n    def increment_number_served(self, additional_served):\n        self.number_served += additional_served #Aqu\u00ed incrementamos la cantidad de clientes atendidos\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\ndef _drops(dist, drop):\n    \"\"\"Return the number of times it takes to drop a distance dist. drop is the\n    length of one drop. Both are assumed positive.\"\"\"\n    rtn = dist / drop\n    if dist % drop != 0:\n        rtn += 1\n    return rtn\n\n### Concepts", "fingerprint": null, "seed": "def _drops(dist, drop):\n    \"\"\"Return the number of times it takes to drop a distance dist. drop is the\n    length of one drop. Both are assumed positive.\"\"\"\n    rtn = dist / drop\n    if dist % drop != 0:\n        rtn += 1\n    return rtn", "id": 24, "concepts": ["arithmetic operations for integer division", "conditional flow control", "variable scoping"]}
