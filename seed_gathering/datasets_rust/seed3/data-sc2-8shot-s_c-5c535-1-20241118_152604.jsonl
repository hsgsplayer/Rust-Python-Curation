{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nfn parse_instruction(line: &str) -> Instruction {\n    let pieces: Vec<&str> = line.split_whitespace().collect();\n    \n    let register = String::from(pieces[0]);\n    let increase = match pieces[1] {\n        \"inc\" => true,\n        \"dec\" => false,\n        _     => panic!(\"Expected 'inc' or 'dec'.\"),\n    };\n    let value = pieces[2].parse::<i32>().expect(\"Could not parse instruction value as i32.\");\n\n    let condition_register = String::from(pieces[4]);\n    let condition_operator = match pieces[5] {\n        \"<\"  => Operator::LessThan,\n        \"<=\" => Operator::LessThanOrEqual,\n        \">\"  => Operator::GreaterThan,\n        \">=\" => Operator::GreaterThanOrEqual,\n        \"==\" => Operator::Equal,\n        \"!=\" => Operator::NotEqual,\n        _    => panic!(\"Unexpected condition operator.\"),\n    };\n    let condition_value = pieces[6].parse::<i32>().expect(\"Could not parse condition value as i32.\");\n\n    Instruction {\n        register,\n        increase,\n        value,\n        condition: Condition {\n            register: condition_register,\n            operator: condition_operator,\n            value: condition_value,\n        },\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn parse_instruction(line: &str) -> Instruction {\n    let pieces: Vec<&str> = line.split_whitespace().collect();\n    \n    let register = String::from(pieces[0]);\n    let increase = match pieces[1] {\n        \"inc\" => true,\n        \"dec\" => false,\n        _     => panic!(\"Expected 'inc' or 'dec'.\"),\n    };\n    let value = pieces[2].parse::<i32>().expect(\"Could not parse instruction value as i32.\");\n\n    let condition_register = String::from(pieces[4]);\n    let condition_operator = match pieces[5] {\n        \"<\"  => Operator::LessThan,\n        \"<=\" => Operator::LessThanOrEqual,\n        \">\"  => Operator::GreaterThan,\n        \">=\" => Operator::GreaterThanOrEqual,\n        \"==\" => Operator::Equal,\n        \"!=\" => Operator::NotEqual,\n        _    => panic!(\"Unexpected condition operator.\"),\n    };\n    let condition_value = pieces[6].parse::<i32>().expect(\"Could not parse condition value as i32.\");\n\n    Instruction {\n        register,\n        increase,\n        value,\n        condition: Condition {\n            register: condition_register,\n            operator: condition_operator,\n            value: condition_value,\n        },\n    }\n}", "id": 2, "concepts": ["string manipulation and parsing", "software design patterns"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\nfn send_err(stream: &mut TcpStream, err: Error) {\n    let _ = stream.write(err.to_string().as_bytes()).expect(\"failed a write\");\n}\n\n### Concepts", "fingerprint": null, "seed": "fn send_err(stream: &mut TcpStream, err: Error) {\n    let _ = stream.write(err.to_string().as_bytes()).expect(\"failed a write\");\n}", "id": 3, "concepts": ["error handling", "string formatting", "standard library functions", "return value checking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\nfn init_with_target() {\n    let project = project(\"init_with_target\").build();\n    project\n        .cargo_fuzz()\n        .arg(\"init\")\n        .arg(\"-t\")\n        .arg(\"custom_target_name\")\n        .assert()\n        .success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"custom_target_name\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"custom_target_name\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn init_with_target() {\n    let project = project(\"init_with_target\").build();\n    project\n        .cargo_fuzz()\n        .arg(\"init\")\n        .arg(\"-t\")\n        .arg(\"custom_target_name\")\n        .assert()\n        .success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"custom_target_name\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"custom_target_name\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}", "id": 4, "concepts": ["test-driven programming", "software design", "configuration files", "test-driven development", "file operations", "command-line argument passing", "assertions", "conditional branching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn up_to_release(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    to: &VersionTag,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    let to_commit = repo.find_commit(to.commit).map_err(|e| {\n        ErrorContext(\n            format!(\n                \"find_commit: repo={}, commit={}\",\n                repo.path().display(),\n                to.commit\n            ),\n            Box::new(e),\n        )\n    })?;\n    let modules = get_submodules(&repo, &to_commit)?;\n\n    let mut author_map = build_author_map(&repo, &reviewers, &mailmap, \"\", &to.raw_tag)\n        .map_err(|e| ErrorContext(format!(\"Up to {}\", to), e))?;\n\n    for module in &modules {\n        if let Ok(path) = update_repo(&module.repository) {\n            let subrepo = Repository::open(&path)?;\n            let submap = build_author_map(\n                &subrepo,\n                &reviewers,\n                &mailmap,\n                \"\",\n                &module.commit.to_string(),\n            )?;\n            author_map.extend(submap);\n        }\n    }\n\n    Ok(author_map)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn up_to_release(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    to: &VersionTag,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    let to_commit = repo.find_commit(to.commit).map_err(|e| {\n        ErrorContext(\n            format!(\n                \"find_commit: repo={}, commit={}\",\n                repo.path().display(),\n                to.commit\n            ),\n            Box::new(e),\n        )\n    })?;\n    let modules = get_submodules(&repo, &to_commit)?;\n\n    let mut author_map = build_author_map(&repo, &reviewers, &mailmap, \"\", &to.raw_tag)\n        .map_err(|e| ErrorContext(format!(\"Up to {}\", to), e))?;\n\n    for module in &modules {\n        if let Ok(path) = update_repo(&module.repository) {\n            let subrepo = Repository::open(&path)?;\n            let submap = build_author_map(\n                &subrepo,\n                &reviewers,\n                &mailmap,\n                \"\",\n                &module.commit.to_string(),\n            )?;\n            author_map.extend(submap);\n        }\n    }\n\n    Ok(author_map)\n}", "id": 5, "concepts": ["recursive function calls", "ownership", "dictionary mutation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 9\n### Snippet\npub fn test_andi() {\n    let buffer = fs::read(\"tests/programs/andi\").unwrap().into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"andi\".into()]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_andi() {\n    let buffer = fs::read(\"tests/programs/andi\").unwrap().into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"andi\".into()]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}", "id": 6, "concepts": ["test framework", "programming language features"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\npub unsafe extern \"C\" fn gatt_svr_register_cb(\n    ctxt: *mut ble_gatt_register_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) {\n    let mut buf_arr: [i8; BLE_UUID_STR_LEN as usize] = [0; BLE_UUID_STR_LEN as usize];\n    let buf = buf_arr.as_mut_ptr();\n\n    match (*ctxt).op as u32 {\n        BLE_GATT_REGISTER_OP_SVC => {\n            printf(\n                cstr!(\"registered service %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.svc.svc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.svc.handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_CHR => {\n            printf(\n                cstr!(\"registering characteristic %s with def_handle=%d val_handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.chr.chr_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.chr.def_handle as i32,\n                (*ctxt).__bindgen_anon_1.chr.val_handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_DSC => {\n            printf(\n                cstr!(\"registering descriptor %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.dsc.dsc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.dsc.handle as i32,\n            );\n        }\n        _ => {\n            printf(cstr!(\"unknown operation: %d\\n\"), (*ctxt).op as u32);\n        }\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "pub unsafe extern \"C\" fn gatt_svr_register_cb(\n    ctxt: *mut ble_gatt_register_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) {\n    let mut buf_arr: [i8; BLE_UUID_STR_LEN as usize] = [0; BLE_UUID_STR_LEN as usize];\n    let buf = buf_arr.as_mut_ptr();\n\n    match (*ctxt).op as u32 {\n        BLE_GATT_REGISTER_OP_SVC => {\n            printf(\n                cstr!(\"registered service %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.svc.svc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.svc.handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_CHR => {\n            printf(\n                cstr!(\"registering characteristic %s with def_handle=%d val_handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.chr.chr_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.chr.def_handle as i32,\n                (*ctxt).__bindgen_anon_1.chr.val_handle as i32,\n            );\n        }\n\n        BLE_GATT_REGISTER_OP_DSC => {\n            printf(\n                cstr!(\"registering descriptor %s with handle=%d\\n\"),\n                ble_uuid_to_str((*(*ctxt).__bindgen_anon_1.dsc.dsc_def).uuid, buf),\n                (*ctxt).__bindgen_anon_1.dsc.handle as i32,\n            );\n        }\n        _ => {\n            printf(cstr!(\"unknown operation: %d\\n\"), (*ctxt).op as u32);\n        }\n    }\n}", "id": 8, "concepts": ["C-like programming language", "memory access with unsafe", "general control flow with match expressions", "UUID conversion with string manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nfn system_call(message: SystemCall) -> SystemCall {\n    let addr = task_buffer_addr();\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn system_call(message: SystemCall) -> SystemCall {\n    let addr = task_buffer_addr();\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}", "id": 9, "concepts": ["system call abstraction", "C function call", "buffering", "concurrent execution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 6\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nfn run_alt_corpus() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_alt\");\n    let alt_corpus = Path::new(\"fuzz\").join(\"alt-corpus\").join(\"run_alt\");\n\n    let project = project(\"run_alt_corpus\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_alt\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() <= 1);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"fail\"), \"fail\")\n        .file(alt_corpus.join(\"pass-0\"), \"0\")\n        .file(alt_corpus.join(\"pass-1\"), \"1\")\n        .file(alt_corpus.join(\"pass-2\"), \"2\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_alt\")\n        .arg(&alt_corpus)\n        .arg(\"--\")\n        .arg(\"-runs=0\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"3 files found in fuzz/alt-corpus/run_alt\")\n                .and(predicate::str::contains(\"fuzz/corpus/run_alt\").not())\n                // libFuzzer will always test the empty input, so the number of\n                // runs performed is always one more than the number of files in\n                // the corpus.\n                .and(predicate::str::contains(\"Done 4 runs in\")),\n        )\n        .success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn run_alt_corpus() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_alt\");\n    let alt_corpus = Path::new(\"fuzz\").join(\"alt-corpus\").join(\"run_alt\");\n\n    let project = project(\"run_alt_corpus\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_alt\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() <= 1);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"fail\"), \"fail\")\n        .file(alt_corpus.join(\"pass-0\"), \"0\")\n        .file(alt_corpus.join(\"pass-1\"), \"1\")\n        .file(alt_corpus.join(\"pass-2\"), \"2\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_alt\")\n        .arg(&alt_corpus)\n        .arg(\"--\")\n        .arg(\"-runs=0\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"3 files found in fuzz/alt-corpus/run_alt\")\n                .and(predicate::str::contains(\"fuzz/corpus/run_alt\").not())\n                // libFuzzer will always test the empty input, so the number of\n                // runs performed is always one more than the number of files in\n                // the corpus.\n                .and(predicate::str::contains(\"Done 4 runs in\")),\n        )\n        .success();\n}", "id": 10, "concepts": ["fuzzing with provided corpus", "libFuzzer", "test framework", "command-line argument parsing", "output filtering"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn read_input_configurations(confs: Vec<PathBuf>) -> (Vec<ComponentEntry>, Vec<ComponentEntry>) {\n    let mut configurations = Vec::new();\n\n    for path in confs {\n        match read_configuration(&path) {\n            Ok(conf) => configurations.push(conf),\n            Err(err) => eprintln!(\"{}\", err),\n        }\n    }\n\n    eprint!(\"\\n\");\n\n    let current_dir = current_dir().unwrap_or(PathBuf::new());\n    let entries = configurations\n        .iter()\n        .map(|conf| ReadConf {\n            conf: None,\n            path: current_dir.join(&conf.path),\n            backup_conf: None,\n            description: conf.description.clone(),\n            volume_type: conf.volume_type.clone(),\n        })\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    let components = configurations\n        .into_iter()\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    (components, entries)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn read_input_configurations(confs: Vec<PathBuf>) -> (Vec<ComponentEntry>, Vec<ComponentEntry>) {\n    let mut configurations = Vec::new();\n\n    for path in confs {\n        match read_configuration(&path) {\n            Ok(conf) => configurations.push(conf),\n            Err(err) => eprintln!(\"{}\", err),\n        }\n    }\n\n    eprint!(\"\\n\");\n\n    let current_dir = current_dir().unwrap_or(PathBuf::new());\n    let entries = configurations\n        .iter()\n        .map(|conf| ReadConf {\n            conf: None,\n            path: current_dir.join(&conf.path),\n            backup_conf: None,\n            description: conf.description.clone(),\n            volume_type: conf.volume_type.clone(),\n        })\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    let components = configurations\n        .into_iter()\n        .map(|conf| ComponentEntry::ConfigurationFile(conf))\n        .collect::<Vec<_>>();\n\n    (components, entries)\n}", "id": 11, "concepts": ["file path manipulation", "environment variable lookup", "error handling", "file system access", "file paths resolution", "string manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\npub fn get_history(history_type: HistoryType) -> Result<String, ()> {\n    let configurator = Configurator::new();\n    let history = configurator.get_history(history_type);\n    // filter out empty string and not exist history path\n    let clean_history: Vec<&String> = match history_type {\n        HistoryType::WorkingFolder => history\n            .into_iter()\n            .filter(|s| !s.is_empty())\n            .filter(|s| Path::new(s).is_dir())\n            .collect::<Vec<_>>(),\n        _ => history\n            .into_iter()\n            .filter(|s| !s.is_empty())\n            .filter(|s| Path::new(s).is_file())\n            .collect::<Vec<_>>(),\n    };\n\n    let history_json_text =\n        serde_json::to_string(&clean_history).unwrap_or_else(|_| String::from(\"[]\"));\n    Ok(history_json_text)\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn get_history(history_type: HistoryType) -> Result<String, ()> {\n    let configurator = Configurator::new();\n    let history = configurator.get_history(history_type);\n    // filter out empty string and not exist history path\n    let clean_history: Vec<&String> = match history_type {\n        HistoryType::WorkingFolder => history\n            .into_iter()\n            .filter(|s| !s.is_empty())\n            .filter(|s| Path::new(s).is_dir())\n            .collect::<Vec<_>>(),\n        _ => history\n            .into_iter()\n            .filter(|s| !s.is_empty())\n            .filter(|s| Path::new(s).is_file())\n            .collect::<Vec<_>>(),\n    };\n\n    let history_json_text =\n        serde_json::to_string(&clean_history).unwrap_or_else(|_| String::from(\"[]\"));\n    Ok(history_json_text)\n}", "id": 12, "concepts": ["handling errors in data retrieval", "filtering out empty strings", "filtering based on path existence"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\nextern \"C\" fn gatt_svr_chr_access_heart_rate(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    /* Sensor location, set to \"Chest\" */\n    const BODY_SENS_LOC: u8 = 0x01;\n\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_HRS_BODY_SENSOR_LOC_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                &BODY_SENS_LOC as *const u8 as *const c_void,\n                size_of::<u8>() as u16,\n            )\n        };\n\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}\n\n### Concepts", "fingerprint": null, "seed": "extern \"C\" fn gatt_svr_chr_access_heart_rate(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    /* Sensor location, set to \"Chest\" */\n    const BODY_SENS_LOC: u8 = 0x01;\n\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_HRS_BODY_SENSOR_LOC_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                &BODY_SENS_LOC as *const u8 as *const c_void,\n                size_of::<u8>() as u16,\n            )\n        };\n\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}", "id": 13, "concepts": ["extern \"C\" function", "C binding", "C binding from Rust"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\nfn run_with_coverage() {\n    let target = \"with_coverage\";\n\n    let project = project(\"run_with_coverage\")\n        .with_fuzz()\n        .fuzz_target(\n            target,\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    println!(\"{:?}\", data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(target)\n        .arg(\"--\")\n        .arg(\"-runs=100\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 100 runs\"))\n        .success();\n\n    project\n        .cargo_fuzz()\n        .arg(\"coverage\")\n        .arg(target)\n        .assert()\n        .stderr(predicate::str::contains(\"Coverage data merged and saved\"))\n        .success();\n\n    let profdata_file = project.fuzz_coverage_dir(target).join(\"coverage.profdata\");\n    assert!(profdata_file.exists(), \"Coverage data file not generated\");\n}\n\n### Concepts", "fingerprint": null, "seed": "fn run_with_coverage() {\n    let target = \"with_coverage\";\n\n    let project = project(\"run_with_coverage\")\n        .with_fuzz()\n        .fuzz_target(\n            target,\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    println!(\"{:?}\", data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(target)\n        .arg(\"--\")\n        .arg(\"-runs=100\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 100 runs\"))\n        .success();\n\n    project\n        .cargo_fuzz()\n        .arg(\"coverage\")\n        .arg(target)\n        .assert()\n        .stderr(predicate::str::contains(\"Coverage data merged and saved\"))\n        .success();\n\n    let profdata_file = project.fuzz_coverage_dir(target).join(\"coverage.profdata\");\n    assert!(profdata_file.exists(), \"Coverage data file not generated\");\n}", "id": 14, "concepts": ["integration testing with `cargo-fuzz`", "fuzz test execution", "profdata file generation", "file manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nfn string_test() {\n    // literal\n    let speech = \"\\\"Ouch!\\\" said the well.\\n\";\n    println!(\"{}\", speech);\n    println!(\n        \"In the room the women come and go,\n         Singing of Mount Abora\"\n    );\n    println!(\n        \"It was a bright, cold day in Aplil, and \\\n         there were four of us \\\n         more or less.\"\n    );\n\n    let default_win_install_path = r\"C:\\Program Files\\Gorillas\";\n    println!(\"{}\", default_win_install_path);\n    // let pattern = Regex::new(r\"\\d(\\.\\d+)*\");\n\n    println!(\n        r###\"\n        This raw string started with 'r###\"'.\n        Therefore it does not end until we reach a quote mark ('\"')\n        followed immediately by three pound signs ('###'):\n    \"###\n    );\n\n    // byte strings\n    let method = b\"GET\";\n    assert_eq!(method, &[b'G', b'E', b'T']);\n\n    let noodles = \"noodles\".to_string();\n    let oodles = &noodles[1..];\n    let poodles = \"\\u{CA0}_\\u{CA0}\";\n\n    assert_eq!(oodles.len(), 6);\n    assert_eq!(poodles.len(), 7);\n    assert_eq!(poodles.chars().count(), 3);\n\n    // let mut s = \"hello\";\n    // s[0] = 'c'; error: tye thpe 'str' cannot be mutably indexed\n    // s.push('\\n'); error: no method named `push` found for type `&str`\n\n    assert_eq!(\n        format!(\"{}\u00b0 {:02}\u2019 {:02}\u201d N\", 24, 5, 23),\n        \"24\u00b0 05\u2019 23\u201d N\".to_string()\n    );\n    let bits = vec![\"veni\", \"vidi\", \"vici\"];\n    assert_eq!(bits.concat(), \"venividivici\");\n    assert_eq!(bits.join(\",\"), \"veni,vidi,vici\");\n\n    assert!(\"ONE\".to_lowercase() == \"one\");\n\n    assert!(\"peanut\".contains(\"nut\"));\n    assert_eq!(\"\\u{CA0}_\\u{CA0}\".replace(\"\\u{CA0}\", \"\u25a0\"), \"\u25a0_\u25a0\");\n    assert_eq!(\"     clean\\n\".trim(), \"clean\");\n\n    for word in \"veni, vidi, vici\".split(\", \") {\n        assert!(word.starts_with(\"v\"));\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn string_test() {\n    // literal\n    let speech = \"\\\"Ouch!\\\" said the well.\\n\";\n    println!(\"{}\", speech);\n    println!(\n        \"In the room the women come and go,\n         Singing of Mount Abora\"\n    );\n    println!(\n        \"It was a bright, cold day in Aplil, and \\\n         there were four of us \\\n         more or less.\"\n    );\n\n    let default_win_install_path = r\"C:\\Program Files\\Gorillas\";\n    println!(\"{}\", default_win_install_path);\n    // let pattern = Regex::new(r\"\\d(\\.\\d+)*\");\n\n    println!(\n        r###\"\n        This raw string started with 'r###\"'.\n        Therefore it does not end until we reach a quote mark ('\"')\n        followed immediately by three pound signs ('###'):\n    \"###\n    );\n\n    // byte strings\n    let method = b\"GET\";\n    assert_eq!(method, &[b'G', b'E', b'T']);\n\n    let noodles = \"noodles\".to_string();\n    let oodles = &noodles[1..];\n    let poodles = \"\\u{CA0}_\\u{CA0}\";\n\n    assert_eq!(oodles.len(), 6);\n    assert_eq!(poodles.len(), 7);\n    assert_eq!(poodles.chars().count(), 3);\n\n    // let mut s = \"hello\";\n    // s[0] = 'c'; error: tye thpe 'str' cannot be mutably indexed\n    // s.push('\\n'); error: no method named `push` found for type `&str`\n\n    assert_eq!(\n        format!(\"{}\u00b0 {:02}\u2019 {:02}\u201d N\", 24, 5, 23),\n        \"24\u00b0 05\u2019 23\u201d N\".to_string()\n    );\n    let bits = vec![\"veni\", \"vidi\", \"vici\"];\n    assert_eq!(bits.concat(), \"venividivici\");\n    assert_eq!(bits.join(\",\"), \"veni,vidi,vici\");\n\n    assert!(\"ONE\".to_lowercase() == \"one\");\n\n    assert!(\"peanut\".contains(\"nut\"));\n    assert_eq!(\"\\u{CA0}_\\u{CA0}\".replace(\"\\u{CA0}\", \"\u25a0\"), \"\u25a0_\u25a0\");\n    assert_eq!(\"     clean\\n\".trim(), \"clean\");\n\n    for word in \"veni, vidi, vici\".split(\", \") {\n        assert!(word.starts_with(\"v\"));\n    }\n}", "id": 15, "concepts": ["string formatting", "string concatenation", "conditional branching", "looping"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nfn commit_coauthors(commit: &Commit) -> Vec<Author> {\n    let mut coauthors = vec![];\n    if let Some(msg) = commit.message_raw() {\n        lazy_static::lazy_static! {\n            static ref RE: Regex =\n                RegexBuilder::new(r\"^Co-authored-by: (?P<name>.*) <(?P<email>.*)>\")\n                    .case_insensitive(true)\n                    .build()\n                    .unwrap();\n        }\n\n        for line in msg.lines().rev() {\n            if line.starts_with(\"Co-authored-by\") {\n                if let Some(caps) = RE.captures(line) {\n                    coauthors.push(Author {\n                        name: caps[\"name\"].to_string(),\n                        email: caps[\"email\"].to_string(),\n                    });\n                }\n            }\n        }\n    }\n    coauthors\n}\n\n### Concepts", "fingerprint": null, "seed": "fn commit_coauthors(commit: &Commit) -> Vec<Author> {\n    let mut coauthors = vec![];\n    if let Some(msg) = commit.message_raw() {\n        lazy_static::lazy_static! {\n            static ref RE: Regex =\n                RegexBuilder::new(r\"^Co-authored-by: (?P<name>.*) <(?P<email>.*)>\")\n                    .case_insensitive(true)\n                    .build()\n                    .unwrap();\n        }\n\n        for line in msg.lines().rev() {\n            if line.starts_with(\"Co-authored-by\") {\n                if let Some(caps) = RE.captures(line) {\n                    coauthors.push(Author {\n                        name: caps[\"name\"].to_string(),\n                        email: caps[\"email\"].to_string(),\n                    });\n                }\n            }\n        }\n    }\n    coauthors\n}", "id": 17, "concepts": ["regular expressions for pattern matching", "capturing groups", "iterating over lines"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nfn main() {\n    println!(\"Common letters in the box ids: {}\",\n             match find_common_id() {\n                 Some(s) => s,\n                 None => \"NA\".to_string()\n             });\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    println!(\"Common letters in the box ids: {}\",\n             match find_common_id() {\n                 Some(s) => s,\n                 None => \"NA\".to_string()\n             });\n}", "id": 19, "concepts": ["if-else-if-else branching", "optional value handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nfn init_twice() {\n    let project = project(\"init_twice\").build();\n\n    // First init should succeed and make all the things.\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n\n    // Second init should fail.\n    project\n        .cargo_fuzz()\n        .arg(\"init\")\n        .assert()\n        .stderr(predicates::str::contains(\"File exists (os error 17)\").and(\n            predicates::str::contains(format!(\n                \"failed to create directory {}\",\n                project.fuzz_dir().display()\n            )),\n        ))\n        .failure();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn init_twice() {\n    let project = project(\"init_twice\").build();\n\n    // First init should succeed and make all the things.\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n\n    // Second init should fail.\n    project\n        .cargo_fuzz()\n        .arg(\"init\")\n        .assert()\n        .stderr(predicates::str::contains(\"File exists (os error 17)\").and(\n            predicates::str::contains(format!(\n                \"failed to create directory {}\",\n                project.fuzz_dir().display()\n            )),\n        ))\n        .failure();\n}", "id": 20, "concepts": ["error message parsing with predicate", "multiple conditional branching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn get_command(stream: &mut TcpStream, buf: &mut[u8]) -> Result<Task, Error> {\n    let buf_sz = stream.read(buf).expect(\"failed to read from stream\");\n    let buf_usize = buf_sz as usize;\n\n    let v = match serde_json::from_slice::<Task>(&buf[..buf_usize]){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn get_command(stream: &mut TcpStream, buf: &mut[u8]) -> Result<Task, Error> {\n    let buf_sz = stream.read(buf).expect(\"failed to read from stream\");\n    let buf_usize = buf_sz as usize;\n\n    let v = match serde_json::from_slice::<Task>(&buf[..buf_usize]){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}", "id": 21, "concepts": ["JSON deserialization", "stream reading", "error handling", "type casting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\nfn print_uint(x:uint) {\n\tprintln!(\"{}\",x);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn print_uint(x:uint) {\n\tprintln!(\"{}\",x);\n}", "id": 22, "concepts": ["conditional statement", "function definition", "function call"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\npub fn day09_2(s: String) -> u32{\n    let mut running_total = 0;\n\n    let mut in_garbage = false;\n    let mut prev_cancel = false;\n    for c in s.chars(){\n        if in_garbage {\n            if c == '>' && !prev_cancel {\n                in_garbage = false;\n                prev_cancel = false;\n            }\n            else if c == '!' && !prev_cancel {\n                prev_cancel = true;\n            }\n            else if !prev_cancel{\n                running_total+=1;\n            }\n            else {\n                prev_cancel = false;\n            }\n        }\n        else{\n            if c == '<' {\n                in_garbage = true;\n                prev_cancel = false;\n            }\n        }\n    }\n    running_total\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn day09_2(s: String) -> u32{\n    let mut running_total = 0;\n\n    let mut in_garbage = false;\n    let mut prev_cancel = false;\n    for c in s.chars(){\n        if in_garbage {\n            if c == '>' && !prev_cancel {\n                in_garbage = false;\n                prev_cancel = false;\n            }\n            else if c == '!' && !prev_cancel {\n                prev_cancel = true;\n            }\n            else if !prev_cancel{\n                running_total+=1;\n            }\n            else {\n                prev_cancel = false;\n            }\n        }\n        else{\n            if c == '<' {\n                in_garbage = true;\n                prev_cancel = false;\n            }\n        }\n    }\n    running_total\n}", "id": 23, "concepts": ["string processing", "nested conditional branching", "ASCII character value calculations"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nfn add() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n\n    assert!(project.fuzz_cargo_toml().is_file());\n    let cargo_toml = fs::read_to_string(project.fuzz_cargo_toml()).unwrap();\n    let expected_bin_attrs = \"test = false\\ndoc = false\";\n    assert!(cargo_toml.contains(expected_bin_attrs));\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"new_fuzz_target\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn add() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n\n    assert!(project.fuzz_cargo_toml().is_file());\n    let cargo_toml = fs::read_to_string(project.fuzz_cargo_toml()).unwrap();\n    let expected_bin_attrs = \"test = false\\ndoc = false\";\n    assert!(cargo_toml.contains(expected_bin_attrs));\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"new_fuzz_target\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}", "id": 24, "concepts": ["file system operations", "command-line argument parsing", "string formatting and manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nfn a_table_should_read_what_was_put() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }]);\n  let mut vs = [Value::default(); 1];\n  table.read (1, &[0], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }]);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn a_table_should_read_what_was_put() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }]);\n  let mut vs = [Value::default(); 1];\n  table.read (1, &[0], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }]);\n}", "id": 25, "concepts": ["HashMap and TreeMap data structures", "read and write operations", "mutability"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\npub fn retype_cpool(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeCPool {\n        request: (source, target),\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn retype_cpool(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeCPool {\n        request: (source, target),\n    });\n}", "id": 26, "concepts": ["system call invocation", "enum-based system call interface", "function argument structuring"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\npub fn test_mulw64() {\n    let buffer = fs::read(\"tests/programs/mulw64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"mulw64\".into()]);\n    assert!(result.is_ok());\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_mulw64() {\n    let buffer = fs::read(\"tests/programs/mulw64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"mulw64\".into()]);\n    assert!(result.is_ok());\n}", "id": 27, "concepts": ["file reading", "Rust enum with associated values", "module nesting", "assertion checking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\npub fn test_custom_syscall() {\n    let buffer = fs::read(\"tests/programs/syscall64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .syscall(Box::new(CustomSyscall {}))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"syscall\".into()])\n        .unwrap();\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 39);\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_custom_syscall() {\n    let buffer = fs::read(\"tests/programs/syscall64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .syscall(Box::new(CustomSyscall {}))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"syscall\".into()])\n        .unwrap();\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 39);\n}", "id": 28, "concepts": ["custom syscall implementation", "`read` syscall function", "`fs::read` function", "`core::str::from_utf8` function", "string manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 8\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nfn get_default_database_paths() -> Vec<PathBuf> {\n    get_platform_dependent_data_dirs()\n        .into_iter()\n        .map(|dir| dir.join(\"grafen\").join(DEFAULT_DBNAME))\n        .collect()\n}\n\n### Concepts", "fingerprint": null, "seed": "fn get_default_database_paths() -> Vec<PathBuf> {\n    get_platform_dependent_data_dirs()\n        .into_iter()\n        .map(|dir| dir.join(\"grafen\").join(DEFAULT_DBNAME))\n        .collect()\n}", "id": 30, "concepts": ["iterating over a list of different types", "list comprehension", "file system API", "data path discovery"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nfn list() {\n    let project = project(\"add\").with_fuzz().build();\n\n    // Create some targets.\n    project.cargo_fuzz().arg(\"add\").arg(\"c\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"b\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"a\").assert().success();\n\n    // Make sure that we can list our targets, and that they're always sorted.\n    project\n        .cargo_fuzz()\n        .arg(\"list\")\n        .assert()\n        .stdout(\"a\\nb\\nc\\n\")\n        .success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn list() {\n    let project = project(\"add\").with_fuzz().build();\n\n    // Create some targets.\n    project.cargo_fuzz().arg(\"add\").arg(\"c\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"b\").assert().success();\n    project.cargo_fuzz().arg(\"add\").arg(\"a\").assert().success();\n\n    // Make sure that we can list our targets, and that they're always sorted.\n    project\n        .cargo_fuzz()\n        .arg(\"list\")\n        .assert()\n        .stdout(\"a\\nb\\nc\\n\")\n        .success();\n}", "id": 31, "concepts": ["testing a custom project", "implementation of the cargo fuzz subcommand", "handling command-line arguments for the fuzz target"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nextern \"C\" fn gatt_svr_chr_access_device_info(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_MODEL_NUMBER_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MODEL_NUM.as_ptr() as *const c_void,\n                MODEL_NUM.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    if uuid == GATT_MANUFACTURER_NAME_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MANUF_NAME.as_ptr() as *const c_void,\n                MANUF_NAME.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}\n\n### Concepts", "fingerprint": null, "seed": "extern \"C\" fn gatt_svr_chr_access_device_info(\n    _conn_handle: u16,\n    _attr_handle: u16,\n    ctxt: *mut ble_gatt_access_ctxt,\n    _arg: *mut ::core::ffi::c_void,\n) -> i32 {\n    let uuid: u16 = unsafe { ble_uuid_u16((*(*ctxt).__bindgen_anon_1.chr).uuid) };\n\n    if uuid == GATT_MODEL_NUMBER_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MODEL_NUM.as_ptr() as *const c_void,\n                MODEL_NUM.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    if uuid == GATT_MANUFACTURER_NAME_UUID {\n        let rc: i32 = unsafe {\n            os_mbuf_append(\n                (*ctxt).om,\n                MANUF_NAME.as_ptr() as *const c_void,\n                MANUF_NAME.len() as u16,\n            )\n        };\n        return if rc == 0 {\n            0\n        } else {\n            BLE_ATT_ERR_INSUFFICIENT_RES as i32\n        };\n    }\n\n    return BLE_ATT_ERR_UNLIKELY as i32;\n}", "id": 33, "concepts": ["C language interoperability (C FFI)", "string literal to bytes conversion", "precondition checking for type validation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nfn de_l(raw: f32, even: bool) -> i32 {\n    if even && raw < 0.0 {\n        (raw.ceil() - 1.0) as i32\n    } else {\n        raw.floor() as i32\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn de_l(raw: f32, even: bool) -> i32 {\n    if even && raw < 0.0 {\n        (raw.ceil() - 1.0) as i32\n    } else {\n        raw.floor() as i32\n    }\n}", "id": 35, "concepts": ["floating point comparisons", "truncation", "arithmetic operations", "conditional if statement"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\nfn cmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"foo\");\n    let project = project(\"cmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"foo\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let _ = data;\n                });\n            \"#,\n        )\n        .file(corpus.join(\"0\"), \"\")\n        .file(corpus.join(\"1\"), \"a\")\n        .file(corpus.join(\"2\"), \"ab\")\n        .file(corpus.join(\"3\"), \"abc\")\n        .file(corpus.join(\"4\"), \"abcd\")\n        .build();\n\n    let corpus_count = || {\n        fs::read_dir(project.root().join(\"fuzz\").join(\"corpus\").join(\"foo\"))\n            .unwrap()\n            .count()\n    };\n    assert_eq!(corpus_count(), 5);\n\n    project\n        .cargo_fuzz()\n        .arg(\"cmin\")\n        .arg(\"foo\")\n        .assert()\n        .success();\n    assert_eq!(corpus_count(), 1);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn cmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"foo\");\n    let project = project(\"cmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"foo\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let _ = data;\n                });\n            \"#,\n        )\n        .file(corpus.join(\"0\"), \"\")\n        .file(corpus.join(\"1\"), \"a\")\n        .file(corpus.join(\"2\"), \"ab\")\n        .file(corpus.join(\"3\"), \"abc\")\n        .file(corpus.join(\"4\"), \"abcd\")\n        .build();\n\n    let corpus_count = || {\n        fs::read_dir(project.root().join(\"fuzz\").join(\"corpus\").join(\"foo\"))\n            .unwrap()\n            .count()\n    };\n    assert_eq!(corpus_count(), 5);\n\n    project\n        .cargo_fuzz()\n        .arg(\"cmin\")\n        .arg(\"foo\")\n        .assert()\n        .success();\n    assert_eq!(corpus_count(), 1);\n}", "id": 37, "concepts": ["fuzzing with project_template", "file generation and manipulation", "file reading", "API call composition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nasync fn get_wifi_profile(ssid: &str) -> Option<String> {\n    delay_for(Duration::from_millis(10)).await;\n\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n            ssid,\n            obfstr::obfstr!(\"key=clear\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    Some(String::from_utf8_lossy(&output.stdout).to_string())\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn get_wifi_profile(ssid: &str) -> Option<String> {\n    delay_for(Duration::from_millis(10)).await;\n\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n            ssid,\n            obfstr::obfstr!(\"key=clear\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    Some(String::from_utf8_lossy(&output.stdout).to_string())\n}", "id": 39, "concepts": ["async/await", "delay implementation", "launching external program and output parsing", "API call validation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nfn is_rollup_commit(commit: &Commit) -> bool {\n    let summary = commit.summary().unwrap_or(\"\");\n    summary.starts_with(\"Rollup merge of #\")\n}\n\n### Concepts", "fingerprint": null, "seed": "fn is_rollup_commit(commit: &Commit) -> bool {\n    let summary = commit.summary().unwrap_or(\"\");\n    summary.starts_with(\"Rollup merge of #\")\n}", "id": 40, "concepts": ["logical conditional in a function implementation", "string matching and string literal"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\npub fn test_misaligned_jump64() {\n    let buffer = fs::read(\"tests/programs/misaligned_jump64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"misaligned_jump64\".into()]);\n    assert!(result.is_ok());\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_misaligned_jump64() {\n    let buffer = fs::read(\"tests/programs/misaligned_jump64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"misaligned_jump64\".into()]);\n    assert!(result.is_ok());\n}", "id": 41, "concepts": ["compilation with inline assembly", "memory layout", "program execution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\npub fn task_set_inactive(target: CAddr) {\n    system_call(SystemCall::TaskSetInactive {\n        request: target\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn task_set_inactive(target: CAddr) {\n    system_call(SystemCall::TaskSetInactive {\n        request: target\n    });\n}", "id": 42, "concepts": ["system call invocation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\npub fn checksum(input: &[u8]) -> Result<u16, LayerError> {\n    let mut sum = 0x00;\n    let mut chunks_iter = input.chunks_exact(2);\n    while let Some(chunk) = chunks_iter.next() {\n        sum += u32::from(u16::from_be_bytes(\n            chunk.try_into().expect(\"chunks of 2 bytes\"),\n        ));\n    }\n\n    if let [rem] = chunks_iter.remainder() {\n        sum += u32::from(u16::from_be_bytes([*rem, 0x00]));\n    }\n\n    let carry_add = (sum & 0xffff) + (sum >> 16);\n    let chksum = !(((carry_add & 0xffff) + (carry_add >> 16)) as u16);\n\n    Ok(chksum)\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn checksum(input: &[u8]) -> Result<u16, LayerError> {\n    let mut sum = 0x00;\n    let mut chunks_iter = input.chunks_exact(2);\n    while let Some(chunk) = chunks_iter.next() {\n        sum += u32::from(u16::from_be_bytes(\n            chunk.try_into().expect(\"chunks of 2 bytes\"),\n        ));\n    }\n\n    if let [rem] = chunks_iter.remainder() {\n        sum += u32::from(u16::from_be_bytes([*rem, 0x00]));\n    }\n\n    let carry_add = (sum & 0xffff) + (sum >> 16);\n    let chksum = !(((carry_add & 0xffff) + (carry_add >> 16)) as u16);\n\n    Ok(chksum)\n}", "id": 43, "concepts": ["checksum calculation with multiple base cases in recursion", "checksum calculation with 3 base cases in recursion", "checksum calculation with 1 base case in recursion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\npub fn var(v: Var) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::Var(v),\n        computed: false,\n    }))\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn var(v: Var) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::Var(v),\n        computed: false,\n    }))\n}", "id": 44, "concepts": ["ownership with reference counting", "closure in trait implementation", "Rc usage"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\npub fn map_raw_page_free(vaddr: usize, untyped: CAddr, toplevel_table: CAddr, page: CAddr) {\n    system_call(SystemCall::MapRawPageFree {\n        untyped: untyped,\n        toplevel_table: toplevel_table,\n        request: (vaddr, page),\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn map_raw_page_free(vaddr: usize, untyped: CAddr, toplevel_table: CAddr, page: CAddr) {\n    system_call(SystemCall::MapRawPageFree {\n        untyped: untyped,\n        toplevel_table: toplevel_table,\n        request: (vaddr, page),\n    });\n}", "id": 45, "concepts": ["system call invocation", "function parameter types", "untyped addresses"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 6\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\nfn santa(instruction: &String) -> i32 {\n    // if '(' up else if ')' down\n    let mut floor: i32 = 0;\n    for paren in instruction.chars() {\n        println!(\"{}\", paren);\n        match paren {\n            '(' => floor += 1,\n            ')' => floor -= 1,\n            _ => panic!(),\n        }\n    }\n    floor\n}\n\n### Concepts", "fingerprint": null, "seed": "fn santa(instruction: &String) -> i32 {\n    // if '(' up else if ')' down\n    let mut floor: i32 = 0;\n    for paren in instruction.chars() {\n        println!(\"{}\", paren);\n        match paren {\n            '(' => floor += 1,\n            ')' => floor -= 1,\n            _ => panic!(),\n        }\n    }\n    floor\n}", "id": 46, "concepts": ["stack-based algorithm", "iterating through a string", "panicking on invalid input"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\npub fn retype_raw_page_free(source: CAddr) -> CAddr {\n    let result = system_call(SystemCall::RetypeRawPageFree {\n        request: source,\n        response: None\n    });\n    match result {\n        SystemCall::RetypeRawPageFree {\n            response, ..\n        } => { return response.unwrap(); },\n        _ => panic!(),\n    };\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn retype_raw_page_free(source: CAddr) -> CAddr {\n    let result = system_call(SystemCall::RetypeRawPageFree {\n        request: source,\n        response: None\n    });\n    match result {\n        SystemCall::RetypeRawPageFree {\n            response, ..\n        } => { return response.unwrap(); },\n        _ => panic!(),\n    };\n}", "id": 47, "concepts": ["system call invocation", "function return value handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\npub fn test_op_rvc_slli_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_slli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_slli_crash_32\".into()]);\n    assert!(result.is_ok());\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_op_rvc_slli_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_slli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_slli_crash_32\".into()]);\n    assert!(result.is_ok());\n}", "id": 48, "concepts": ["LLVM IR parsing and execution", "symbolic execution of LLVM IR"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nfn reflect(v: &Vec3, n: &Vec3) -> Vec3 {\n    *v - *n * 2.0 * dot(v, n)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn reflect(v: &Vec3, n: &Vec3) -> Vec3 {\n    *v - *n * 2.0 * dot(v, n)\n}", "id": 49, "concepts": ["vector reflection", "vector operations with dot product", "vector decomposition", "immutable functions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\nfn main() {\n    gtk::init();\n\n    let mut window = gtk::Window::new(gtk::WindowType::TopLevel).unwrap();\n\n    window.set_title(\"TreeView Sample\");\n    window.set_window_position(gtk::WindowPosition::Center);\n\n    Connect::connect(&window, DeleteEvent::new(&mut |_| {\n        gtk::main_quit();\n        true\n    }));\n\n    // test Value\n\n    let hello = String::from(\"Hello world !\");\n    let value = glib::Value::new().unwrap();\n\n    value.init(glib::Type::String);\n    value.set(&hello);\n    println!(\"gvalue.get example : {}\", value.get::<String>());\n\n    // left pane\n\n    let mut left_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let left_store = gtk::ListStore::new(&column_types).unwrap();\n    let left_model = left_store.get_model().unwrap();\n\n    left_tree.set_model(&left_model);\n    left_tree.set_headers_visible(false);\n    append_text_column(&mut left_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n        left_store.append(&mut iter);\n        left_store.set_string(&iter, 0, \"I'm in a list\");\n    }\n\n    // right pane\n\n    let mut right_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let right_store = gtk::TreeStore::new(&column_types).unwrap();\n    let right_model = right_store.get_model().unwrap();\n\n    right_tree.set_model(&right_model);\n    right_tree.set_headers_visible(false);\n    append_text_column(&mut right_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut iter, None);\n        right_store.set_value(&iter, 0, &value);\n\n        let mut child_iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut child_iter, Some(&iter));\n        right_store.set_string(&child_iter, 0, \"I'm a child node\");\n    }\n\n    // display the panes\n\n    let mut split_pane = gtk::Box::new(gtk::Orientation::Horizontal, 10).unwrap();\n\n    split_pane.set_size_request(-1, -1);\n    split_pane.add(&left_tree);\n    split_pane.add(&right_tree);\n\n    window.add(&split_pane);\n    window.show_all();\n    gtk::main();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    gtk::init();\n\n    let mut window = gtk::Window::new(gtk::WindowType::TopLevel).unwrap();\n\n    window.set_title(\"TreeView Sample\");\n    window.set_window_position(gtk::WindowPosition::Center);\n\n    Connect::connect(&window, DeleteEvent::new(&mut |_| {\n        gtk::main_quit();\n        true\n    }));\n\n    // test Value\n\n    let hello = String::from(\"Hello world !\");\n    let value = glib::Value::new().unwrap();\n\n    value.init(glib::Type::String);\n    value.set(&hello);\n    println!(\"gvalue.get example : {}\", value.get::<String>());\n\n    // left pane\n\n    let mut left_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let left_store = gtk::ListStore::new(&column_types).unwrap();\n    let left_model = left_store.get_model().unwrap();\n\n    left_tree.set_model(&left_model);\n    left_tree.set_headers_visible(false);\n    append_text_column(&mut left_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n        left_store.append(&mut iter);\n        left_store.set_string(&iter, 0, \"I'm in a list\");\n    }\n\n    // right pane\n\n    let mut right_tree = gtk::TreeView::new().unwrap();\n    let column_types = [glib::Type::String];\n    let right_store = gtk::TreeStore::new(&column_types).unwrap();\n    let right_model = right_store.get_model().unwrap();\n\n    right_tree.set_model(&right_model);\n    right_tree.set_headers_visible(false);\n    append_text_column(&mut right_tree);\n\n    for _ in 0..10 {\n        let mut iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut iter, None);\n        right_store.set_value(&iter, 0, &value);\n\n        let mut child_iter = gtk::TreeIter::new().unwrap();\n\n        right_store.append(&mut child_iter, Some(&iter));\n        right_store.set_string(&child_iter, 0, \"I'm a child node\");\n    }\n\n    // display the panes\n\n    let mut split_pane = gtk::Box::new(gtk::Orientation::Horizontal, 10).unwrap();\n\n    split_pane.set_size_request(-1, -1);\n    split_pane.add(&left_tree);\n    split_pane.add(&right_tree);\n\n    window.add(&split_pane);\n    window.show_all();\n    gtk::main();\n}", "id": 50, "concepts": ["list comprehension", "list extension", "treeview", "treeiter", "treeiter-treeiter relationship", "treeview-treeiter relationship", "iter-iter relationship", "type conversion", "type casting", "treeview-liststore relationship", "liststore-treeiter relationship", "gvalue-treeiter relationship"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nconst fn null_ble_gatt_chr_def() -> ble_gatt_chr_def {\n    return ble_gatt_chr_def {\n        uuid: ptr::null(),\n        access_cb: None,\n        arg: (ptr::null_mut()),\n        descriptors: (ptr::null_mut()),\n        flags: 0,\n        min_key_size: 0,\n        val_handle: (ptr::null_mut()),\n    };\n}\n\n### Concepts", "fingerprint": null, "seed": "const fn null_ble_gatt_chr_def() -> ble_gatt_chr_def {\n    return ble_gatt_chr_def {\n        uuid: ptr::null(),\n        access_cb: None,\n        arg: (ptr::null_mut()),\n        descriptors: (ptr::null_mut()),\n        flags: 0,\n        min_key_size: 0,\n        val_handle: (ptr::null_mut()),\n    };\n}", "id": 51, "concepts": ["null pointer constants in Rust", "const functions", "pointer type", "return value"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 7\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nfn align_address(ptr: *const u8, align: usize) -> usize {\n    let addr = ptr as usize;\n    if addr % align != 0 {\n        align - addr % align\n    } else {\n        0\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn align_address(ptr: *const u8, align: usize) -> usize {\n    let addr = ptr as usize;\n    if addr % align != 0 {\n        align - addr % align\n    } else {\n        0\n    }\n}", "id": 52, "concepts": ["pointer alignment", "address calculation", "conditional branching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\npub fn test_contains_ckbforks_section() {\n    let buffer = fs::read(\"tests/programs/ckbforks\").unwrap();\n    let ckbforks_exists_v0 = || -> bool {\n        let elf = goblin_v023::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    let ckbforks_exists_v1 = || -> bool {\n        let elf = goblin_v040::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    assert_eq!(ckbforks_exists_v0, true);\n    assert_eq!(ckbforks_exists_v1, true);\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_contains_ckbforks_section() {\n    let buffer = fs::read(\"tests/programs/ckbforks\").unwrap();\n    let ckbforks_exists_v0 = || -> bool {\n        let elf = goblin_v023::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    let ckbforks_exists_v1 = || -> bool {\n        let elf = goblin_v040::elf::Elf::parse(&buffer).unwrap();\n        for section_header in &elf.section_headers {\n            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {\n                if r == \".ckb.forks\" {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }();\n    assert_eq!(ckbforks_exists_v0, true);\n    assert_eq!(ckbforks_exists_v1, true);\n}", "id": 53, "concepts": ["file system I/O", "parsing an ELF binary", "handling ELF binary sections"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\npub fn test_memory_store_empty_bytes() {\n    assert_memory_store_empty_bytes(&mut FlatMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut SparseMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut WXorXMemory::<FlatMemory<u64>>::default());\n    #[cfg(has_asm)]\n    assert_memory_store_empty_bytes(&mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000));\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_memory_store_empty_bytes() {\n    assert_memory_store_empty_bytes(&mut FlatMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut SparseMemory::<u64>::default());\n    assert_memory_store_empty_bytes(&mut WXorXMemory::<FlatMemory<u64>>::default());\n    #[cfg(has_asm)]\n    assert_memory_store_empty_bytes(&mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000));\n}", "id": 54, "concepts": ["memory store creation", "memory store interface", "advanced assertion checking", "return value testing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nfn build_serverprefix(s: ~str) -> Result<IRCToken, ~str> {\n    Ok(PrefixT(Prefix {nick: s, user: ~\"\", host: ~\"\"}))\n}\n\n### Concepts", "fingerprint": null, "seed": "fn build_serverprefix(s: ~str) -> Result<IRCToken, ~str> {\n    Ok(PrefixT(Prefix {nick: s, user: ~\"\", host: ~\"\"}))\n}", "id": 55, "concepts": ["control flow with Result", "named tuple construction", "string interpolation", "return value construction"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nfn main() {\n\n    #[cfg(feature = \"breakout\")]\n    let memfile_bytes = include_bytes!(\"stm32h743zi_memory.x\");\n    #[cfg(not(feature = \"breakout\"))]\n    let memfile_bytes = include_bytes!(\"stm32h743vi_memory.x\");\n\n    // Put the linker script somewhere the linker can find it\n    let out = &PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n    File::create(out.join(\"memory.x\"))\n        .unwrap()\n        .write_all(memfile_bytes)\n        .unwrap();\n    println!(\"cargo:rustc-link-search={}\", out.display());\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n\n    #[cfg(feature = \"breakout\")]\n    let memfile_bytes = include_bytes!(\"stm32h743zi_memory.x\");\n    #[cfg(not(feature = \"breakout\"))]\n    let memfile_bytes = include_bytes!(\"stm32h743vi_memory.x\");\n\n    // Put the linker script somewhere the linker can find it\n    let out = &PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n    File::create(out.join(\"memory.x\"))\n        .unwrap()\n        .write_all(memfile_bytes)\n        .unwrap();\n    println!(\"cargo:rustc-link-search={}\", out.display());\n}", "id": 56, "concepts": ["file system manipulation", "file input/output", "dynamic unit selection", "conditional compilation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn init_finds_parent_project() {\n    let project = project(\"init_finds_parent_project\").build();\n    project\n        .cargo_fuzz()\n        .current_dir(project.root().join(\"src\"))\n        .arg(\"init\")\n        .assert()\n        .success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n}\n\n### Concepts", "fingerprint": null, "seed": "fn init_finds_parent_project() {\n    let project = project(\"init_finds_parent_project\").build();\n    project\n        .cargo_fuzz()\n        .current_dir(project.root().join(\"src\"))\n        .arg(\"init\")\n        .assert()\n        .success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n}", "id": 57, "concepts": ["command-line argument parsing", "mocking project state", "file system operations"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nasync fn index(_req: HttpRequest) -> impl Responder {\n    HttpResponse::Ok().json(\"Catalog API root\")\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn index(_req: HttpRequest) -> impl Responder {\n    HttpResponse::Ok().json(\"Catalog API root\")\n}", "id": 58, "concepts": ["async/await syntax", "HTTP response formatting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\npub fn test_memory_load_bytes() {\n    let mut rng = thread_rng();\n\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 0);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 2);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 1024 * 6);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 0, 0);\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_memory_load_bytes() {\n    let mut rng = thread_rng();\n\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 0);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 2);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 1024 * 5, 1024 * 6);\n    assert_memory_load_bytes_all(&mut rng, RISCV_MAX_MEMORY, 0, 0);\n}", "id": 59, "concepts": ["random number generation", "global state management", "unit testing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn get_platform_dependent_data_dirs() -> Vec<PathBuf> {\n    let xdg_data_dirs_variable = var(\"XDG_DATA_DIRS\")\n        .unwrap_or(String::from(\"/usr/local/share:/usr/local\"));\n    let xdg_dirs_iter = xdg_data_dirs_variable.split(':').map(|s| Some(PathBuf::from(s)));\n\n    let dirs = if cfg!(target_os = \"macos\") {\n        vec![\n            var_os(\"XDG_DATA_HOME\").map(|dir| PathBuf::from(dir)),\n            home_dir().map(|dir| dir.join(\"Library\").join(\"Application Support\"))\n        ].into_iter()\n         .chain(xdg_dirs_iter)\n         .chain(vec![Some(PathBuf::from(\"/\").join(\"Library\").join(\"Application Support\"))])\n         .collect()\n    } else if cfg!(target_os = \"linux\") {\n        vec![\n            var_os(\"XDG_DATA_HOME\").map(|dir| PathBuf::from(dir)),\n            home_dir().map(|dir| dir.join(\".local\").join(\"share\"))\n        ].into_iter()\n         .chain(xdg_dirs_iter)\n         .collect()\n    } else if cfg!(target_os = \"windows\") {\n        vec![var_os(\"APPDATA\").map(|dir| PathBuf::from(dir))]\n    } else {\n        Vec::new()\n    };\n\n    dirs.into_iter().filter_map(|dir| dir).collect()\n}\n\n### Concepts", "fingerprint": null, "seed": "fn get_platform_dependent_data_dirs() -> Vec<PathBuf> {\n    let xdg_data_dirs_variable = var(\"XDG_DATA_DIRS\")\n        .unwrap_or(String::from(\"/usr/local/share:/usr/local\"));\n    let xdg_dirs_iter = xdg_data_dirs_variable.split(':').map(|s| Some(PathBuf::from(s)));\n\n    let dirs = if cfg!(target_os = \"macos\") {\n        vec![\n            var_os(\"XDG_DATA_HOME\").map(|dir| PathBuf::from(dir)),\n            home_dir().map(|dir| dir.join(\"Library\").join(\"Application Support\"))\n        ].into_iter()\n         .chain(xdg_dirs_iter)\n         .chain(vec![Some(PathBuf::from(\"/\").join(\"Library\").join(\"Application Support\"))])\n         .collect()\n    } else if cfg!(target_os = \"linux\") {\n        vec![\n            var_os(\"XDG_DATA_HOME\").map(|dir| PathBuf::from(dir)),\n            home_dir().map(|dir| dir.join(\".local\").join(\"share\"))\n        ].into_iter()\n         .chain(xdg_dirs_iter)\n         .collect()\n    } else if cfg!(target_os = \"windows\") {\n        vec![var_os(\"APPDATA\").map(|dir| PathBuf::from(dir))]\n    } else {\n        Vec::new()\n    };\n\n    dirs.into_iter().filter_map(|dir| dir).collect()\n}", "id": 61, "concepts": ["OS-dependent data paths", "environment variable usage", "path manipulations", "conditional compilation", "iteration over iterable collections"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nfn vector_test() {\n    {\n        fn build_vector() -> Vec<i16> {\n            let mut v: Vec<i16> = Vec::<i16>::new();\n            v.push(10i16);\n            v.push(20i16);\n            v\n        }\n\n        fn build_vector_2() -> Vec<i16> {\n            let mut v = Vec::new();\n            v.push(10);\n            v.push(20);\n            v\n        }\n        let v1 = build_vector();\n        let v2 = build_vector_2();\n        assert_eq!(v1, v2);\n    }\n    let mut v1 = vec![2, 3, 5, 7];\n    assert_eq!(v1.iter().fold(1, |a, b| a * b), 210);\n\n    v1.push(11);\n    v1.push(13);\n    assert_eq!(v1.iter().fold(1, |a, b| a * b), 30030);\n\n    let mut v2 = Vec::new();\n    v2.push(\"step\");\n    v2.push(\"on\");\n    v2.push(\"no\");\n    v2.push(\"pets\");\n    assert_eq!(v2, vec![\"step\", \"on\", \"no\", \"pets\"]);\n\n    let v3: Vec<i32> = (0..5).collect();\n    assert_eq!(v3, [0, 1, 2, 3, 4]);\n\n    let mut v4 = vec![\"a man\", \"a plan\", \"a canal\", \"panama\"];\n    v4.reverse();\n    assert_eq!(v4, vec![\"panama\", \"a canal\", \"a plan\", \"a man\"]);\n\n    let mut v5 = Vec::with_capacity(2);\n    assert_eq!(v5.len(), 0);\n    assert_eq!(v5.capacity(), 2);\n\n    v5.push(1);\n    v5.push(2);\n    assert_eq!(v5.len(), 2);\n    assert_eq!(v5.capacity(), 2);\n\n    v5.push(3);\n    assert_eq!(v5.len(), 3);\n    assert_eq!(v5.capacity(), 4);\n\n    let mut v6 = vec![10, 20, 30, 40, 50];\n\n    v6.insert(3, 35);\n    assert_eq!(v6, [10, 20, 30, 35, 40, 50]);\n\n    v6.remove(1);\n    assert_eq!(v6, [10, 30, 35, 40, 50]);\n\n    let mut v7 = vec![\"carmen\", \"miranda\"];\n    assert_eq!(v7.pop(), Some(\"miranda\"));\n    assert_eq!(v7.pop(), Some(\"carmen\"));\n    assert_eq!(v7.pop(), None);\n\n    // let languages: Vec<String> = std::env::args().skip(1).collect();\n    let languages = vec![\"Lisp\", \"Scheme\", \"C\", \"C++\", \"Fortran\"];\n    let mut v8 = Vec::new();\n    for l in languages {\n        if l.len() % 2 == 0 {\n            v8.push(\"functional\");\n        } else {\n            v8.push(\"imperative\");\n        }\n    }\n    assert_eq!(\n        v8,\n        [\n            \"functional\",\n            \"functional\",\n            \"imperative\",\n            \"imperative\",\n            \"imperative\"\n        ]\n    );\n\n    // slice\n\n    let v9: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];\n    let a9: [f64; 4] = [0.0, 0.707, 1.0, 0.707];\n\n    let sv: &[f64] = &v9;\n    let sa: &[f64] = &a9;\n\n    assert_eq!(sv[0..2], [0.0, 0.707]);\n    assert_eq!(sa[2..], [1.0, 0.707]);\n    assert_eq!(&sv[1..3], [0.707, 1.0]);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn vector_test() {\n    {\n        fn build_vector() -> Vec<i16> {\n            let mut v: Vec<i16> = Vec::<i16>::new();\n            v.push(10i16);\n            v.push(20i16);\n            v\n        }\n\n        fn build_vector_2() -> Vec<i16> {\n            let mut v = Vec::new();\n            v.push(10);\n            v.push(20);\n            v\n        }\n        let v1 = build_vector();\n        let v2 = build_vector_2();\n        assert_eq!(v1, v2);\n    }\n    let mut v1 = vec![2, 3, 5, 7];\n    assert_eq!(v1.iter().fold(1, |a, b| a * b), 210);\n\n    v1.push(11);\n    v1.push(13);\n    assert_eq!(v1.iter().fold(1, |a, b| a * b), 30030);\n\n    let mut v2 = Vec::new();\n    v2.push(\"step\");\n    v2.push(\"on\");\n    v2.push(\"no\");\n    v2.push(\"pets\");\n    assert_eq!(v2, vec![\"step\", \"on\", \"no\", \"pets\"]);\n\n    let v3: Vec<i32> = (0..5).collect();\n    assert_eq!(v3, [0, 1, 2, 3, 4]);\n\n    let mut v4 = vec![\"a man\", \"a plan\", \"a canal\", \"panama\"];\n    v4.reverse();\n    assert_eq!(v4, vec![\"panama\", \"a canal\", \"a plan\", \"a man\"]);\n\n    let mut v5 = Vec::with_capacity(2);\n    assert_eq!(v5.len(), 0);\n    assert_eq!(v5.capacity(), 2);\n\n    v5.push(1);\n    v5.push(2);\n    assert_eq!(v5.len(), 2);\n    assert_eq!(v5.capacity(), 2);\n\n    v5.push(3);\n    assert_eq!(v5.len(), 3);\n    assert_eq!(v5.capacity(), 4);\n\n    let mut v6 = vec![10, 20, 30, 40, 50];\n\n    v6.insert(3, 35);\n    assert_eq!(v6, [10, 20, 30, 35, 40, 50]);\n\n    v6.remove(1);\n    assert_eq!(v6, [10, 30, 35, 40, 50]);\n\n    let mut v7 = vec![\"carmen\", \"miranda\"];\n    assert_eq!(v7.pop(), Some(\"miranda\"));\n    assert_eq!(v7.pop(), Some(\"carmen\"));\n    assert_eq!(v7.pop(), None);\n\n    // let languages: Vec<String> = std::env::args().skip(1).collect();\n    let languages = vec![\"Lisp\", \"Scheme\", \"C\", \"C++\", \"Fortran\"];\n    let mut v8 = Vec::new();\n    for l in languages {\n        if l.len() % 2 == 0 {\n            v8.push(\"functional\");\n        } else {\n            v8.push(\"imperative\");\n        }\n    }\n    assert_eq!(\n        v8,\n        [\n            \"functional\",\n            \"functional\",\n            \"imperative\",\n            \"imperative\",\n            \"imperative\"\n        ]\n    );\n\n    // slice\n\n    let v9: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];\n    let a9: [f64; 4] = [0.0, 0.707, 1.0, 0.707];\n\n    let sv: &[f64] = &v9;\n    let sa: &[f64] = &a9;\n\n    assert_eq!(sv[0..2], [0.0, 0.707]);\n    assert_eq!(sa[2..], [1.0, 0.707]);\n    assert_eq!(&sv[1..3], [0.707, 1.0]);\n}", "id": 62, "concepts": ["explicit vector initialization", "vec! macro", "vector literal", "vector iteration", "vector slicing", "vector reverse", "vector capacity", "vector length", "vector push", "vector pop", "vector insert", "vector remove", "vector build with for loop"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 9\n### Snippet\npub fn channel_take_cap(target: CAddr) -> CAddr {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Cap(v) => return v.unwrap(),\n        _ => panic!(),\n    };\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn channel_take_cap(target: CAddr) -> CAddr {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Cap(v) => return v.unwrap(),\n        _ => panic!(),\n    };\n}", "id": 63, "concepts": ["explicit channel message handling", "explicit payload handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nfn main() {     \n        std::process::Command::new(\"packfolder.exe\").args(&[\"src/frontend\", \"dupa.rc\", \"-binary\"])\n    .output().expect(\"no i ciul\");\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {     \n        std::process::Command::new(\"packfolder.exe\").args(&[\"src/frontend\", \"dupa.rc\", \"-binary\"])\n    .output().expect(\"no i ciul\");\n}", "id": 64, "concepts": ["command-line argument parsing", "file system operations", "path manipulations", "file extraction"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn char_test() {\n    assert_eq!('*'.is_alphabetic(), false);\n    assert_eq!('\u03b2'.is_alphabetic(), true);\n    assert_eq!('8'.to_digit(10), Some(8));\n    assert_eq!('\\u{CA0}'.len_utf8(), 3);\n    assert_eq!(std::char::from_digit(2, 10), Some('2'));\n}\n\n### Concepts", "fingerprint": null, "seed": "fn char_test() {\n    assert_eq!('*'.is_alphabetic(), false);\n    assert_eq!('\u03b2'.is_alphabetic(), true);\n    assert_eq!('8'.to_digit(10), Some(8));\n    assert_eq!('\\u{CA0}'.len_utf8(), 3);\n    assert_eq!(std::char::from_digit(2, 10), Some('2'));\n}", "id": 65, "concepts": ["boolean test for character type", "character to integer conversion", "string iteration", "character length measurement"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 8\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\npub fn test_trace() {\n    let buffer = fs::read(\"tests/programs/trace64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"trace64\".into()]);\n    assert!(result.is_err());\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_trace() {\n    let buffer = fs::read(\"tests/programs/trace64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"trace64\".into()]);\n    assert!(result.is_err());\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 66, "concepts": ["function composition", "trait implementation", "return value handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 5\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn parseLightInfo(reader: &mut BufReader<&File>, buf: &mut String, lights: &mut Vec<Light>) -> Model {\r\n    let mut light = Light {\r\n        lightType: \"\" as str,\r\n        radius: 0.0,\r\n        period: 0,\r\n        position: Vec3f::new(0.0, 0.0, 0.0),\r\n        Color: Vec3f::new(0.0, 0.0, 0.0),\r\n    };\r\n    //Firstly, read the LigthType\r\n    reader.read_line(buf);\r\n    let lightType: &str = buf.trim().clone();\r\n    let mut key = \"\";\r\n    let mut radius = \"\";\r\n    let mut period = 0;\r\n    if lightType == \"o\" || lightType == \"l\" {\r\n        let mut infoIndex = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        radius = split_info.next().unwrap().parse().unwrap();\r\n        period = split_info.next().unwrap().parse().unwrap();\r\n    }\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 2 {\r\n        //Then, read the position and Color Info\r\n        split_info = buf.split(\" \");\r\n        let mut fieldInfo = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        if infoIndex == 1 {\r\n            light.position = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        } else {\r\n            light.Color = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        }\r\n        infoIndex += 1\r\n    }\r\n    //Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n    lights.push(light);\r\n}\n\n### Concepts", "fingerprint": null, "seed": "fn parseLightInfo(reader: &mut BufReader<&File>, buf: &mut String, lights: &mut Vec<Light>) -> Model {\r\n    let mut light = Light {\r\n        lightType: \"\" as str,\r\n        radius: 0.0,\r\n        period: 0,\r\n        position: Vec3f::new(0.0, 0.0, 0.0),\r\n        Color: Vec3f::new(0.0, 0.0, 0.0),\r\n    };\r\n    //Firstly, read the LigthType\r\n    reader.read_line(buf);\r\n    let lightType: &str = buf.trim().clone();\r\n    let mut key = \"\";\r\n    let mut radius = \"\";\r\n    let mut period = 0;\r\n    if lightType == \"o\" || lightType == \"l\" {\r\n        let mut infoIndex = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        radius = split_info.next().unwrap().parse().unwrap();\r\n        period = split_info.next().unwrap().parse().unwrap();\r\n    }\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 2 {\r\n        //Then, read the position and Color Info\r\n        split_info = buf.split(\" \");\r\n        let mut fieldInfo = 0;\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        key = split_info.next().unwrap().parse().unwrap();\r\n        if infoIndex == 1 {\r\n            light.position = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        } else {\r\n            light.Color = Vec3f::new(\r\n                x: split_info.next().unwrap().parse().unwrap(),\r\n                y: split_info.next().unwrap().parse().unwrap(),\r\n                z: split_info.next().unwrap().parse().unwrap(),\r\n            )\r\n        }\r\n        infoIndex += 1\r\n    }\r\n    //Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n    lights.push(light);\r\n}", "id": 67, "concepts": ["string parsing", "text file parsing", "nested structure parsing", "variable initialization", "list comprehension with multiple elements", "conditional branching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\npub fn task_set_stack_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetStackPointer {\n        request: (target, ptr),\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn task_set_stack_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetStackPointer {\n        request: (target, ptr),\n    });\n}", "id": 68, "concepts": ["system call wrapper", "C pointer manipulation", "structure deconstruction", "function pointer deconstruction for struct arguments"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nfn run_diagnostic_contains_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\"run_with_crash\", None);\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"yes_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    run_with_crash::fail_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    let run = format!(\n        \"cargo fuzz run --fuzz-dir {} yes_crash custom_dir/artifacts/yes_crash\",\n        &fuzz_dir\n    );\n\n    let tmin = format!(\n        \"cargo fuzz tmin --fuzz-dir {} yes_crash custom_dir/artifacts/yes_crash\",\n        &fuzz_dir\n    );\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"yes_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(predicates::str::contains(run).and(predicate::str::contains(tmin)))\n        .failure();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn run_diagnostic_contains_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\"run_with_crash\", None);\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"yes_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    run_with_crash::fail_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    let run = format!(\n        \"cargo fuzz run --fuzz-dir {} yes_crash custom_dir/artifacts/yes_crash\",\n        &fuzz_dir\n    );\n\n    let tmin = format!(\n        \"cargo fuzz tmin --fuzz-dir {} yes_crash custom_dir/artifacts/yes_crash\",\n        &fuzz_dir\n    );\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"yes_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(predicates::str::contains(run).and(predicate::str::contains(tmin)))\n        .failure();\n}", "id": 69, "concepts": ["fuzzing", "custom directory", "fuzz target name", "using a custom directory"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\npub fn test_op_rvc_srai_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_srai_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srai_crash_32\".into()]);\n    assert!(result.is_ok());\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_op_rvc_srai_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_srai_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srai_crash_32\".into()]);\n    assert!(result.is_ok());\n}", "id": 70, "concepts": ["loading program from a file", "unwrapping of Optional values", "vector initialization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\nfn alloc_svc_def() -> *const ble_gatt_svc_def {\n    leaky_box!(\n        ble_gatt_svc_def {\n            type_: BLE_GATT_SVC_TYPE_PRIMARY as u8,\n            uuid: ble_uuid16_declare!(GATT_HRS_UUID),\n            includes: ptr::null_mut(),\n            characteristics: leaky_box!(\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_HRS_MEASUREMENT_UUID),\n                    access_cb: Some(gatt_svr_chr_access_heart_rate),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_NOTIFY as u16,\n                    min_key_size: 0,\n                    val_handle: (unsafe { &mut HRS_HRM_HANDLE as *mut u16 }),\n                },\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_HRS_BODY_SENSOR_LOC_UUID),\n                    access_cb: Some(gatt_svr_chr_access_heart_rate),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_READ as u16,\n                    min_key_size: 0,\n                    val_handle: ptr::null_mut(),\n                },\n                null_ble_gatt_chr_def()\n            )\n        },\n        ble_gatt_svc_def {\n            type_: BLE_GATT_SVC_TYPE_PRIMARY as u8,\n            uuid: ble_uuid16_declare!(GATT_DEVICE_INFO_UUID),\n            includes: ptr::null_mut(),\n            characteristics: leaky_box!(\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_MANUFACTURER_NAME_UUID),\n                    access_cb: Some(gatt_svr_chr_access_device_info),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_READ as u16,\n                    min_key_size: 0,\n                    val_handle: (ptr::null_mut()),\n                },\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_MODEL_NUMBER_UUID),\n                    access_cb: Some(gatt_svr_chr_access_device_info),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_READ as u16,\n                    min_key_size: 0,\n                    val_handle: (ptr::null_mut()),\n                },\n                null_ble_gatt_chr_def()\n            )\n        },\n        null_ble_gatt_svc_def()\n    )\n}\n\n### Concepts", "fingerprint": null, "seed": "fn alloc_svc_def() -> *const ble_gatt_svc_def {\n    leaky_box!(\n        ble_gatt_svc_def {\n            type_: BLE_GATT_SVC_TYPE_PRIMARY as u8,\n            uuid: ble_uuid16_declare!(GATT_HRS_UUID),\n            includes: ptr::null_mut(),\n            characteristics: leaky_box!(\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_HRS_MEASUREMENT_UUID),\n                    access_cb: Some(gatt_svr_chr_access_heart_rate),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_NOTIFY as u16,\n                    min_key_size: 0,\n                    val_handle: (unsafe { &mut HRS_HRM_HANDLE as *mut u16 }),\n                },\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_HRS_BODY_SENSOR_LOC_UUID),\n                    access_cb: Some(gatt_svr_chr_access_heart_rate),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_READ as u16,\n                    min_key_size: 0,\n                    val_handle: ptr::null_mut(),\n                },\n                null_ble_gatt_chr_def()\n            )\n        },\n        ble_gatt_svc_def {\n            type_: BLE_GATT_SVC_TYPE_PRIMARY as u8,\n            uuid: ble_uuid16_declare!(GATT_DEVICE_INFO_UUID),\n            includes: ptr::null_mut(),\n            characteristics: leaky_box!(\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_MANUFACTURER_NAME_UUID),\n                    access_cb: Some(gatt_svr_chr_access_device_info),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_READ as u16,\n                    min_key_size: 0,\n                    val_handle: (ptr::null_mut()),\n                },\n                ble_gatt_chr_def {\n                    uuid: ble_uuid16_declare!(GATT_MODEL_NUMBER_UUID),\n                    access_cb: Some(gatt_svr_chr_access_device_info),\n                    arg: (ptr::null_mut()),\n                    descriptors: (ptr::null_mut()),\n                    flags: BLE_GATT_CHR_F_READ as u16,\n                    min_key_size: 0,\n                    val_handle: (ptr::null_mut()),\n                },\n                null_ble_gatt_chr_def()\n            )\n        },\n        null_ble_gatt_svc_def()\n    )\n}", "id": 71, "concepts": ["macros for declaring constants", "null values in structure definitions", "opaque pointers", "heap-allocated memory allocation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\npub fn test_invalid_file_offset64() {\n    let buffer = fs::read(\"tests/programs/invalid_file_offset64\")\n        .unwrap()\n        .into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"invalid_file_offset64\".into()]);\n    assert_eq!(result.err(), Some(Error::ElfSegmentAddrOrSizeError));\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_invalid_file_offset64() {\n    let buffer = fs::read(\"tests/programs/invalid_file_offset64\")\n        .unwrap()\n        .into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"invalid_file_offset64\".into()]);\n    assert_eq!(result.err(), Some(Error::ElfSegmentAddrOrSizeError));\n}", "id": 72, "concepts": ["error handling", "trait bounds", "return values from functions", "using a higher-order for loop"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nfn main() {\n  let mut prod_env = \"\".to_string();\n\n  let ws_server_thread = thread::Builder::new().name(\"ws_server\".to_string()).spawn(move || {\n      println!(\"Starting websocket server..\");\n      listen(\"127.0.0.1:3012\", |out| { Server { out: out } }).unwrap()\n  }).unwrap();\n\n  thread::sleep(time::Duration::from_millis(1000));\n  match env::var(\"PROD_ENV\".to_string()) {\n      Ok(val) => prod_env = val,\n      Err(e) => println!(\"Operating in dev mode due to: {}\", e),\n  }\n\n  if prod_env != \"\" {\n    let app_router_thread = thread::Builder::new().name(\"app_router\".to_string()).spawn(move || {\n        let mut app_router = Nickel::new();\n        println!(\"Starting app router..\");\n        app_router.mount(\"/controller/\", StaticFilesHandler::new(\"app/controller/\"));\n        app_router.mount(\"/display/\", StaticFilesHandler::new(\"app/display/\"));\n        app_router.listen(\"127.0.0.1:6767\").unwrap();\n    }).unwrap();\n    let _ = app_router_thread.join();\n  }\n\n  let _ = ws_server_thread.join();\n  println!(\"Server closing down..\");\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n  let mut prod_env = \"\".to_string();\n\n  let ws_server_thread = thread::Builder::new().name(\"ws_server\".to_string()).spawn(move || {\n      println!(\"Starting websocket server..\");\n      listen(\"127.0.0.1:3012\", |out| { Server { out: out } }).unwrap()\n  }).unwrap();\n\n  thread::sleep(time::Duration::from_millis(1000));\n  match env::var(\"PROD_ENV\".to_string()) {\n      Ok(val) => prod_env = val,\n      Err(e) => println!(\"Operating in dev mode due to: {}\", e),\n  }\n\n  if prod_env != \"\" {\n    let app_router_thread = thread::Builder::new().name(\"app_router\".to_string()).spawn(move || {\n        let mut app_router = Nickel::new();\n        println!(\"Starting app router..\");\n        app_router.mount(\"/controller/\", StaticFilesHandler::new(\"app/controller/\"));\n        app_router.mount(\"/display/\", StaticFilesHandler::new(\"app/display/\"));\n        app_router.listen(\"127.0.0.1:6767\").unwrap();\n    }).unwrap();\n    let _ = app_router_thread.join();\n  }\n\n  let _ = ws_server_thread.join();\n  println!(\"Server closing down..\");\n}", "id": 73, "concepts": ["string manipulation", "thread creation through closures", "asynchronous thread joining", "environment variable handling for conditional execution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\nasync fn retrieve_pairs() {\n    let exchange = init().await;\n    let pairs = exchange.refresh_market_info().await.unwrap();\n    println!(\"{:?}\", pairs);\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn retrieve_pairs() {\n    let exchange = init().await;\n    let pairs = exchange.refresh_market_info().await.unwrap();\n    println!(\"{:?}\", pairs);\n}", "id": 74, "concepts": ["async/await", "async function", "await", "asynchronous IO"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nasync fn main() -> Result<!, String> {\n    // Begin by parsing the arguments. We are either a server or a client, and\n    // we need an address and potentially a sleep duration.\n    let args: Vec<_> = env::args().collect();\n\n    match &*args {\n        [_, mode, url]             if mode == \"server\" => server(url).await?,\n        [_, mode, url]             if mode == \"client\" => client(url, tokio::io::stdin()).await?,\n        [_, mode, url, input_file] if mode == \"client\" => {\n            match tokio::fs::File::open(input_file).await {\n                Ok(file) => client(url, file).await?,\n                Err(err) => {\n                    eprintln!(\"Failed to open input_file: \\\"{}\\\", error: {}\", input_file, err);\n                    process::exit(2);\n                }\n            }\n        }\n        _ => {\n            eprintln!(\"Usage:\\n{0} server <url>\\n  or\\n{0} client <url> [input_file]\", args[0]);\n            process::exit(1);\n        }\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn main() -> Result<!, String> {\n    // Begin by parsing the arguments. We are either a server or a client, and\n    // we need an address and potentially a sleep duration.\n    let args: Vec<_> = env::args().collect();\n\n    match &*args {\n        [_, mode, url]             if mode == \"server\" => server(url).await?,\n        [_, mode, url]             if mode == \"client\" => client(url, tokio::io::stdin()).await?,\n        [_, mode, url, input_file] if mode == \"client\" => {\n            match tokio::fs::File::open(input_file).await {\n                Ok(file) => client(url, file).await?,\n                Err(err) => {\n                    eprintln!(\"Failed to open input_file: \\\"{}\\\", error: {}\", input_file, err);\n                    process::exit(2);\n                }\n            }\n        }\n        _ => {\n            eprintln!(\"Usage:\\n{0} server <url>\\n  or\\n{0} client <url> [input_file]\", args[0]);\n            process::exit(1);\n        }\n    }\n}", "id": 75, "concepts": ["command-line argument parsing", "pattern matching", "asynchronous IO"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nasync fn main() -> std::io::Result<()> {\n    dotenv().ok();\n    let app_data = AppData {\n        conn_pool: database::create_pool(),\n    };\n\n    let mut listenfd = ListenFd::from_env();\n    let mut server = HttpServer::new(move || {\n        App::new()\n            .data(app_data.clone())\n            .service(index)\n            .configure(routes::config)\n            .default_service(web::route().to(fallback_route))\n            .wrap(middlewares::auth_middleware::Logging)\n            .wrap(Cors::new().finish())\n            .wrap(IdentityService::new(\n                CookieIdentityPolicy::new(\n                    env::var(\"COOKIE_SECRET\")\n                        .unwrap_or(\"DEFAULT_SECRET\".to_string())\n                        .as_bytes(),\n                )\n                .name(\"auth\")\n                .path(\"/\")\n                .domain(env::var(\"APP_DOMAIN\").unwrap_or(\"localhost\".to_string()))\n                .max_age(chrono::Duration::days(1).num_seconds())\n                .secure(false),\n            ))\n    });\n\n    server = if let Some(l) = listenfd.take_tcp_listener(0).unwrap() {\n        server.listen(l)?\n    } else {\n        server.bind(\"localhost:8000\")?\n    };\n\n    server.run().await\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn main() -> std::io::Result<()> {\n    dotenv().ok();\n    let app_data = AppData {\n        conn_pool: database::create_pool(),\n    };\n\n    let mut listenfd = ListenFd::from_env();\n    let mut server = HttpServer::new(move || {\n        App::new()\n            .data(app_data.clone())\n            .service(index)\n            .configure(routes::config)\n            .default_service(web::route().to(fallback_route))\n            .wrap(middlewares::auth_middleware::Logging)\n            .wrap(Cors::new().finish())\n            .wrap(IdentityService::new(\n                CookieIdentityPolicy::new(\n                    env::var(\"COOKIE_SECRET\")\n                        .unwrap_or(\"DEFAULT_SECRET\".to_string())\n                        .as_bytes(),\n                )\n                .name(\"auth\")\n                .path(\"/\")\n                .domain(env::var(\"APP_DOMAIN\").unwrap_or(\"localhost\".to_string()))\n                .max_age(chrono::Duration::days(1).num_seconds())\n                .secure(false),\n            ))\n    });\n\n    server = if let Some(l) = listenfd.take_tcp_listener(0).unwrap() {\n        server.listen(l)?\n    } else {\n        server.bind(\"localhost:8000\")?\n    };\n\n    server.run().await\n}", "id": 76, "concepts": ["async/await", "HTTP server", "database connection pool", "environment variables", "middleware", "web framework configuration"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\npub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\n    Board::new(n as usize).solve()\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\n    Board::new(n as usize).solve()\n}", "id": 78, "concepts": ["backtracking algorithm", "exhaustive search"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nfn default_handler(irqn: i16) {\n    panic!(\"Unhandled exception (IRQn = {})\", irqn);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn default_handler(irqn: i16) {\n    panic!(\"Unhandled exception (IRQn = {})\", irqn);\n}", "id": 79, "concepts": ["default exception handler", "panic with error message"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\npub fn channel_put_cap(target: CAddr, value: CAddr) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Cap(Some(value)))\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn channel_put_cap(target: CAddr, value: CAddr) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Cap(Some(value)))\n    });\n}", "id": 80, "concepts": ["system call abstraction", "function overloading", "channel message", "conversion to `Cap`"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\npub fn test_wxorx_crash_64() {\n    let buffer = fs::read(\"tests/programs/wxorx_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"wxorx_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_wxorx_crash_64() {\n    let buffer = fs::read(\"tests/programs/wxorx_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"wxorx_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}", "id": 81, "concepts": ["file reading", "error handling", "error type checking", "test framework"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn de_board(raw: Vec<usize>, t: isize, l: i32, width: u8, height: u8) -> game::Board {\n    let mut res = game::Board::new(t, l, width, height);\n    res.pieces = raw\n        .into_iter()\n        .map(|x| game::Piece::from(x))\n        .collect();\n    res\n}\n\n### Concepts", "fingerprint": null, "seed": "fn de_board(raw: Vec<usize>, t: isize, l: i32, width: u8, height: u8) -> game::Board {\n    let mut res = game::Board::new(t, l, width, height);\n    res.pieces = raw\n        .into_iter()\n        .map(|x| game::Piece::from(x))\n        .collect();\n    res\n}", "id": 82, "concepts": ["Vector initialization", "functional programming techniques in a single line", "pattern matching and type conversion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\npub fn day09_1(s : String) -> u32{\n    let mut running_total = 0;\n    let mut scope = 0;\n\n    let mut in_garbage = false;\n    let mut prev_cancel = false;\n    for c in s.chars(){\n        if in_garbage {\n            if c == '>' && !prev_cancel {\n                in_garbage = false;\n                prev_cancel = false;\n            }\n            else if c == '!' && !prev_cancel {\n                prev_cancel = true;\n            }\n            else {\n                prev_cancel = false;\n            }\n        }\n        else{\n            if c == '{' {\n                scope+=1;\n                running_total+=scope;\n            }\n            else if c == '}' {\n                scope -=1;\n            }\n            else if c == '<' {\n                in_garbage = true;\n            }\n        }\n    }\n    running_total\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn day09_1(s : String) -> u32{\n    let mut running_total = 0;\n    let mut scope = 0;\n\n    let mut in_garbage = false;\n    let mut prev_cancel = false;\n    for c in s.chars(){\n        if in_garbage {\n            if c == '>' && !prev_cancel {\n                in_garbage = false;\n                prev_cancel = false;\n            }\n            else if c == '!' && !prev_cancel {\n                prev_cancel = true;\n            }\n            else {\n                prev_cancel = false;\n            }\n        }\n        else{\n            if c == '{' {\n                scope+=1;\n                running_total+=scope;\n            }\n            else if c == '}' {\n                scope -=1;\n            }\n            else if c == '<' {\n                in_garbage = true;\n            }\n        }\n    }\n    running_total\n}", "id": 83, "concepts": ["string manipulation", "parsing", "string slices", "unrolling a loop", "iteration with indices"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nfn loadResFromMesh(model: &mut Model, meshFilePath: &str) {}\n\n### Concepts", "fingerprint": null, "seed": "fn loadResFromMesh(model: &mut Model, meshFilePath: &str) {}", "id": 85, "concepts": ["string manipulation", "string interpolation", "string parsing", "string concatenation", "string formatting", "string escaping", "string concatenation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nfn app() -> App<\n    impl ServiceFactory<\n        ServiceRequest,\n        Response = ServiceResponse<impl MessageBody>,\n        Config = (),\n        InitError = (),\n        Error = Error,\n    >,\n> {\n    App::new()\n}\n\n### Concepts", "fingerprint": null, "seed": "fn app() -> App<\n    impl ServiceFactory<\n        ServiceRequest,\n        Response = ServiceResponse<impl MessageBody>,\n        Config = (),\n        InitError = (),\n        Error = Error,\n    >,\n> {\n    App::new()\n}", "id": 86, "concepts": ["trait implementation", "constructor pattern", "service instantiation", "function return"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\npub fn task_set_top_page_table(target: CAddr, table: CAddr) {\n    system_call(SystemCall::TaskSetTopPageTable {\n        request: (target, table),\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn task_set_top_page_table(target: CAddr, table: CAddr) {\n    system_call(SystemCall::TaskSetTopPageTable {\n        request: (target, table),\n    });\n}", "id": 87, "concepts": ["system call interface", "explicit type conversion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 8\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nfn run_no_crash() {\n    let project = project(\"run_no_crash\")\n        .with_fuzz()\n        .fuzz_target(\n            \"no_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    #[cfg(fuzzing_repro)]\n                    eprintln!(\"Reproducing a crash\");\n\n                    run_no_crash::pass_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"no_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Done 1000 runs\")\n                .and(predicate::str::contains(\"Reproducing a crash\").not()),\n        )\n        .success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn run_no_crash() {\n    let project = project(\"run_no_crash\")\n        .with_fuzz()\n        .fuzz_target(\n            \"no_crash\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    #[cfg(fuzzing_repro)]\n                    eprintln!(\"Reproducing a crash\");\n\n                    run_no_crash::pass_fuzzing(data);\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"no_crash\")\n        .arg(\"--\")\n        .arg(\"-runs=1000\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Done 1000 runs\")\n                .and(predicate::str::contains(\"Reproducing a crash\").not()),\n        )\n        .success();\n}", "id": 88, "concepts": ["fuzzing", "crash reproduction", "fuzzing and crash reproduction on the Rust fuzzing platform", "string and regex matching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nfn generate_thanks() -> Result<BTreeMap<VersionTag, AuthorMap>, Box<dyn std::error::Error>> {\n    let path = update_repo(\"https://github.com/rust-lang/rust.git\")?;\n    let repo = git2::Repository::open(&path)?;\n    let mailmap = mailmap_from_repo(&repo)?;\n    let reviewers = Reviewers::new()?;\n\n    let mut versions = get_versions(&repo)?;\n    let last_full_stable = versions\n        .iter()\n        .rfind(|v| v.raw_tag.ends_with(\".0\"))\n        .unwrap()\n        .version\n        .clone();\n\n    versions.push(VersionTag {\n        name: String::from(\"Beta\"),\n        version: {\n            let mut last = last_full_stable.clone();\n            last.minor += 1;\n            last\n        },\n        raw_tag: String::from(\"beta\"),\n        commit: repo\n            .revparse_single(\"beta\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n    versions.push(VersionTag {\n        name: String::from(\"Master\"),\n        version: {\n            // master is plus 1 minor versions off of beta, which we just pushed\n            let mut last = last_full_stable.clone();\n            last.minor += 2;\n            last\n        },\n        raw_tag: String::from(\"master\"),\n        commit: repo\n            .revparse_single(\"master\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n\n    let mut version_map = BTreeMap::new();\n\n    let mut cache = HashMap::new();\n\n    for (idx, version) in versions.iter().enumerate() {\n        let previous = if let Some(v) = idx.checked_sub(1).map(|idx| &versions[idx]) {\n            v\n        } else {\n            let author_map = build_author_map(&repo, &reviewers, &mailmap, \"\", &version.raw_tag)?;\n            version_map.insert(version.clone(), author_map);\n            continue;\n        };\n\n        eprintln!(\"Processing {:?} to {:?}\", previous, version);\n\n        cache.insert(\n            version,\n            up_to_release(&repo, &reviewers, &mailmap, &version)?,\n        );\n        let previous = match cache.remove(&previous) {\n            Some(v) => v,\n            None => up_to_release(&repo, &reviewers, &mailmap, &previous)?,\n        };\n        let current = cache.get(&version).unwrap();\n\n        // Remove commits reachable from the previous release.\n        let only_current = current.difference(&previous);\n        version_map.insert(version.clone(), only_current);\n    }\n\n    Ok(version_map)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn generate_thanks() -> Result<BTreeMap<VersionTag, AuthorMap>, Box<dyn std::error::Error>> {\n    let path = update_repo(\"https://github.com/rust-lang/rust.git\")?;\n    let repo = git2::Repository::open(&path)?;\n    let mailmap = mailmap_from_repo(&repo)?;\n    let reviewers = Reviewers::new()?;\n\n    let mut versions = get_versions(&repo)?;\n    let last_full_stable = versions\n        .iter()\n        .rfind(|v| v.raw_tag.ends_with(\".0\"))\n        .unwrap()\n        .version\n        .clone();\n\n    versions.push(VersionTag {\n        name: String::from(\"Beta\"),\n        version: {\n            let mut last = last_full_stable.clone();\n            last.minor += 1;\n            last\n        },\n        raw_tag: String::from(\"beta\"),\n        commit: repo\n            .revparse_single(\"beta\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n    versions.push(VersionTag {\n        name: String::from(\"Master\"),\n        version: {\n            // master is plus 1 minor versions off of beta, which we just pushed\n            let mut last = last_full_stable.clone();\n            last.minor += 2;\n            last\n        },\n        raw_tag: String::from(\"master\"),\n        commit: repo\n            .revparse_single(\"master\")\n            .unwrap()\n            .peel_to_commit()\n            .unwrap()\n            .id(),\n        in_progress: true,\n    });\n\n    let mut version_map = BTreeMap::new();\n\n    let mut cache = HashMap::new();\n\n    for (idx, version) in versions.iter().enumerate() {\n        let previous = if let Some(v) = idx.checked_sub(1).map(|idx| &versions[idx]) {\n            v\n        } else {\n            let author_map = build_author_map(&repo, &reviewers, &mailmap, \"\", &version.raw_tag)?;\n            version_map.insert(version.clone(), author_map);\n            continue;\n        };\n\n        eprintln!(\"Processing {:?} to {:?}\", previous, version);\n\n        cache.insert(\n            version,\n            up_to_release(&repo, &reviewers, &mailmap, &version)?,\n        );\n        let previous = match cache.remove(&previous) {\n            Some(v) => v,\n            None => up_to_release(&repo, &reviewers, &mailmap, &previous)?,\n        };\n        let current = cache.get(&version).unwrap();\n\n        // Remove commits reachable from the previous release.\n        let only_current = current.difference(&previous);\n        version_map.insert(version.clone(), only_current);\n    }\n\n    Ok(version_map)\n}", "id": 89, "concepts": ["parsing git commit logs", "author mapping", "unfolding nested data structures"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\nfn input(user_message: &str) -> io::Result<String> {\r\n    use std::io::Write;\r\n\r\n    print!(\"{}\", user_message);\r\n\r\n    io::stdout().flush()?;\r\n\r\n    let mut buffer: String = String::new();\r\n    io::stdin().read_line(&mut buffer)?;\r\n\r\n    Ok(buffer.trim_right().to_owned())\r\n}\n\n### Concepts", "fingerprint": null, "seed": "fn input(user_message: &str) -> io::Result<String> {\r\n    use std::io::Write;\r\n\r\n    print!(\"{}\", user_message);\r\n\r\n    io::stdout().flush()?;\r\n\r\n    let mut buffer: String = String::new();\r\n    io::stdin().read_line(&mut buffer)?;\r\n\r\n    Ok(buffer.trim_right().to_owned())\r\n}", "id": 90, "concepts": ["string concatenation", "string formatting", "reading user input", "printing to standard out", "flushing standard out", "string trimming"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 5\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\npub fn docker_metric_from_stats(first: &InstantDockerContainerMetric, second: &InstantDockerContainerMetric) -> DockerContainerMetric {\n    let first = first.clone();\n    let second = second.clone();\n    let time_diff = second.timestamp - first.timestamp;\n\n    let first_iter = first.stat.into_iter();\n\n    let stat: Vec<DockerContainerMetricEntry> = second.stat.into_iter()\n        .filter_map(|v| first_iter.clone()\n            .find(|item| item.name == v.name)\n            .map(|item| (item, v))\n        )\n        .filter(|two_entries| two_entries.1.cpu_usage > two_entries.0.cpu_usage)\n        .map(|two_entries| docker_metric_entry_from_two_stats(time_diff, two_entries.0, two_entries.1))\n        .collect();\n\n    DockerContainerMetric { stat, timestamp: second.timestamp }\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn docker_metric_from_stats(first: &InstantDockerContainerMetric, second: &InstantDockerContainerMetric) -> DockerContainerMetric {\n    let first = first.clone();\n    let second = second.clone();\n    let time_diff = second.timestamp - first.timestamp;\n\n    let first_iter = first.stat.into_iter();\n\n    let stat: Vec<DockerContainerMetricEntry> = second.stat.into_iter()\n        .filter_map(|v| first_iter.clone()\n            .find(|item| item.name == v.name)\n            .map(|item| (item, v))\n        )\n        .filter(|two_entries| two_entries.1.cpu_usage > two_entries.0.cpu_usage)\n        .map(|two_entries| docker_metric_entry_from_two_stats(time_diff, two_entries.0, two_entries.1))\n        .collect();\n\n    DockerContainerMetric { stat, timestamp: second.timestamp }\n}", "id": 91, "concepts": ["iteration with iterators", "filtering with closures"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn most_least_common(btm: BTreeMap<char, i32>) -> (char, char) {\n    let mut count_vec: Vec<_> = btm.into_iter().collect();\n    // Reverse sort the vector of pairs by \"value\" (sorted by \"key\" in case of tie)\n    count_vec.sort_by(|a, b| b.1.cmp(&a.1));\n    let m = count_vec.first().map(|&(k, _)| k).unwrap();\n    let l = count_vec.last().map(|&(k, _)| k).unwrap();\n    (m, l)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn most_least_common(btm: BTreeMap<char, i32>) -> (char, char) {\n    let mut count_vec: Vec<_> = btm.into_iter().collect();\n    // Reverse sort the vector of pairs by \"value\" (sorted by \"key\" in case of tie)\n    count_vec.sort_by(|a, b| b.1.cmp(&a.1));\n    let m = count_vec.first().map(|&(k, _)| k).unwrap();\n    let l = count_vec.last().map(|&(k, _)| k).unwrap();\n    (m, l)\n}", "id": 92, "concepts": ["iteration with iterators", "tuple unpacking", "map operation on a dictionary", "sorting based on multiple fields"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\npub fn test_rvc_pageend() {\n    // The last instruction of a executable memory page is an RVC instruction.\n    let buffer = fs::read(\"tests/programs/rvc_pageend\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    machine\n        .load_program(&buffer, &vec![\"rvc_end\".into()])\n        .unwrap();\n\n    let anchor_pc: u64 = 69630;\n    // Ensure that anchor_pc is in the end of the page\n    assert_eq!(anchor_pc as usize % RISCV_PAGESIZE, RISCV_PAGESIZE - 2);\n    let memory = machine.memory_mut();\n    // Ensure that the data segment is located at anchor_pc + 2\n    let data0 = memory.load16(&(anchor_pc + 2)).unwrap().to_u32();\n    assert_eq!(data0, 4);\n    let data1 = memory.load16(&(anchor_pc + 6)).unwrap().to_u32();\n    assert_eq!(data1, 2);\n    // Ensure that the anchor instruction is \"c.jr a0\"\n    let anchor_inst = memory.load16(&anchor_pc).unwrap().to_u16();\n    assert_eq!(anchor_inst, 0x8502);\n\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_rvc_pageend() {\n    // The last instruction of a executable memory page is an RVC instruction.\n    let buffer = fs::read(\"tests/programs/rvc_pageend\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    machine\n        .load_program(&buffer, &vec![\"rvc_end\".into()])\n        .unwrap();\n\n    let anchor_pc: u64 = 69630;\n    // Ensure that anchor_pc is in the end of the page\n    assert_eq!(anchor_pc as usize % RISCV_PAGESIZE, RISCV_PAGESIZE - 2);\n    let memory = machine.memory_mut();\n    // Ensure that the data segment is located at anchor_pc + 2\n    let data0 = memory.load16(&(anchor_pc + 2)).unwrap().to_u32();\n    assert_eq!(data0, 4);\n    let data1 = memory.load16(&(anchor_pc + 6)).unwrap().to_u32();\n    assert_eq!(data1, 2);\n    // Ensure that the anchor instruction is \"c.jr a0\"\n    let anchor_inst = memory.load16(&anchor_pc).unwrap().to_u16();\n    assert_eq!(anchor_inst, 0x8502);\n\n    let result = machine.run();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}", "id": 93, "concepts": ["memory access from RISCV binary", "memory layout", "memory layout manipulation", "memory loading with Rust's unsafe API"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\nfn cargo_fuzz() -> Command {\n    Command::cargo_bin(\"cargo-fuzz\").unwrap()\n}\n\n### Concepts", "fingerprint": null, "seed": "fn cargo_fuzz() -> Command {\n    Command::cargo_bin(\"cargo-fuzz\").unwrap()\n}", "id": 94, "concepts": ["cargo subcommand invocation", "Command struct initialization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\npub fn task_set_buffer(target: CAddr, buffer: CAddr) {\n    system_call(SystemCall::TaskSetBuffer {\n        request: (target, buffer),\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn task_set_buffer(target: CAddr, buffer: CAddr) {\n    system_call(SystemCall::TaskSetBuffer {\n        request: (target, buffer),\n    });\n}", "id": 95, "concepts": ["calling system calls from Rust code", "system call argument type conversions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nfn process_instructions(instructions: &Vec<Instruction>) -> (HashMap<&str, i32>, i32) {\n    let mut registers: HashMap<&str, i32> = HashMap::new();\n    let mut max = 0;\n\n    for instruction in instructions {\n        let current = *registers.entry(&instruction.condition.register).or_insert(0);\n\n        let condition_satisfied = match instruction.condition.operator {\n            Operator::LessThan           => current <  instruction.condition.value,\n            Operator::LessThanOrEqual    => current <= instruction.condition.value,\n            Operator::GreaterThan        => current >  instruction.condition.value,\n            Operator::GreaterThanOrEqual => current >= instruction.condition.value,\n            Operator::Equal              => current == instruction.condition.value,\n            Operator::NotEqual           => current != instruction.condition.value,\n        };\n\n        if !condition_satisfied {\n            continue;\n        }\n\n        let delta = match instruction.increase {\n            true  => instruction.value,\n            false => -1 * instruction.value,\n        };\n\n        let entry = registers.entry(&instruction.register).or_insert(0);\n        *entry += delta;\n        let new_value = *entry;\n\n        if new_value > max {\n            max = new_value;\n        }\n    }\n\n    (registers, max)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn process_instructions(instructions: &Vec<Instruction>) -> (HashMap<&str, i32>, i32) {\n    let mut registers: HashMap<&str, i32> = HashMap::new();\n    let mut max = 0;\n\n    for instruction in instructions {\n        let current = *registers.entry(&instruction.condition.register).or_insert(0);\n\n        let condition_satisfied = match instruction.condition.operator {\n            Operator::LessThan           => current <  instruction.condition.value,\n            Operator::LessThanOrEqual    => current <= instruction.condition.value,\n            Operator::GreaterThan        => current >  instruction.condition.value,\n            Operator::GreaterThanOrEqual => current >= instruction.condition.value,\n            Operator::Equal              => current == instruction.condition.value,\n            Operator::NotEqual           => current != instruction.condition.value,\n        };\n\n        if !condition_satisfied {\n            continue;\n        }\n\n        let delta = match instruction.increase {\n            true  => instruction.value,\n            false => -1 * instruction.value,\n        };\n\n        let entry = registers.entry(&instruction.register).or_insert(0);\n        *entry += delta;\n        let new_value = *entry;\n\n        if new_value > max {\n            max = new_value;\n        }\n    }\n\n    (registers, max)\n}", "id": 96, "concepts": ["iteration with conditional execution", "hash map operations"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nfn broker(table: &mut Table, ntransfers: u32) {\n\n  let mut rng = thread_rng();\n  let mut ract = Range::new(0, 100);\n  let mut ramt = Range::new(0, 1000);\n  let mut nstale = 0;\n\n  for _ in 0..ntransfers {\n    let a1 = ract.sample(&mut rng);\n    let mut a2 = ract.sample(&mut rng);\n    while a2 == a1 {\n      a2 = ract.sample(&mut rng);\n    }\n    let n = ramt.sample(&mut rng);\n\n    let rt = table.time();\n    let mut vs = [Value::default(); 2];\n    table.read(rt, &[a1, a2], &mut vs);\n    let r1 = Row { k: a1, v: vs[0].v - n };\n    let r2 = Row { k: a2, v: vs[1].v + n };\n    match table.write(rt, &[r1, r2]) {\n      WriteResult::Stale { .. } => nstale += 1,\n      _ => ()\n    }\n  }\n  assert!(nstale < ntransfers / 2);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn broker(table: &mut Table, ntransfers: u32) {\n\n  let mut rng = thread_rng();\n  let mut ract = Range::new(0, 100);\n  let mut ramt = Range::new(0, 1000);\n  let mut nstale = 0;\n\n  for _ in 0..ntransfers {\n    let a1 = ract.sample(&mut rng);\n    let mut a2 = ract.sample(&mut rng);\n    while a2 == a1 {\n      a2 = ract.sample(&mut rng);\n    }\n    let n = ramt.sample(&mut rng);\n\n    let rt = table.time();\n    let mut vs = [Value::default(); 2];\n    table.read(rt, &[a1, a2], &mut vs);\n    let r1 = Row { k: a1, v: vs[0].v - n };\n    let r2 = Row { k: a2, v: vs[1].v + n };\n    match table.write(rt, &[r1, r2]) {\n      WriteResult::Stale { .. } => nstale += 1,\n      _ => ()\n    }\n  }\n  assert!(nstale < ntransfers / 2);\n}", "id": 97, "concepts": ["iteration with a while loop", "nested loops"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\nfn map_prefix(tok: IRCToken) -> Result<IRCToken, ~str> {\n    match tok {\n        Sequence([Unparsed(nick), Sequence([rest])]) => match rest {\n            Sequence([Sequence([rest]), Unparsed(~\"@\"), Unparsed(host)]) => match rest {\n                Sequence([Unparsed(~\"!\"), Unparsed(user)]) => Ok(PrefixT(Prefix {nick: nick, user: user, host: host})),\n                _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: host})),\n            },\n            _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: ~\"\"})),\n        },\n        _ => Err(~\"Malformed prefix\")\n    }\n\n### Concepts", "fingerprint": null, "seed": "fn map_prefix(tok: IRCToken) -> Result<IRCToken, ~str> {\n    match tok {\n        Sequence([Unparsed(nick), Sequence([rest])]) => match rest {\n            Sequence([Sequence([rest]), Unparsed(~\"@\"), Unparsed(host)]) => match rest {\n                Sequence([Unparsed(~\"!\"), Unparsed(user)]) => Ok(PrefixT(Prefix {nick: nick, user: user, host: host})),\n                _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: host})),\n            },\n            _ => Ok(PrefixT(Prefix {nick: nick, user: ~\"\", host: ~\"\"})),\n        },\n        _ => Err(~\"Malformed prefix\")\n    }", "id": 98, "concepts": ["pattern matching", "transforming data structure", "condition checking", "matcher building", "handling invalid input"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nfn system_call_put_payload<T: Any>(message: SystemCall, payload: T) -> SystemCall {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        buffer.payload_length = size_of::<T>();\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &mut *payload_addr;\n        *payload_data = payload;\n\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn system_call_put_payload<T: Any>(message: SystemCall, payload: T) -> SystemCall {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        buffer.payload_length = size_of::<T>();\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &mut *payload_addr;\n        *payload_data = payload;\n\n        system_call_raw();\n        buffer.call.take().unwrap()\n    }\n}", "id": 99, "concepts": ["System call abstraction", "calling convention", "unsafe code", "type casting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\npub fn test_op_rvc_srli_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_srli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srli_crash_32\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_op_rvc_srli_crash_32() {\n    let buffer = fs::read(\"tests/programs/op_rvc_srli_crash_32\")\n        .unwrap()\n        .into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"op_rvc_srli_crash_32\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 101, "concepts": ["runtime error testing", "comparison with an expected error result", "memory page access error"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nfn print_fixed_acc(inss: &[Instruction], op: Operation, pc: usize) -> bool {\n    let mut fixed_inss = inss.to_vec();\n    fixed_inss[pc].op = op;\n\n    match Evaluator::new(&mut fixed_inss).eval_until_loop() {\n        (final_pc, final_acc, _) if final_pc == fixed_inss.len() => {\n            println!(\"{}\", final_acc);\n            true\n        }\n        _ => false,\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn print_fixed_acc(inss: &[Instruction], op: Operation, pc: usize) -> bool {\n    let mut fixed_inss = inss.to_vec();\n    fixed_inss[pc].op = op;\n\n    match Evaluator::new(&mut fixed_inss).eval_until_loop() {\n        (final_pc, final_acc, _) if final_pc == fixed_inss.len() => {\n            println!(\"{}\", final_acc);\n            true\n        }\n        _ => false,\n    }\n}", "id": 102, "concepts": ["control flow and looping", "evaluation of instructions", "conditional branching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\nfn soda(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<Soda>()?;\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "fn soda(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<Soda>()?;\n    Ok(())\n}", "id": 103, "concepts": ["module creation and initialization", "class definition", "Python calling convention"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\npub fn retype_task(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeTask {\n        request: (source, target),\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn retype_task(source: CAddr, target: CAddr) {\n    system_call(SystemCall::RetypeTask {\n        request: (source, target),\n    });\n}", "id": 104, "concepts": ["system call dispatch", "comparison-assignment", "option assignment"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn list_migration_directories_with_an_empty_migrations_folder_works(api: TestApi) {\n    let migrations_directory = api.create_migrations_directory();\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[]);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn list_migration_directories_with_an_empty_migrations_folder_works(api: TestApi) {\n    let migrations_directory = api.create_migrations_directory();\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[]);\n}", "id": 105, "concepts": ["migrating the code to a different directory", "calling multiple functions on the same line"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn get_common_chars(box_one: &String, box_two: &String) -> String {\n    box_one.chars()\n        .zip(box_two.chars())\n        .filter(|ch| ch.0 == ch.1)\n        .map(|ch| ch.0)\n        .collect()\n}\n\n### Concepts", "fingerprint": null, "seed": "fn get_common_chars(box_one: &String, box_two: &String) -> String {\n    box_one.chars()\n        .zip(box_two.chars())\n        .filter(|ch| ch.0 == ch.1)\n        .map(|ch| ch.0)\n        .collect()\n}", "id": 106, "concepts": ["Filtering for matching pairs", "list comprehension", "string processing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\npub fn test_nop() {\n    let buffer = fs::read(\"tests/programs/nop\").unwrap().into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"nop\".into()]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_nop() {\n    let buffer = fs::read(\"tests/programs/nop\").unwrap().into();\n    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec![\"nop\".into()]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), 0);\n}", "id": 107, "concepts": ["file system access", "comparison with boolean values", "result checking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nfn build_author_map_(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    let mut walker = repo.revwalk()?;\n\n    if repo.revparse_single(to).is_err() {\n        // If a commit is not found, try fetching it.\n        git(&[\n            \"--git-dir\",\n            repo.path().to_str().unwrap(),\n            \"fetch\",\n            \"origin\",\n            to,\n        ])?;\n    }\n\n    if from == \"\" {\n        let to = repo.revparse_single(to)?.peel_to_commit()?.id();\n        walker.push(to)?;\n    } else {\n        walker.push_range(&format!(\"{}..{}\", from, to))?;\n    }\n\n    let mut author_map = AuthorMap::new();\n    for oid in walker {\n        let oid = oid?;\n        let commit = repo.find_commit(oid)?;\n\n        let mut commit_authors = Vec::new();\n        if !is_rollup_commit(&commit) {\n            // We ignore the author of rollup-merge commits, and account for\n            // that author once by counting the reviewer of all bors merges. For\n            // rollups, we consider that this is the most relevant person, which\n            // is usually the case.\n            //\n            // Otherwise, a single rollup with N PRs attributes N commits to the author of the\n            // rollup, which isn't fair.\n            commit_authors.push(Author::from_sig(commit.author()));\n        }\n        match parse_bors_reviewer(&reviewers, &repo, &commit) {\n            Ok(Some(reviewers)) => commit_authors.extend(reviewers),\n            Ok(None) => {}\n            Err(ErrorContext(msg, e)) => {\n                if e.is::<reviewers::UnknownReviewer>() {\n                    eprintln!(\"Unknown reviewer: {}\", ErrorContext(msg, e));\n                } else {\n                    return Err(ErrorContext(msg, e).into());\n                }\n            }\n        }\n        commit_authors.extend(commit_coauthors(&commit));\n        for author in commit_authors {\n            let author = mailmap.canonicalize(&author);\n            author_map.add(author, oid);\n        }\n    }\n    Ok(author_map)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn build_author_map_(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    let mut walker = repo.revwalk()?;\n\n    if repo.revparse_single(to).is_err() {\n        // If a commit is not found, try fetching it.\n        git(&[\n            \"--git-dir\",\n            repo.path().to_str().unwrap(),\n            \"fetch\",\n            \"origin\",\n            to,\n        ])?;\n    }\n\n    if from == \"\" {\n        let to = repo.revparse_single(to)?.peel_to_commit()?.id();\n        walker.push(to)?;\n    } else {\n        walker.push_range(&format!(\"{}..{}\", from, to))?;\n    }\n\n    let mut author_map = AuthorMap::new();\n    for oid in walker {\n        let oid = oid?;\n        let commit = repo.find_commit(oid)?;\n\n        let mut commit_authors = Vec::new();\n        if !is_rollup_commit(&commit) {\n            // We ignore the author of rollup-merge commits, and account for\n            // that author once by counting the reviewer of all bors merges. For\n            // rollups, we consider that this is the most relevant person, which\n            // is usually the case.\n            //\n            // Otherwise, a single rollup with N PRs attributes N commits to the author of the\n            // rollup, which isn't fair.\n            commit_authors.push(Author::from_sig(commit.author()));\n        }\n        match parse_bors_reviewer(&reviewers, &repo, &commit) {\n            Ok(Some(reviewers)) => commit_authors.extend(reviewers),\n            Ok(None) => {}\n            Err(ErrorContext(msg, e)) => {\n                if e.is::<reviewers::UnknownReviewer>() {\n                    eprintln!(\"Unknown reviewer: {}\", ErrorContext(msg, e));\n                } else {\n                    return Err(ErrorContext(msg, e).into());\n                }\n            }\n        }\n        commit_authors.extend(commit_coauthors(&commit));\n        for author in commit_authors {\n            let author = mailmap.canonicalize(&author);\n            author_map.add(author, oid);\n        }\n    }\n    Ok(author_map)\n}", "id": 109, "concepts": ["type comparison", "error handling", "parameterized error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn parseFromFile(file: &File) {\r\n    let mut reader = BufReader::new(file);\r\n    let mut buf = String::from(\"\");\r\n    let line_index = 0;\r\n    let mut models: Vec<Model> = Vec::new();\r\n    let mut lights: Vec<Model> = Vec::new();\r\n    while (reader.read_line(&mut buf) != 0) {\r\n        if lien_index == 0 {\r\n            if line == 'm' {\r\n                //now we read the model data\r\n                reader.read_line(&mut buf);\r\n                let model_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut model_index = 0;\r\n                while model_index < model_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n            if line == 'l' {\r\n                reader.read_line(&mut buf);\r\n                let light_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut light_index = 0;\r\n                while light_index < light_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n\n### Concepts", "fingerprint": null, "seed": "fn parseFromFile(file: &File) {\r\n    let mut reader = BufReader::new(file);\r\n    let mut buf = String::from(\"\");\r\n    let line_index = 0;\r\n    let mut models: Vec<Model> = Vec::new();\r\n    let mut lights: Vec<Model> = Vec::new();\r\n    while (reader.read_line(&mut buf) != 0) {\r\n        if lien_index == 0 {\r\n            if line == 'm' {\r\n                //now we read the model data\r\n                reader.read_line(&mut buf);\r\n                let model_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut model_index = 0;\r\n                while model_index < model_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n            if line == 'l' {\r\n                reader.read_line(&mut buf);\r\n                let light_count = buf.trim().parse().expect(\"it's not a number\");\r\n                let mut light_index = 0;\r\n                while light_index < light_count {\r\n                    parseModelInfo(&mut reader, &mut buf, &mut models)\r\n                    model_index += 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}", "id": 110, "concepts": ["file I/O", "while loop", "file reading and parsing", "regex"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\nfn read_or_create_default_database() -> Result<DataBase> {\n    let default_database_paths = get_default_database_paths();\n\n    if default_database_paths.is_empty() {\n        eprintln!(\"{}\", format!(\n            \"Could not find a location for the default database. \\\n            Opening a database which cannot be saved.\",\n        ).color(\"yellow\"));\n\n        return Ok(DataBase::new());\n    }\n\n    // See if a default database can be found at any path before creating a new one.\n    for path in &default_database_paths {\n        if path.is_file() {\n            return read_database(&path).map_err(|err| GrafenCliError::from(err))\n        }\n    }\n\n    let mut default_database = DataBase::new();\n    let default_path = &default_database_paths[0];\n\n    if let Some(parent_dir) = default_path.parent() {\n        match DirBuilder::new().recursive(true).create(&parent_dir) {\n            Ok(_) => default_database.set_path(&default_path).unwrap(),\n            Err(err) => {\n                eprintln!(\"{}\", format!(\n                    \"Warning: Could not create a folder for a default database at '{}' ({}). \\\n                    Opening a database which cannot be saved.\",\n                    default_path.display(), err\n                ).color(\"yellow\"));\n            },\n        }\n    }\n\n    Ok(default_database)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn read_or_create_default_database() -> Result<DataBase> {\n    let default_database_paths = get_default_database_paths();\n\n    if default_database_paths.is_empty() {\n        eprintln!(\"{}\", format!(\n            \"Could not find a location for the default database. \\\n            Opening a database which cannot be saved.\",\n        ).color(\"yellow\"));\n\n        return Ok(DataBase::new());\n    }\n\n    // See if a default database can be found at any path before creating a new one.\n    for path in &default_database_paths {\n        if path.is_file() {\n            return read_database(&path).map_err(|err| GrafenCliError::from(err))\n        }\n    }\n\n    let mut default_database = DataBase::new();\n    let default_path = &default_database_paths[0];\n\n    if let Some(parent_dir) = default_path.parent() {\n        match DirBuilder::new().recursive(true).create(&parent_dir) {\n            Ok(_) => default_database.set_path(&default_path).unwrap(),\n            Err(err) => {\n                eprintln!(\"{}\", format!(\n                    \"Warning: Could not create a folder for a default database at '{}' ({}). \\\n                    Opening a database which cannot be saved.\",\n                    default_path.display(), err\n                ).color(\"yellow\"));\n            },\n        }\n    }\n\n    Ok(default_database)\n}", "id": 111, "concepts": ["file system access", "error handling", "function definition", "syntax of boolean logic"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\npub fn data_type<'a>() -> Parser<'a, char, DataType> {\n    ident().convert(|v| DataType::match_data_type(&v))\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn data_type<'a>() -> Parser<'a, char, DataType> {\n    ident().convert(|v| DataType::match_data_type(&v))\n}", "id": 112, "concepts": ["type-checking for a sequence of tokens", "custom syntax of a parser", "recursive parsing of a sub-grammar"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nfn run() -> Result<(), Box<dyn std::error::Error>> {\n    let by_version = generate_thanks()?;\n\n    let mut all_time = by_version.values().next().unwrap().clone();\n    for map in by_version.values().skip(1) {\n        all_time.extend(map.clone());\n    }\n\n    site::render(by_version, all_time)?;\n\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "fn run() -> Result<(), Box<dyn std::error::Error>> {\n    let by_version = generate_thanks()?;\n\n    let mut all_time = by_version.values().next().unwrap().clone();\n    for map in by_version.values().skip(1) {\n        all_time.extend(map.clone());\n    }\n\n    site::render(by_version, all_time)?;\n\n    Ok(())\n}", "id": 113, "concepts": ["iterating over a map", "map construction", "map extension", "map sorting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 2\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nfn main() {\n\tlet argv = os::args();\n\tlet size = from_str::<uint>(argv[1]).unwrap();\n//\tprintln!(\"{}\",size);\n\n\tlet align = from_str::<uint>(argv[2]).unwrap();\n//\tprintln!(\"{}\", align);\n\n\tlet aligned = align_to(size,align);\n\tprintln!(\"{} by {} = {}\", size, align, aligned);\n\n//\tprint_uint(*argv[1]);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n\tlet argv = os::args();\n\tlet size = from_str::<uint>(argv[1]).unwrap();\n//\tprintln!(\"{}\",size);\n\n\tlet align = from_str::<uint>(argv[2]).unwrap();\n//\tprintln!(\"{}\", align);\n\n\tlet aligned = align_to(size,align);\n\tprintln!(\"{} by {} = {}\", size, align, aligned);\n\n//\tprint_uint(*argv[1]);\n}", "id": 115, "concepts": ["conversion between number types", "command line argument processing", "syntax of `match` expression"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\npub fn number(n: i64) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::Number(n),\n        computed: true,\n    }))\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn number(n: i64) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::Number(n),\n        computed: true,\n    }))\n}", "id": 116, "concepts": ["referential transparency", "immutability", "recursive data types", "data structures"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\npub unsafe fn gatt_svr_init() -> i32 {\n    // Leaks the eff out of the svc_def\n    let svcs_ptr = alloc_svc_def();\n    print_svcs(svcs_ptr);\n\n    ble_svc_gap_init();\n    ble_svc_gatt_init();\n\n    let mut rc;\n\n    rc = ble_gatts_count_cfg(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_count_cfg\\n\"));\n\n    rc = ble_gatts_add_svcs(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_add_svcs\\n\"));\n\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "pub unsafe fn gatt_svr_init() -> i32 {\n    // Leaks the eff out of the svc_def\n    let svcs_ptr = alloc_svc_def();\n    print_svcs(svcs_ptr);\n\n    ble_svc_gap_init();\n    ble_svc_gatt_init();\n\n    let mut rc;\n\n    rc = ble_gatts_count_cfg(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_count_cfg\\n\"));\n\n    rc = ble_gatts_add_svcs(svcs_ptr);\n    esp_assert!(rc == 0, cstr!(\"RC err after ble_gatts_add_svcs\\n\"));\n\n    return 0;\n}", "id": 118, "concepts": ["memory allocation", "error handling with exceptions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\npub fn main() {\n    let opts = TileOptions {\n        parent_x: 108,\n        parent_y: 54,\n        width: 10,\n        height: 10,\n        max_value: 10.0,\n        min_value: 0.0,\n        mean: 5.0,\n        std_dev: 2.0,\n    };\n    let t = NormalDistTile::new(opts);\n    println!(\" {:?}\", t.subtiles);\n    println!(\"{}\", t.get(0, 0));\n    println!(\"{}\", t.get(1, 0));\n    println!(\"{}\", t.get(2, 0));\n    println!(\"{}\", t.get(3, 0));\n\n    println!(\"{}\", t.get(0, 5));\n    println!(\"{}\", t.get(1, 5));\n    println!(\"{}\", t.get(2, 5));\n    println!(\"{}\", t.get(3, 5));\n\n    println!(\"{}\", t.get((t.width - 4) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 3) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 2) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 1) as u8, (t.height - 1) as u8));\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn main() {\n    let opts = TileOptions {\n        parent_x: 108,\n        parent_y: 54,\n        width: 10,\n        height: 10,\n        max_value: 10.0,\n        min_value: 0.0,\n        mean: 5.0,\n        std_dev: 2.0,\n    };\n    let t = NormalDistTile::new(opts);\n    println!(\" {:?}\", t.subtiles);\n    println!(\"{}\", t.get(0, 0));\n    println!(\"{}\", t.get(1, 0));\n    println!(\"{}\", t.get(2, 0));\n    println!(\"{}\", t.get(3, 0));\n\n    println!(\"{}\", t.get(0, 5));\n    println!(\"{}\", t.get(1, 5));\n    println!(\"{}\", t.get(2, 5));\n    println!(\"{}\", t.get(3, 5));\n\n    println!(\"{}\", t.get((t.width - 4) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 3) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 2) as u8, (t.height - 1) as u8));\n    println!(\"{}\", t.get((t.width - 1) as u8, (t.height - 1) as u8));\n}", "id": 119, "concepts": ["object-oriented programming", "polymorphism and inheritance", "dynamic dispatch"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nfn a_table_should_preserve_the_money_supply() {\n  let mut table = HashMapOfTreeMap::new();\n  broker(&mut table, 1000);\n  expect_money_conserved(&table);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn a_table_should_preserve_the_money_supply() {\n  let mut table = HashMapOfTreeMap::new();\n  broker(&mut table, 1000);\n  expect_money_conserved(&table);\n}", "id": 121, "concepts": ["hashmap and treemap implementation and use for testing", "mutation handling for testing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\nfn\nis_invalid_column_type\n(\nerr\n:\nError\n)\n-\n>\nbool\n{\nmatches\n!\n(\nerr\nError\n:\n:\nInvalidColumnType\n(\n.\n.\n)\n)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn\nis_invalid_column_type\n(\nerr\n:\nError\n)\n-\n>\nbool\n{\nmatches\n!\n(\nerr\nError\n:\n:\nInvalidColumnType\n(\n.\n.\n)\n)\n}", "id": 123, "concepts": ["match", "if-let", "pattern-matching", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\npub fn star2(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let mut max_guard_asleep_per_minute = vec![(0, None); 60];\n    for &guard_id in guard_map.keys() {\n        let mut guard_asleep_by_minute = vec![0; 60];\n        for day in &guard_map[&guard_id] {\n            for minute in 0..60 {\n                guard_asleep_by_minute[minute] += i32::from(!day.minutes[minute]);\n            }\n        }\n        for minute in 0..60 {\n            if max_guard_asleep_per_minute[minute].0 < guard_asleep_by_minute[minute] {\n                max_guard_asleep_per_minute[minute] = (guard_asleep_by_minute[minute], Some(guard_id));\n            }\n        }\n    }\n    if let Some((max_minute, (_, Some(max_guard_id)))) = max_guard_asleep_per_minute.iter().enumerate().max_by_key(|(_, (times, _))| times) {\n        return (max_minute as i32 * max_guard_id) .to_string();\n    }\n    panic!(\"No maximum found: Invalid input!\");\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn star2(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let mut max_guard_asleep_per_minute = vec![(0, None); 60];\n    for &guard_id in guard_map.keys() {\n        let mut guard_asleep_by_minute = vec![0; 60];\n        for day in &guard_map[&guard_id] {\n            for minute in 0..60 {\n                guard_asleep_by_minute[minute] += i32::from(!day.minutes[minute]);\n            }\n        }\n        for minute in 0..60 {\n            if max_guard_asleep_per_minute[minute].0 < guard_asleep_by_minute[minute] {\n                max_guard_asleep_per_minute[minute] = (guard_asleep_by_minute[minute], Some(guard_id));\n            }\n        }\n    }\n    if let Some((max_minute, (_, Some(max_guard_id)))) = max_guard_asleep_per_minute.iter().enumerate().max_by_key(|(_, (times, _))| times) {\n        return (max_minute as i32 * max_guard_id) .to_string();\n    }\n    panic!(\"No maximum found: Invalid input!\");\n}", "id": 124, "concepts": ["hashmap lookup", "conditional lookup for branching", "nested loop with for-let pattern matching", "multiple return values in functions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nasync fn get_price_ticker() {\n    let exchange = init().await;\n    let req = GetPriceTickerRequest {\n        market_pair: \"eth_btc\".to_string(),\n    };\n    let resp = exchange.get_price_ticker(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn get_price_ticker() {\n    let exchange = init().await;\n    let req = GetPriceTickerRequest {\n        market_pair: \"eth_btc\".to_string(),\n    };\n    let resp = exchange.get_price_ticker(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 125, "concepts": ["async/await", "futures", "tokio runtime", "futures::executor"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\npub fn test_flat_crash_64() {\n    let buffer = fs::read(\"tests/programs/flat_crash_64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, FlatMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    let result = machine.load_program(&buffer, &vec![\"flat_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_flat_crash_64() {\n    let buffer = fs::read(\"tests/programs/flat_crash_64\").unwrap().into();\n    let core_machine =\n        DefaultCoreMachine::<u64, FlatMemory<u64>>::new(ISA_IMC, VERSION0, u64::max_value());\n    let mut machine = DefaultMachineBuilder::new(core_machine).build();\n    let result = machine.load_program(&buffer, &vec![\"flat_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemOutOfBound));\n}", "id": 126, "concepts": ["error handling in Rust", "type conversion", "function execution with mutation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 6\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nfn get_submodules(\n    repo: &Repository,\n    at: &Commit,\n) -> Result<Vec<Submodule>, Box<dyn std::error::Error>> {\n    let submodule_cfg = modules_file(&repo, &at)?;\n    let submodule_cfg = Config::parse(&submodule_cfg)?;\n    let mut path_to_url = HashMap::new();\n    let entries = submodule_cfg.entries(None)?;\n    for entry in &entries {\n        let entry = entry?;\n        let name = entry.name().unwrap();\n        if name.ends_with(\".path\") {\n            let url = name.replace(\".path\", \".url\");\n            let url = submodule_cfg.get_string(&url).unwrap();\n            path_to_url.insert(entry.value().unwrap().to_owned(), url);\n        }\n    }\n    let mut submodules = Vec::new();\n    let tree = at.tree()?;\n    for (path, url) in &path_to_url {\n        let path = Path::new(&path);\n        let entry = tree.get_path(&path);\n        // the submodule may not actually exist\n        let entry = match entry {\n            Ok(e) => e,\n            Err(_) => continue,\n        };\n        assert_eq!(entry.kind().unwrap(), git2::ObjectType::Commit);\n        submodules.push(Submodule {\n            path: path.to_owned(),\n            commit: entry.id(),\n            repository: url.to_owned(),\n        });\n    }\n    submodules.retain(|s| {\n        let is_rust =\n            s.repository.contains(\"rust-lang\") || s.repository.contains(\"rust-lang-nursery\");\n        let exclude = vec![\n            \"https://github.com/rust-lang/llvm.git\",\n            \"https://github.com/rust-lang/llvm-project.git\",\n            \"https://github.com/rust-lang/lld.git\",\n            \"https://github.com/rust-lang-nursery/clang.git\",\n            \"https://github.com/rust-lang-nursery/lldb.git\",\n            \"https://github.com/rust-lang/libuv.git\",\n            \"https://github.com/rust-lang/gyp.git\",\n            \"https://github.com/rust-lang/jemalloc.git\",\n            \"https://github.com/rust-lang/compiler-rt.git\",\n            \"https://github.com/rust-lang/hoedown.git\",\n        ];\n        is_rust\n            && !exclude.contains(&s.repository.as_str())\n            && !exclude.contains(&&*format!(\"{}.git\", s.repository))\n    });\n    Ok(submodules)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn get_submodules(\n    repo: &Repository,\n    at: &Commit,\n) -> Result<Vec<Submodule>, Box<dyn std::error::Error>> {\n    let submodule_cfg = modules_file(&repo, &at)?;\n    let submodule_cfg = Config::parse(&submodule_cfg)?;\n    let mut path_to_url = HashMap::new();\n    let entries = submodule_cfg.entries(None)?;\n    for entry in &entries {\n        let entry = entry?;\n        let name = entry.name().unwrap();\n        if name.ends_with(\".path\") {\n            let url = name.replace(\".path\", \".url\");\n            let url = submodule_cfg.get_string(&url).unwrap();\n            path_to_url.insert(entry.value().unwrap().to_owned(), url);\n        }\n    }\n    let mut submodules = Vec::new();\n    let tree = at.tree()?;\n    for (path, url) in &path_to_url {\n        let path = Path::new(&path);\n        let entry = tree.get_path(&path);\n        // the submodule may not actually exist\n        let entry = match entry {\n            Ok(e) => e,\n            Err(_) => continue,\n        };\n        assert_eq!(entry.kind().unwrap(), git2::ObjectType::Commit);\n        submodules.push(Submodule {\n            path: path.to_owned(),\n            commit: entry.id(),\n            repository: url.to_owned(),\n        });\n    }\n    submodules.retain(|s| {\n        let is_rust =\n            s.repository.contains(\"rust-lang\") || s.repository.contains(\"rust-lang-nursery\");\n        let exclude = vec![\n            \"https://github.com/rust-lang/llvm.git\",\n            \"https://github.com/rust-lang/llvm-project.git\",\n            \"https://github.com/rust-lang/lld.git\",\n            \"https://github.com/rust-lang-nursery/clang.git\",\n            \"https://github.com/rust-lang-nursery/lldb.git\",\n            \"https://github.com/rust-lang/libuv.git\",\n            \"https://github.com/rust-lang/gyp.git\",\n            \"https://github.com/rust-lang/jemalloc.git\",\n            \"https://github.com/rust-lang/compiler-rt.git\",\n            \"https://github.com/rust-lang/hoedown.git\",\n        ];\n        is_rust\n            && !exclude.contains(&s.repository.as_str())\n            && !exclude.contains(&&*format!(\"{}.git\", s.repository))\n    });\n    Ok(submodules)\n}", "id": 127, "concepts": ["git submodule access", "string manipulation and branch detection", "compilation of a rust library"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nfn float_test() {\n    assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.);\n    assert_eq!((-1.01f64).floor(), -2.0);\n    assert!((-1. / std::f32::INFINITY).is_sign_negative());\n}\n\n### Concepts", "fingerprint": null, "seed": "fn float_test() {\n    assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.);\n    assert_eq!((-1.01f64).floor(), -2.0);\n    assert!((-1. / std::f32::INFINITY).is_sign_negative());\n}", "id": 128, "concepts": ["floating point operations", "round function and branching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nasync fn order_book() {\n    let exchange = init().await;\n    let req = OrderBookRequest {\n        market_pair: \"eth_btc\".to_string(),\n    };\n    let resp = exchange.order_book(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn order_book() {\n    let exchange = init().await;\n    let req = OrderBookRequest {\n        market_pair: \"eth_btc\".to_string(),\n    };\n    let resp = exchange.order_book(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 129, "concepts": ["asynchronous programming with async / await", "simple request-response pattern implementation with built-in futures"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn parseModelInfo(reader: &mut BufReader<&File>, buf: &mut String, models: &mut Vec<Model>, basePath: &str) -> Model {\r\n    //Firstly, read the meshId and materialId;\r\n    reader.read_line(buf);\r\n    let mut split_info = buf.split(\" \");\r\n    if len(split_info) != 2 {}\r\n    let meshId: i32 = split_info.next().unwrap().parse().unwrap();\r\n    let materidId = split_info.next().unwrap().parse().unwrap();\r\n    let meshFilePath = basePath + \"/meshes/\" + meshId + \"_mesh.obj\";\r\n    let materialPath = basePath + \"/materials/\" + materidId + \"/\" + materidId;\r\n    //Then, read the position info;\r\n    split_info = buf.split(\" \");\r\n    let mut modelInfo: Vec<Vec3f> = Vec::new();\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 3 {\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        modelInfo.push(Vec3f {\r\n            x: split_info.next().unwrap().parse().unwrap(),\r\n            y: split_info.next().unwrap().parse().unwrap(),\r\n            z: split_info.next().unwrap().parse().unwrap(),\r\n        });\r\n        infoIndex += 1;\r\n    }\r\n    loadImageFromMaterial(model, materidId);\r\n\r\n    models.push(Model {\r\n        meshId,\r\n        materidId: 0,\r\n        position: Vec3f {\r\n            x: modelInfo.get(0).unwrap().x,\r\n            y: modelInfo.get(0).unwrap().y,\r\n            z: modelInfo.get(0).unwrap().z,\r\n        },\r\n        rotation: Vec3f {\r\n            x: modelInfo.get(1).unwrap().x,\r\n            y: modelInfo.get(1).unwrap().y,\r\n            z: modelInfo.get(1).unwrap().z,\r\n        },\r\n        scaling: Vec3f {\r\n            x: modelInfo.get(2).unwrap().x,\r\n            y: modelInfo.get(2).unwrap().y,\r\n            z: modelInfo.get(2).unwrap().z,\r\n        },\r\n    }\r\n    );\r\n\r\n    //Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n}\n\n### Concepts", "fingerprint": null, "seed": "fn parseModelInfo(reader: &mut BufReader<&File>, buf: &mut String, models: &mut Vec<Model>, basePath: &str) -> Model {\r\n    //Firstly, read the meshId and materialId;\r\n    reader.read_line(buf);\r\n    let mut split_info = buf.split(\" \");\r\n    if len(split_info) != 2 {}\r\n    let meshId: i32 = split_info.next().unwrap().parse().unwrap();\r\n    let materidId = split_info.next().unwrap().parse().unwrap();\r\n    let meshFilePath = basePath + \"/meshes/\" + meshId + \"_mesh.obj\";\r\n    let materialPath = basePath + \"/materials/\" + materidId + \"/\" + materidId;\r\n    //Then, read the position info;\r\n    split_info = buf.split(\" \");\r\n    let mut modelInfo: Vec<Vec3f> = Vec::new();\r\n    let mut infoIndex = 0;\r\n    while infoIndex < 3 {\r\n        reader.read_line(buf);\r\n        let mut split_info = buf.split(\" \");\r\n        modelInfo.push(Vec3f {\r\n            x: split_info.next().unwrap().parse().unwrap(),\r\n            y: split_info.next().unwrap().parse().unwrap(),\r\n            z: split_info.next().unwrap().parse().unwrap(),\r\n        });\r\n        infoIndex += 1;\r\n    }\r\n    loadImageFromMaterial(model, materidId);\r\n\r\n    models.push(Model {\r\n        meshId,\r\n        materidId: 0,\r\n        position: Vec3f {\r\n            x: modelInfo.get(0).unwrap().x,\r\n            y: modelInfo.get(0).unwrap().y,\r\n            z: modelInfo.get(0).unwrap().z,\r\n        },\r\n        rotation: Vec3f {\r\n            x: modelInfo.get(1).unwrap().x,\r\n            y: modelInfo.get(1).unwrap().y,\r\n            z: modelInfo.get(1).unwrap().z,\r\n        },\r\n        scaling: Vec3f {\r\n            x: modelInfo.get(2).unwrap().x,\r\n            y: modelInfo.get(2).unwrap().y,\r\n            z: modelInfo.get(2).unwrap().z,\r\n        },\r\n    }\r\n    );\r\n\r\n    //Finally, we only need to read an empty line to finish the model parsing process\r\n    reader.read_line(buf);\r\n}", "id": 130, "concepts": ["parsing file lines", "string splitting", "reading and parsing file content", "array indexing", "tuple deconstruction", "dynamic vector initialization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 6\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn main() {\n    let file_name = \"input.txt\";\n    let instructions = parse_file(file_name);\n    let (registers, largest_value) = process_instructions(&instructions);\n    println!(\"Day 8, part 1: {}\", get_largest_register_value(&registers));\n    println!(\"Day 8, part 2: {}\", largest_value);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    let file_name = \"input.txt\";\n    let instructions = parse_file(file_name);\n    let (registers, largest_value) = process_instructions(&instructions);\n    println!(\"Day 8, part 1: {}\", get_largest_register_value(&registers));\n    println!(\"Day 8, part 2: {}\", largest_value);\n}", "id": 131, "concepts": ["parsing file contents", "file input", "dictionary lookup", "error handling with exceptions", "local function definition", "nested function calls", "return value evaluation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nfn hard_fault(ef: &ExceptionFrame) -> ! {\n    panic!(\"Hardfault... : {:#?}\", ef);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn hard_fault(ef: &ExceptionFrame) -> ! {\n    panic!(\"Hardfault... : {:#?}\", ef);\n}", "id": 132, "concepts": ["panic! and exception frames"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 9\n### Snippet\npub fn get_driver(url: &str) -> MigrateResult<Box<Driver>> {\n    // Mysql driver does not allow to connect using a url so we need to parse it\n    let mut parser = UrlParser::new();\n    parser.scheme_type_mapper(db_scheme_type_mapper);\n    let parsed = parser.parse(url).unwrap();\n\n    match parsed.scheme.as_ref() {\n        \"postgres\" => postgres::Postgres::new(url).map(|d| Box::new(d) as Box<Driver>),\n        \"mysql\" => mysql::Mysql::new(parsed).map(|d| Box::new(d) as Box<Driver>),\n        _ => Err(invalid_url(url))\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn get_driver(url: &str) -> MigrateResult<Box<Driver>> {\n    // Mysql driver does not allow to connect using a url so we need to parse it\n    let mut parser = UrlParser::new();\n    parser.scheme_type_mapper(db_scheme_type_mapper);\n    let parsed = parser.parse(url).unwrap();\n\n    match parsed.scheme.as_ref() {\n        \"postgres\" => postgres::Postgres::new(url).map(|d| Box::new(d) as Box<Driver>),\n        \"mysql\" => mysql::Mysql::new(parsed).map(|d| Box::new(d) as Box<Driver>),\n        _ => Err(invalid_url(url))\n    }\n}", "id": 133, "concepts": ["parsing URL", "URL parser", "error handling", "function composition", "value extraction with pattern matching", "string comparison"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 4\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn build_all() {\n    let project = project(\"build_all\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_b\")\n        .assert()\n        .success();\n\n    // Build to ensure that the build directory is created and\n    // `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n\n    let a_bin = build_dir.join(\"build_all_a\");\n    let b_bin = build_dir.join(\"build_all_b\");\n\n    // Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    // Test that building all fuzz targets does in fact recreate the files.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    assert!(a_bin.is_file());\n    assert!(b_bin.is_file());\n}\n\n### Concepts", "fingerprint": null, "seed": "fn build_all() {\n    let project = project(\"build_all\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_all_b\")\n        .assert()\n        .success();\n\n    // Build to ensure that the build directory is created and\n    // `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n\n    let a_bin = build_dir.join(\"build_all_a\");\n    let b_bin = build_dir.join(\"build_all_b\");\n\n    // Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    // Test that building all fuzz targets does in fact recreate the files.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    assert!(a_bin.is_file());\n    assert!(b_bin.is_file());\n}", "id": 134, "concepts": ["fuzz target building", "file removal", "file existence check", "file creation and removal"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nfn main() {\n    env_logger::init().unwrap_or_else(\n        |err|\n            panic!(\"unable to initiate env logger: {}\", err)\n    );\n\n    match core::start() {\n        Ok(()) => info!(\"game exiting\"),\n        Err(err) => error!(\"core start error: {}\", err),\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    env_logger::init().unwrap_or_else(\n        |err|\n            panic!(\"unable to initiate env logger: {}\", err)\n    );\n\n    match core::start() {\n        Ok(()) => info!(\"game exiting\"),\n        Err(err) => error!(\"core start error: {}\", err),\n    }\n}", "id": 135, "concepts": ["error handling with match", "initialization of the logger", "error handling with unwrap or expect", "error handling with panics", "error handling with macros"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\npub fn write_board(board_name: String, contents: String) -> Result<(), String> {\n    let mut configurator = Configurator::new();\n    unsafe {\n        configurator.set_working_folder(WORKING_FOLDER.clone());\n    }\n    configurator.write_board(board_name, contents)\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn write_board(board_name: String, contents: String) -> Result<(), String> {\n    let mut configurator = Configurator::new();\n    unsafe {\n        configurator.set_working_folder(WORKING_FOLDER.clone());\n    }\n    configurator.write_board(board_name, contents)\n}", "id": 136, "concepts": ["input validation", "error handling", "error message customization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 9\n### Snippet\nfn help() {\n    cargo_fuzz().arg(\"help\").assert().success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn help() {\n    cargo_fuzz().arg(\"help\").assert().success();\n}", "id": 137, "concepts": ["command line argument passing", "cargo fuzzing", "error handling with exceptions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 5\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nfn assert_memory_load_bytes_all<R: Rng>(\n    rng: &mut R,\n    max_memory: usize,\n    buf_size: usize,\n    addr: u64,\n) {\n    assert_memory_load_bytes(\n        rng,\n        &mut SparseMemory::<u64>::new_with_memory(max_memory),\n        buf_size,\n        addr,\n    );\n    assert_memory_load_bytes(\n        rng,\n        &mut FlatMemory::<u64>::new_with_memory(max_memory),\n        buf_size,\n        addr,\n    );\n    assert_memory_load_bytes(\n        rng,\n        &mut WXorXMemory::new(FlatMemory::<u64>::new_with_memory(max_memory)),\n        buf_size,\n        addr,\n    );\n\n    #[cfg(has_asm)]\n    assert_memory_load_bytes(\n        rng,\n        &mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000),\n        buf_size,\n        addr,\n    );\n}\n\n### Concepts", "fingerprint": null, "seed": "fn assert_memory_load_bytes_all<R: Rng>(\n    rng: &mut R,\n    max_memory: usize,\n    buf_size: usize,\n    addr: u64,\n) {\n    assert_memory_load_bytes(\n        rng,\n        &mut SparseMemory::<u64>::new_with_memory(max_memory),\n        buf_size,\n        addr,\n    );\n    assert_memory_load_bytes(\n        rng,\n        &mut FlatMemory::<u64>::new_with_memory(max_memory),\n        buf_size,\n        addr,\n    );\n    assert_memory_load_bytes(\n        rng,\n        &mut WXorXMemory::new(FlatMemory::<u64>::new_with_memory(max_memory)),\n        buf_size,\n        addr,\n    );\n\n    #[cfg(has_asm)]\n    assert_memory_load_bytes(\n        rng,\n        &mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000),\n        buf_size,\n        addr,\n    );\n}", "id": 139, "concepts": ["memory access", "testing all implementations of the same trait", "trait object instantiation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 6\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nfn should_update() -> bool {\n    std::env::args_os().nth(1).unwrap_or_default() == \"--refresh\"\n}\n\n### Concepts", "fingerprint": null, "seed": "fn should_update() -> bool {\n    std::env::args_os().nth(1).unwrap_or_default() == \"--refresh\"\n}", "id": 140, "concepts": ["conditional evaluation of command-line arguments", "environment variable manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nfn build_unparsed(s: ~str) -> Result<IRCToken, ~str> {\n    Ok(Unparsed(s))\n}\n\n### Concepts", "fingerprint": null, "seed": "fn build_unparsed(s: ~str) -> Result<IRCToken, ~str> {\n    Ok(Unparsed(s))\n}", "id": 141, "concepts": ["result type", "string manipulation", "type conversion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nfn get_largest_register_value(registers: &HashMap<&str, i32>) -> i32 {\n    *registers\n        .iter()\n        .map(|(_, v)| v)\n        .max()\n        .unwrap_or(&0)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn get_largest_register_value(registers: &HashMap<&str, i32>) -> i32 {\n    *registers\n        .iter()\n        .map(|(_, v)| v)\n        .max()\n        .unwrap_or(&0)\n}", "id": 142, "concepts": ["maximum value of a map", "default value handling", "hash map iteration"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nasync fn main() -> std::io::Result<()> {\n    // Set keep-alive to 75 seconds\n    let _one = HttpServer::new(app).keep_alive(Duration::from_secs(75));\n\n    // Use OS's keep-alive (usually quite long)\n    let _two = HttpServer::new(app).keep_alive(KeepAlive::Os);\n\n    // Disable keep-alive\n    let _three = HttpServer::new(app).keep_alive(None);\n\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn main() -> std::io::Result<()> {\n    // Set keep-alive to 75 seconds\n    let _one = HttpServer::new(app).keep_alive(Duration::from_secs(75));\n\n    // Use OS's keep-alive (usually quite long)\n    let _two = HttpServer::new(app).keep_alive(KeepAlive::Os);\n\n    // Disable keep-alive\n    let _three = HttpServer::new(app).keep_alive(None);\n\n    Ok(())\n}", "id": 143, "concepts": ["lifetimes", "asynchronous programming", "lifetime scopes", "asynchronous task execution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn main() {\n    let re_top = Regex::new(r\" {4}|\\[([A-Z])\\]\").unwrap();\n    let re_action = Regex::new(r\"move (\\d+) from (\\d+) to (\\d+)\").unwrap();\n    let mut stacks: Vec<Vec<char>> = Vec::new();\n\n    let mut input = io::stdin().lock().lines()\n        .flat_map(|l| l.ok());\n\n    for line in &mut input {\n        if line.trim().is_empty() { break }\n        for (ix, ch) in match_iter::<char>(&re_top, &line).enumerate() {\n            if let Some(ch) = ch {\n                ensure_size(&mut stacks, ix + 1);\n                stacks[ix].push(ch);\n            }\n        }\n    }\n\n    for stack in &mut stacks {\n        stack.reverse()\n    }\n\n    for line in input {\n        if let Some((num, src, dst)) = match_capture::<Action>(&re_action, &line) {\n            let (src, dst) = get_disjoint(&mut stacks, src - 1, dst - 1);\n            assert!(num <= src.len(), \"Trying to pop {} from {}\", num, src.len());\n            let pos = src.len() - num;\n            dst.extend_from_slice(&src[pos..]);\n            src.truncate(pos);\n        }\n    }\n\n    let letters = stacks.iter().map(|s| s.last().expect(\"Stack is empty\"));\n    println!(\"{}\", letters.collect::<String>());\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    let re_top = Regex::new(r\" {4}|\\[([A-Z])\\]\").unwrap();\n    let re_action = Regex::new(r\"move (\\d+) from (\\d+) to (\\d+)\").unwrap();\n    let mut stacks: Vec<Vec<char>> = Vec::new();\n\n    let mut input = io::stdin().lock().lines()\n        .flat_map(|l| l.ok());\n\n    for line in &mut input {\n        if line.trim().is_empty() { break }\n        for (ix, ch) in match_iter::<char>(&re_top, &line).enumerate() {\n            if let Some(ch) = ch {\n                ensure_size(&mut stacks, ix + 1);\n                stacks[ix].push(ch);\n            }\n        }\n    }\n\n    for stack in &mut stacks {\n        stack.reverse()\n    }\n\n    for line in input {\n        if let Some((num, src, dst)) = match_capture::<Action>(&re_action, &line) {\n            let (src, dst) = get_disjoint(&mut stacks, src - 1, dst - 1);\n            assert!(num <= src.len(), \"Trying to pop {} from {}\", num, src.len());\n            let pos = src.len() - num;\n            dst.extend_from_slice(&src[pos..]);\n            src.truncate(pos);\n        }\n    }\n\n    let letters = stacks.iter().map(|s| s.last().expect(\"Stack is empty\"));\n    println!(\"{}\", letters.collect::<String>());\n}", "id": 144, "concepts": ["iterators", "regular expression for pattern matching", "list manipulation", "nested data structures"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nfn main() {\n    if env::args().len() != 2 {\n        panic!(\"Incorrect number of arguments provided\\n\");\n    }\n\n    let input = BufReader::new(File::open(env::args().nth(1).unwrap()).unwrap());\n\n    let mut cols: Vec<BTreeMap<char, i32>> = vec![];\n\n    for line in input.lines() {\n        for (i, c) in line.unwrap().chars().enumerate() {\n            if i == cols.len() {\n                cols.push(BTreeMap::new());\n            }\n            *cols[i].entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut most = String::new();\n    let mut least = String::new();\n    for c in cols {\n        let (m, l) = most_least_common(c);\n        most.push(m);\n        least.push(l);\n    }\n    println!(\"Most common message: {}\", most);\n    println!(\"Least common message: {}\", least);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    if env::args().len() != 2 {\n        panic!(\"Incorrect number of arguments provided\\n\");\n    }\n\n    let input = BufReader::new(File::open(env::args().nth(1).unwrap()).unwrap());\n\n    let mut cols: Vec<BTreeMap<char, i32>> = vec![];\n\n    for line in input.lines() {\n        for (i, c) in line.unwrap().chars().enumerate() {\n            if i == cols.len() {\n                cols.push(BTreeMap::new());\n            }\n            *cols[i].entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut most = String::new();\n    let mut least = String::new();\n    for c in cols {\n        let (m, l) = most_least_common(c);\n        most.push(m);\n        least.push(l);\n    }\n    println!(\"Most common message: {}\", most);\n    println!(\"Least common message: {}\", least);\n}", "id": 145, "concepts": ["iterators", "BTreeMaps", "sorting by frequency", "parsing command line arguments"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\npub fn main() {\n    let game = Game::new();\n\n    game_loop(game, 240, 0.1, |g| {\n        g.game.your_update_function();\n    }, |g| {\n        g.game.your_render_function();\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn main() {\n    let game = Game::new();\n\n    game_loop(game, 240, 0.1, |g| {\n        g.game.your_update_function();\n    }, |g| {\n        g.game.your_render_function();\n    });\n}", "id": 147, "concepts": ["game loop", "function composition", "game loop synchronization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\nfn db_scheme_type_mapper(scheme: &str) -> SchemeType {\n    match scheme {\n        \"postgres\" => SchemeType::Relative(5432),\n        \"mysql\" => SchemeType::Relative(3306),\n        _ => SchemeType::NonRelative,\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn db_scheme_type_mapper(scheme: &str) -> SchemeType {\n    match scheme {\n        \"postgres\" => SchemeType::Relative(5432),\n        \"mysql\" => SchemeType::Relative(3306),\n        _ => SchemeType::NonRelative,\n    }\n}", "id": 149, "concepts": ["mapping of input values to output values", "default return value", "explicit return value", "case statement"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\npub fn write_file(path: PathBuf, content: String) -> Result<(), String> {\n    fs::write(path, content).map_err(|e| e.to_string())\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn write_file(path: PathBuf, content: String) -> Result<(), String> {\n    fs::write(path, content).map_err(|e| e.to_string())\n}", "id": 151, "concepts": ["error handling", "function composition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\nfn rc_test() {\n    use std::rc::Rc;\n\n    let s: Rc<String> = Rc::new(\"shirataki\".to_string());\n    let t: Rc<String> = s.clone();\n    let u: Rc<String> = s.clone();\n\n    assert!(s.contains(\"shira\"));\n    assert_eq!(t.find(\"taki\"), Some(5));\n    println!(\"{} are quite chewy, almost bouncy, but lack flavor\", u);\n\n    // s.push_str(\" noodles\"); // error\n}\n\n### Concepts", "fingerprint": null, "seed": "fn rc_test() {\n    use std::rc::Rc;\n\n    let s: Rc<String> = Rc::new(\"shirataki\".to_string());\n    let t: Rc<String> = s.clone();\n    let u: Rc<String> = s.clone();\n\n    assert!(s.contains(\"shira\"));\n    assert_eq!(t.find(\"taki\"), Some(5));\n    println!(\"{} are quite chewy, almost bouncy, but lack flavor\", u);\n\n    // s.push_str(\" noodles\"); // error\n}", "id": 152, "concepts": ["resource-counted objects", "cloning of resource-counted objects", "string manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn overflow() {\n    let big_val = std::i32::MAX;\n    // let x = big_val + 1; // panic\n    let _x = big_val.wrapping_add(1); // ok\n}\n\n### Concepts", "fingerprint": null, "seed": "fn overflow() {\n    let big_val = std::i32::MAX;\n    // let x = big_val + 1; // panic\n    let _x = big_val.wrapping_add(1); // ok\n}", "id": 153, "concepts": ["integer overflow", "integer wrapping"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\nasync fn run_completions(shell: ShellCompletion) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing completions\");\n\n\tfn generate(generator: impl Generator) {\n\t\tlet mut cmd = Args::command();\n\t\tclap_complete::generate(generator, &mut cmd, \"watchexec\", &mut std::io::stdout());\n\t}\n\n\tmatch shell {\n\t\tShellCompletion::Bash => generate(Shell::Bash),\n\t\tShellCompletion::Elvish => generate(Shell::Elvish),\n\t\tShellCompletion::Fish => generate(Shell::Fish),\n\t\tShellCompletion::Nu => generate(clap_complete_nushell::Nushell),\n\t\tShellCompletion::Powershell => generate(Shell::PowerShell),\n\t\tShellCompletion::Zsh => generate(Shell::Zsh),\n\t}\n\n\tOk(())\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn run_completions(shell: ShellCompletion) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing completions\");\n\n\tfn generate(generator: impl Generator) {\n\t\tlet mut cmd = Args::command();\n\t\tclap_complete::generate(generator, &mut cmd, \"watchexec\", &mut std::io::stdout());\n\t}\n\n\tmatch shell {\n\t\tShellCompletion::Bash => generate(Shell::Bash),\n\t\tShellCompletion::Elvish => generate(Shell::Elvish),\n\t\tShellCompletion::Fish => generate(Shell::Fish),\n\t\tShellCompletion::Nu => generate(clap_complete_nushell::Nushell),\n\t\tShellCompletion::Powershell => generate(Shell::PowerShell),\n\t\tShellCompletion::Zsh => generate(Shell::Zsh),\n\t}\n\n\tOk(())\n}", "id": 154, "concepts": ["optional parameter", "function composition", "type casting", "return value handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn ownership_test() {\n    let mut v = Vec::new();\n    for i in 101..106 {\n        v.push(i.to_string());\n    }\n\n    let fifth = v.pop().unwrap();\n    assert_eq!(fifth, \"105\");\n\n    let second = v.swap_remove(1);\n    assert_eq!(second, \"102\");\n\n    let third = std::mem::replace(&mut v[2], \"substitute\".to_string());\n    assert_eq!(third, \"103\");\n\n    assert_eq!(v, vec![\"101\", \"104\", \"substitute\"]);\n\n    struct Person {\n        name: Option<String>,\n        birth: Option<i32>,\n    };\n\n    let mut composers = Vec::new();\n    composers.push(Person {\n        name: Some(\"Palestrina\".to_string()),\n        birth: Some(1525),\n    });\n\n    // let first_name = composers[0].name // error\n\n    let first_name = std::mem::replace(&mut composers[0].name, None);\n    assert_eq!(first_name, Some(\"Palestrina\".to_string()));\n    assert_eq!(composers[0].name, None);\n    let birth = composers[0].birth.take();\n    assert_eq!(birth, Some(1525));\n    assert_eq!(composers[0].birth, None);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn ownership_test() {\n    let mut v = Vec::new();\n    for i in 101..106 {\n        v.push(i.to_string());\n    }\n\n    let fifth = v.pop().unwrap();\n    assert_eq!(fifth, \"105\");\n\n    let second = v.swap_remove(1);\n    assert_eq!(second, \"102\");\n\n    let third = std::mem::replace(&mut v[2], \"substitute\".to_string());\n    assert_eq!(third, \"103\");\n\n    assert_eq!(v, vec![\"101\", \"104\", \"substitute\"]);\n\n    struct Person {\n        name: Option<String>,\n        birth: Option<i32>,\n    };\n\n    let mut composers = Vec::new();\n    composers.push(Person {\n        name: Some(\"Palestrina\".to_string()),\n        birth: Some(1525),\n    });\n\n    // let first_name = composers[0].name // error\n\n    let first_name = std::mem::replace(&mut composers[0].name, None);\n    assert_eq!(first_name, Some(\"Palestrina\".to_string()));\n    assert_eq!(composers[0].name, None);\n    let birth = composers[0].birth.take();\n    assert_eq!(birth, Some(1525));\n    assert_eq!(composers[0].birth, None);\n}", "id": 155, "concepts": ["ownership transfer", "mutability and immutability", "collections initialization", "destructuring", "optional variables"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 6\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\nfn main() -> Result<()> {\n    let inss = parse_instructions()?;\n\n    for (pc, ins) in inss.iter().enumerate() {\n        match ins.op {\n            Operation::Nothing => {\n                // Don't invert zero `nop`s as `jmp +0` results in a loop.\n                if ins.arg != 0 && print_fixed_acc(&inss, Operation::Jump, pc) {\n                    break;\n                }\n            }\n            Operation::Jump => {\n                // Finish as soon as one inversion fixes the code.\n                if print_fixed_acc(&inss, Operation::Nothing, pc) {\n                    break;\n                }\n            }\n            Operation::Accumulate => {}\n        }\n    }\n\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() -> Result<()> {\n    let inss = parse_instructions()?;\n\n    for (pc, ins) in inss.iter().enumerate() {\n        match ins.op {\n            Operation::Nothing => {\n                // Don't invert zero `nop`s as `jmp +0` results in a loop.\n                if ins.arg != 0 && print_fixed_acc(&inss, Operation::Jump, pc) {\n                    break;\n                }\n            }\n            Operation::Jump => {\n                // Finish as soon as one inversion fixes the code.\n                if print_fixed_acc(&inss, Operation::Nothing, pc) {\n                    break;\n                }\n            }\n            Operation::Accumulate => {}\n        }\n    }\n\n    Ok(())\n}", "id": 156, "concepts": ["algorithm design", "2-pointer technique", "conditional loop", "algorithmic complexity", "precondition checking for type validation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nasync fn fallback_route(_req: HttpRequest) -> impl Responder {\n    HttpResponse::NotFound().json(\"Route not found\")\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn fallback_route(_req: HttpRequest) -> impl Responder {\n    HttpResponse::NotFound().json(\"Route not found\")\n}", "id": 157, "concepts": ["async function implementation", "function composition", "response generation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn main() {\n    let instruction: Vec<String> = std::env::args().collect();\n    let instruction: &String = &instruction[1];\n\n    println!(\"{}\", santa(instruction));\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    let instruction: Vec<String> = std::env::args().collect();\n    let instruction: &String = &instruction[1];\n\n    println!(\"{}\", santa(instruction));\n}", "id": 158, "concepts": ["command-line argument parsing", "string formatting and manipulation", "string interpolation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nfn listing_a_single_migration_name_should_work(api: TestApi) {\n    let dm = api.datamodel_with_provider(\n        r#\"\n        model Cat {\n            id Int @id\n            name String\n        }\n    \"#,\n    );\n\n    let migrations_directory = api.create_migrations_directory();\n\n    api.create_migration(\"init\", &dm, &migrations_directory).send_sync();\n\n    api.apply_migrations(&migrations_directory)\n        .send_sync()\n        .assert_applied_migrations(&[\"init\"]);\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[\"init\"]);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn listing_a_single_migration_name_should_work(api: TestApi) {\n    let dm = api.datamodel_with_provider(\n        r#\"\n        model Cat {\n            id Int @id\n            name String\n        }\n    \"#,\n    );\n\n    let migrations_directory = api.create_migrations_directory();\n\n    api.create_migration(\"init\", &dm, &migrations_directory).send_sync();\n\n    api.apply_migrations(&migrations_directory)\n        .send_sync()\n        .assert_applied_migrations(&[\"init\"]);\n\n    api.list_migration_directories(&migrations_directory)\n        .send()\n        .assert_listed_directories(&[\"init\"]);\n}", "id": 159, "concepts": ["creating migration directories", "migration directory entry retrieval", "migration file retrieval", "migration application"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn de_timeline(raw: TimelineRaw, even: bool) -> game::Timeline {\n    let mut res = game::Timeline::new(\n        de_l(raw.index, even),\n        raw.width,\n        raw.height,\n        raw.begins_at,\n        raw.emerges_from.map(|x| de_l(x, even)),\n    );\n\n    let index = de_l(raw.index, even);\n    let begins_at = raw.begins_at;\n    let width = raw.width;\n    let height = raw.height;\n\n    res.states = raw\n        .states\n        .into_iter()\n        .enumerate()\n        .map(|(i, b)| de_board(b, begins_at + i as isize, index, width, height))\n        .collect();\n\n    res\n}\n\n### Concepts", "fingerprint": null, "seed": "fn de_timeline(raw: TimelineRaw, even: bool) -> game::Timeline {\n    let mut res = game::Timeline::new(\n        de_l(raw.index, even),\n        raw.width,\n        raw.height,\n        raw.begins_at,\n        raw.emerges_from.map(|x| de_l(x, even)),\n    );\n\n    let index = de_l(raw.index, even);\n    let begins_at = raw.begins_at;\n    let width = raw.width;\n    let height = raw.height;\n\n    res.states = raw\n        .states\n        .into_iter()\n        .enumerate()\n        .map(|(i, b)| de_board(b, begins_at + i as isize, index, width, height))\n        .collect();\n\n    res\n}", "id": 160, "concepts": ["iterator usage for list comprehension", "map usage for list iteration", "defining new types", "type alias usage"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nfn expect_money_conserved(table: &Table) {\n  let mut history: BTreeMap<u32, Vec<Row>> = BTreeMap::new();\n  for c in table.scan() {\n    history.entry(c.t).or_insert(Vec::new()).push(Row { k: c.k, v: c.v });\n  }\n  let mut tracker: HashMap<i32, i32> = HashMap::new();\n  for (_, rs) in history {\n    for r in rs {\n      tracker.insert(r.k, r.v);\n    }\n    let mut sum = 0;\n    for (_, v) in tracker.clone() {\n      sum += v;\n    }\n    assert! (sum == 0);\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn expect_money_conserved(table: &Table) {\n  let mut history: BTreeMap<u32, Vec<Row>> = BTreeMap::new();\n  for c in table.scan() {\n    history.entry(c.t).or_insert(Vec::new()).push(Row { k: c.k, v: c.v });\n  }\n  let mut tracker: HashMap<i32, i32> = HashMap::new();\n  for (_, rs) in history {\n    for r in rs {\n      tracker.insert(r.k, r.v);\n    }\n    let mut sum = 0;\n    for (_, v) in tracker.clone() {\n      sum += v;\n    }\n    assert! (sum == 0);\n  }\n}", "id": 162, "concepts": ["BTree map usage", "nested data structures", "hash map iteration", "map mutation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nfn assert_memory_store_empty_bytes<M: Memory>(memory: &mut M) {\n    assert!(memory.store_byte(0, 0, 42).is_ok());\n    assert!(memory.store_bytes(0, &[]).is_ok());\n}\n\n### Concepts", "fingerprint": null, "seed": "fn assert_memory_store_empty_bytes<M: Memory>(memory: &mut M) {\n    assert!(memory.store_byte(0, 0, 42).is_ok());\n    assert!(memory.store_bytes(0, &[]).is_ok());\n}", "id": 163, "concepts": ["match error type identification", "conditional assertion based on optional value", "structured error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\npub async fn render_window_wasm(subaction: brawllib_rs::high_level_fighter::HighLevelSubaction) {\n    use brawllib_rs::renderer::app::state::{AppEventIncoming, State};\n    use brawllib_rs::renderer::app::App;\n    use wasm_bindgen::prelude::*;\n    use web_sys::HtmlElement;\n\n    let document = web_sys::window().unwrap().document().unwrap();\n\n    let body = document.body().unwrap();\n    let parent_div = document.create_element(\"div\").unwrap();\n    parent_div\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .style()\n        .set_css_text(\"margin: auto; width: 80%; aspect-ratio: 4 / 2; background-color: black\");\n    body.append_child(&parent_div).unwrap();\n\n    let app = App::new_insert_into_element(parent_div, subaction).await;\n    let event_tx = app.get_event_tx();\n\n    let frame = document.create_element(\"p\").unwrap();\n    frame.set_inner_html(\"Frame: 0\");\n    body.append_child(&frame).unwrap();\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Run\");\n    let event_tx_move = event_tx.clone();\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Stop\" {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Pause))\n                .unwrap();\n            button_move.set_inner_html(\"Run\");\n        } else {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Play))\n                .unwrap();\n            button_move.set_inner_html(\"Stop\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Perspective\");\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Orthographic\" {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(false))\n                .unwrap();\n            button_move.set_inner_html(\"Perspective\");\n        } else {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(true))\n                .unwrap();\n            button_move.set_inner_html(\"Orthographic\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    app.get_event_tx()\n        .send(AppEventIncoming::SetState(State::Pause))\n        .unwrap();\n\n    app.run();\n}\n\n### Concepts", "fingerprint": null, "seed": "pub async fn render_window_wasm(subaction: brawllib_rs::high_level_fighter::HighLevelSubaction) {\n    use brawllib_rs::renderer::app::state::{AppEventIncoming, State};\n    use brawllib_rs::renderer::app::App;\n    use wasm_bindgen::prelude::*;\n    use web_sys::HtmlElement;\n\n    let document = web_sys::window().unwrap().document().unwrap();\n\n    let body = document.body().unwrap();\n    let parent_div = document.create_element(\"div\").unwrap();\n    parent_div\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .style()\n        .set_css_text(\"margin: auto; width: 80%; aspect-ratio: 4 / 2; background-color: black\");\n    body.append_child(&parent_div).unwrap();\n\n    let app = App::new_insert_into_element(parent_div, subaction).await;\n    let event_tx = app.get_event_tx();\n\n    let frame = document.create_element(\"p\").unwrap();\n    frame.set_inner_html(\"Frame: 0\");\n    body.append_child(&frame).unwrap();\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Run\");\n    let event_tx_move = event_tx.clone();\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Stop\" {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Pause))\n                .unwrap();\n            button_move.set_inner_html(\"Run\");\n        } else {\n            event_tx_move\n                .send(AppEventIncoming::SetState(State::Play))\n                .unwrap();\n            button_move.set_inner_html(\"Stop\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    let button = document.create_element(\"button\").unwrap();\n    body.append_child(&button).unwrap();\n    let button_move = button.clone();\n    button_move.set_inner_html(\"Perspective\");\n    let do_thing = Closure::wrap(Box::new(move || {\n        if button_move.inner_html() == \"Orthographic\" {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(false))\n                .unwrap();\n            button_move.set_inner_html(\"Perspective\");\n        } else {\n            event_tx\n                .send(AppEventIncoming::SetPerspective(true))\n                .unwrap();\n            button_move.set_inner_html(\"Orthographic\");\n        }\n    }) as Box<dyn FnMut()>);\n    button\n        .dyn_ref::<HtmlElement>()\n        .unwrap()\n        .set_onclick(Some(do_thing.as_ref().unchecked_ref()));\n\n    app.get_event_tx()\n        .send(AppEventIncoming::SetState(State::Pause))\n        .unwrap();\n\n    app.run();\n}", "id": 164, "concepts": ["async/await syntax", "closure", "DOM manipulation", "thread communication", "synchronization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\npub fn module<'a>(context: &'a Context) -> Option<Module<'a>> {\n    const SUCCESS_CHAR: &str = \"\u279c\";\n    const FAILURE_CHAR: &str = \"\u2716\";\n    let color_success = Color::Green.bold();\n    let color_failure = Color::Red.bold();\n\n    let mut module = context.new_module(\"character\")?;\n    module.get_prefix().set_value(\"\");\n\n    let arguments = &context.arguments;\n    let use_symbol = module\n        .config_value_bool(\"use_symbol_for_status\")\n        .unwrap_or(false);\n    let exit_success = arguments.value_of(\"status_code\").unwrap_or(\"0\") == \"0\";\n\n    /* If an error symbol is set in the config, use symbols to indicate\n    success/failure, in addition to color */\n    let symbol = if use_symbol && !exit_success {\n        module.new_segment(\"error_symbol\", FAILURE_CHAR)\n    } else {\n        module.new_segment(\"symbol\", SUCCESS_CHAR)\n    };\n\n    if exit_success {\n        symbol.set_style(color_success.bold());\n    } else {\n        symbol.set_style(color_failure.bold());\n    };\n\n    Some(module)\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn module<'a>(context: &'a Context) -> Option<Module<'a>> {\n    const SUCCESS_CHAR: &str = \"\u279c\";\n    const FAILURE_CHAR: &str = \"\u2716\";\n    let color_success = Color::Green.bold();\n    let color_failure = Color::Red.bold();\n\n    let mut module = context.new_module(\"character\")?;\n    module.get_prefix().set_value(\"\");\n\n    let arguments = &context.arguments;\n    let use_symbol = module\n        .config_value_bool(\"use_symbol_for_status\")\n        .unwrap_or(false);\n    let exit_success = arguments.value_of(\"status_code\").unwrap_or(\"0\") == \"0\";\n\n    /* If an error symbol is set in the config, use symbols to indicate\n    success/failure, in addition to color */\n    let symbol = if use_symbol && !exit_success {\n        module.new_segment(\"error_symbol\", FAILURE_CHAR)\n    } else {\n        module.new_segment(\"symbol\", SUCCESS_CHAR)\n    };\n\n    if exit_success {\n        symbol.set_style(color_success.bold());\n    } else {\n        symbol.set_style(color_failure.bold());\n    };\n\n    Some(module)\n}", "id": 166, "concepts": ["symbol for success or failure", "conditional logic", "string concatenation", "string comparison"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\nfn handle_trame(trame: Trame) -> Option<Trame> {\n    match (\n        trame.id,\n        trame.cmd,\n        &trame.data[0..trame.data_length as usize],\n    ) {\n        (0...5, 0x0, [0x55]) => Some(trame!(trame.id, 0x00, [0xAA])),\n        (_, _, _) => None,\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn handle_trame(trame: Trame) -> Option<Trame> {\n    match (\n        trame.id,\n        trame.cmd,\n        &trame.data[0..trame.data_length as usize],\n    ) {\n        (0...5, 0x0, [0x55]) => Some(trame!(trame.id, 0x00, [0xAA])),\n        (_, _, _) => None,\n    }\n}", "id": 167, "concepts": ["pattern matching", "function pointer", "bitwise operations", "generic function parameters"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\nfn\ntest_string\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\n\"\nhello\nworld\n!\n\"\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\ns\n.\nto_owned\n(\n)\n]\n)\n?\n;\nlet\nfrom\n:\nString\n=\ndb\n.\none_column\n(\n\"\nSELECT\nt\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nfrom\ns\n)\n;\nOk\n(\n(\n)\n)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn\ntest_string\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\n\"\nhello\nworld\n!\n\"\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\ns\n.\nto_owned\n(\n)\n]\n)\n?\n;\nlet\nfrom\n:\nString\n=\ndb\n.\none_column\n(\n\"\nSELECT\nt\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nfrom\ns\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 168, "concepts": ["use of the `?` operator and `Result` generic type", "string interpolation", "conditional error handling", "conditional execution of code"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\npub fn acrn_read_dir(path: &str, recursive: bool) -> Result<Vec<DirEntry>, String> {\n    read_dir(path, recursive).map_err(|e| e.to_string())\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn acrn_read_dir(path: &str, recursive: bool) -> Result<Vec<DirEntry>, String> {\n    read_dir(path, recursive).map_err(|e| e.to_string())\n}", "id": 170, "concepts": ["recursive directory traversal with a function that has multiple base cases and returns a result of type `Vec<DirEntry>`"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\npub fn acrn_create_dir(path: &str, recursive: bool) -> Result<(), String> {\n    if recursive {\n        fs::create_dir_all(path).map_err(|e| e.to_string())\n    } else {\n        fs::create_dir(path).map_err(|e| e.to_string())\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn acrn_create_dir(path: &str, recursive: bool) -> Result<(), String> {\n    if recursive {\n        fs::create_dir_all(path).map_err(|e| e.to_string())\n    } else {\n        fs::create_dir(path).map_err(|e| e.to_string())\n    }\n}", "id": 171, "concepts": ["recursive directory creation with a flag to determine behavior", "generic error handling with match expression"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nfn parse_prefix_command(rom: &[u8]) -> Option<Box<dyn Instruction>> {\n    let opcode = rom[0];\n    match opcode {\n        /* RLC r */\n        0x00...0x07 => unimplemented!(\"RLC r\"),\n        /* RRC r */\n        0x08...0x0F => unimplemented!(\"RRC r\"),\n        /* RL B */\n        0x10 => cmd!(alu::RotateRegisterLeft(r8!(B))),\n        /* RL C */\n        0x11 => cmd!(alu::RotateRegisterLeft(r8!(C))),\n        /* RL D */\n        0x12 => cmd!(alu::RotateRegisterLeft(r8!(D))),\n        /* RL E */\n        0x13 => cmd!(alu::RotateRegisterLeft(r8!(E))),\n        /* RL H */\n        0x14 => cmd!(alu::RotateRegisterLeft(r8!(H))),\n        /* RL L */\n        0x15 => cmd!(alu::RotateRegisterLeft(r8!(L))),\n        /* RL A */\n        0x17 => cmd!(alu::RotateRegisterLeft(r8!(A))),\n        /* RL (HL) */\n        0x16 => unimplemented!(\"RL (HL)\"),\n        /* RR r */\n        0x17...0x1F => unimplemented!(\"RR r\"),\n        /* SLA r */\n        0x20...0x27 => unimplemented!(\"SLA r\"),\n        /* SRA r */\n        0x27...0x2F => unimplemented!(\"SRA r\"),\n        /* BIT 0,r */\n        0x40...0x47 => unimplemented!(\"BIT 0,r\"),\n        /* BIT 1,r */\n        0x47...0x4F => unimplemented!(\"BIT 1,r\"),\n        /* BIT 7,r */\n        0x78...0x7F => {\n            let bit: u8 = 0b1000_0000;\n            let register = match opcode {\n                0x78 => Register8::B,\n                0x79 => Register8::C,\n                0x7A => Register8::D,\n                0x7B => Register8::E,\n                0x7C => Register8::H,\n                0x7D => Register8::L,\n                // 0x7E => TargetRegister::HL,\n                0x7F => Register8::A,\n                _ => unreachable!()\n            };\n            cmd!(alu::Bit {\n                bit,\n                register\n            })\n        },\n        _ => None\n\n    }\n\n}\n\n### Concepts", "fingerprint": null, "seed": "fn parse_prefix_command(rom: &[u8]) -> Option<Box<dyn Instruction>> {\n    let opcode = rom[0];\n    match opcode {\n        /* RLC r */\n        0x00...0x07 => unimplemented!(\"RLC r\"),\n        /* RRC r */\n        0x08...0x0F => unimplemented!(\"RRC r\"),\n        /* RL B */\n        0x10 => cmd!(alu::RotateRegisterLeft(r8!(B))),\n        /* RL C */\n        0x11 => cmd!(alu::RotateRegisterLeft(r8!(C))),\n        /* RL D */\n        0x12 => cmd!(alu::RotateRegisterLeft(r8!(D))),\n        /* RL E */\n        0x13 => cmd!(alu::RotateRegisterLeft(r8!(E))),\n        /* RL H */\n        0x14 => cmd!(alu::RotateRegisterLeft(r8!(H))),\n        /* RL L */\n        0x15 => cmd!(alu::RotateRegisterLeft(r8!(L))),\n        /* RL A */\n        0x17 => cmd!(alu::RotateRegisterLeft(r8!(A))),\n        /* RL (HL) */\n        0x16 => unimplemented!(\"RL (HL)\"),\n        /* RR r */\n        0x17...0x1F => unimplemented!(\"RR r\"),\n        /* SLA r */\n        0x20...0x27 => unimplemented!(\"SLA r\"),\n        /* SRA r */\n        0x27...0x2F => unimplemented!(\"SRA r\"),\n        /* BIT 0,r */\n        0x40...0x47 => unimplemented!(\"BIT 0,r\"),\n        /* BIT 1,r */\n        0x47...0x4F => unimplemented!(\"BIT 1,r\"),\n        /* BIT 7,r */\n        0x78...0x7F => {\n            let bit: u8 = 0b1000_0000;\n            let register = match opcode {\n                0x78 => Register8::B,\n                0x79 => Register8::C,\n                0x7A => Register8::D,\n                0x7B => Register8::E,\n                0x7C => Register8::H,\n                0x7D => Register8::L,\n                // 0x7E => TargetRegister::HL,\n                0x7F => Register8::A,\n                _ => unreachable!()\n            };\n            cmd!(alu::Bit {\n                bit,\n                register\n            })\n        },\n        _ => None\n\n    }\n\n}", "id": 172, "concepts": ["command opcode parsing", "bitwise operations", "register manipulation", "conditional branching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nfn show_image(image: &Image)\n{\n    let sdl             = sdl2::init().unwrap();\n    let video_subsystem = sdl.video().unwrap();\n    let display_mode    = video_subsystem.current_display_mode(0).unwrap();\n\n    let w = match display_mode.w as u32 > image.width {\n        true  => image.width,\n        false => display_mode.w as u32\n    };\n    let h = match display_mode.h as u32 > image.height {\n        true  => image.height,\n        false => display_mode.h as u32\n    };\n    \n    let window = video_subsystem\n        .window(\"Image\", w, h)\n        .build()\n        .unwrap();\n    let mut canvas = window\n        .into_canvas()\n        .present_vsync()\n        .build()\n        .unwrap();\n    let black = sdl2::pixels::Color::RGB(0, 0, 0);\n\n    let mut event_pump = sdl.event_pump().unwrap();\n    // render image\n        canvas.set_draw_color(black);\n        canvas.clear();\n\n        for r in 0..image.height {\n            for c in 0..image.width {\n                let pixel = &image.pixels[image.height as usize - r as usize - 1][c as usize];\n                canvas.set_draw_color(Color::RGB(pixel.R as u8, pixel.G as u8, pixel.B as u8));\n                canvas.fill_rect(Rect::new(c as i32, r as i32, 1, 1)).unwrap();\n            }\n        }\n        \n        canvas.present();\n\n    'main: loop \n    {        \n        for event in event_pump.poll_iter() {\n            match event {\n                sdl2::event::Event::Quit {..} => break 'main,\n                _ => {},\n            }\n        }\n\n        sleep(Duration::new(0, 250000000));\n    }\n    \n}\n\n### Concepts", "fingerprint": null, "seed": "fn show_image(image: &Image)\n{\n    let sdl             = sdl2::init().unwrap();\n    let video_subsystem = sdl.video().unwrap();\n    let display_mode    = video_subsystem.current_display_mode(0).unwrap();\n\n    let w = match display_mode.w as u32 > image.width {\n        true  => image.width,\n        false => display_mode.w as u32\n    };\n    let h = match display_mode.h as u32 > image.height {\n        true  => image.height,\n        false => display_mode.h as u32\n    };\n    \n    let window = video_subsystem\n        .window(\"Image\", w, h)\n        .build()\n        .unwrap();\n    let mut canvas = window\n        .into_canvas()\n        .present_vsync()\n        .build()\n        .unwrap();\n    let black = sdl2::pixels::Color::RGB(0, 0, 0);\n\n    let mut event_pump = sdl.event_pump().unwrap();\n    // render image\n        canvas.set_draw_color(black);\n        canvas.clear();\n\n        for r in 0..image.height {\n            for c in 0..image.width {\n                let pixel = &image.pixels[image.height as usize - r as usize - 1][c as usize];\n                canvas.set_draw_color(Color::RGB(pixel.R as u8, pixel.G as u8, pixel.B as u8));\n                canvas.fill_rect(Rect::new(c as i32, r as i32, 1, 1)).unwrap();\n            }\n        }\n        \n        canvas.present();\n\n    'main: loop \n    {        \n        for event in event_pump.poll_iter() {\n            match event {\n                sdl2::event::Event::Quit {..} => break 'main,\n                _ => {},\n            }\n        }\n\n        sleep(Duration::new(0, 250000000));\n    }\n    \n}", "id": 174, "concepts": ["image rendering", "event handling", "SDL2 library", "generic type parameters"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\npub fn acrn_remove_file(path: &str) -> Result<(), String> {\n    fs::remove_file(path).map_err(|e| e.to_string())\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn acrn_remove_file(path: &str) -> Result<(), String> {\n    fs::remove_file(path).map_err(|e| e.to_string())\n}", "id": 175, "concepts": ["file removal", "function composition", "error propagation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 6\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 7\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn run_a_few_inputs() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_few\");\n\n    let project = project(\"run_a_few_inputs\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_few\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() != 4);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"pass-0\"), \"\")\n        .file(corpus.join(\"pass-1\"), \"1\")\n        .file(corpus.join(\"pass-2\"), \"12\")\n        .file(corpus.join(\"pass-3\"), \"123\")\n        .file(corpus.join(\"fail\"), \"fail\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_few\")\n        .arg(corpus.join(\"pass-0\"))\n        .arg(corpus.join(\"pass-1\"))\n        .arg(corpus.join(\"pass-2\"))\n        .arg(corpus.join(\"pass-3\"))\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Running 4 inputs 1 time(s) each.\").and(\n                predicate::str::contains(\"Running: fuzz/corpus/run_few/pass\"),\n            ),\n        )\n        .success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn run_a_few_inputs() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"run_few\");\n\n    let project = project(\"run_a_few_inputs\")\n        .with_fuzz()\n        .fuzz_target(\n            \"run_few\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    assert!(data.len() != 4);\n                });\n            \"#,\n        )\n        .file(corpus.join(\"pass-0\"), \"\")\n        .file(corpus.join(\"pass-1\"), \"1\")\n        .file(corpus.join(\"pass-2\"), \"12\")\n        .file(corpus.join(\"pass-3\"), \"123\")\n        .file(corpus.join(\"fail\"), \"fail\")\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"run_few\")\n        .arg(corpus.join(\"pass-0\"))\n        .arg(corpus.join(\"pass-1\"))\n        .arg(corpus.join(\"pass-2\"))\n        .arg(corpus.join(\"pass-3\"))\n        .assert()\n        .stderr(\n            predicate::str::contains(\"Running 4 inputs 1 time(s) each.\").and(\n                predicate::str::contains(\"Running: fuzz/corpus/run_few/pass\"),\n            ),\n        )\n        .success();\n}", "id": 176, "concepts": ["fuzzing", "file input", "fuzz target", "generic function input"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\npub fn task_set_active(target: CAddr) {\n    system_call(SystemCall::TaskSetActive {\n        request: target\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn task_set_active(target: CAddr) {\n    system_call(SystemCall::TaskSetActive {\n        request: target\n    });\n}", "id": 178, "concepts": ["system call", "native library interfacing", "platform-specific system call functionality"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 7\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 8\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nfn usart_pc() {}\n\n### Concepts", "fingerprint": null, "seed": "fn usart_pc() {}", "id": 179, "concepts": ["USART peripheral", "SPI communication", "synchronous I/O", "bit operations"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\nfn copy_test() {\n    {\n        /*\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number); // error\n        */\n\n        #[derive(Copy, Clone)]\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number);\n\n        /*\n        #[derive(Copy, Clone)]\n        struct StringLabel {\n            name: String,\n        }\n        */\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn copy_test() {\n    {\n        /*\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number); // error\n        */\n\n        #[derive(Copy, Clone)]\n        struct Label {\n            number: u32,\n        }\n\n        fn print(l: Label) {\n            println!(\"STAMP: {}\", l.number);\n        }\n        let l = Label { number: 3 };\n        print(l);\n        println!(\"My label number is: {}\", l.number);\n\n        /*\n        #[derive(Copy, Clone)]\n        struct StringLabel {\n            name: String,\n        }\n        */\n    }\n}", "id": 180, "concepts": ["struct declaration", "struct copy", "struct mutability", "struct assignment"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\npub fn acrn_write(file_path: &str, contents: &str) -> Result<(), String> {\n    let mut file = File::create(file_path).map_err(|e| e.to_string())?;\n    file.write_all(contents.as_bytes())\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn acrn_write(file_path: &str, contents: &str) -> Result<(), String> {\n    let mut file = File::create(file_path).map_err(|e| e.to_string())?;\n    file.write_all(contents.as_bytes())\n        .map_err(|e| e.to_string())?;\n    Ok(())\n}", "id": 181, "concepts": ["creating a file with a file descriptor", "writing to a file with a file descriptor", "error handling with exceptions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\npub fn test_jump0() {\n    let buffer = fs::read(\"tests/programs/jump0_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"jump0_64\".into()]);\n    assert!(result.is_err());\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_jump0() {\n    let buffer = fs::read(\"tests/programs/jump0_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"jump0_64\".into()]);\n    assert!(result.is_err());\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 185, "concepts": ["memory check", "buffer reading", "error handling in Rust", "return value from function"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn build_author_map(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    match build_author_map_(repo, reviewers, mailmap, from, to) {\n        Ok(o) => Ok(o),\n        Err(err) => Err(ErrorContext(\n            format!(\n                \"build_author_map(repo={}, from={:?}, to={:?})\",\n                repo.path().display(),\n                from,\n                to\n            ),\n            err,\n        ))?,\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn build_author_map(\n    repo: &Repository,\n    reviewers: &Reviewers,\n    mailmap: &Mailmap,\n    from: &str,\n    to: &str,\n) -> Result<AuthorMap, Box<dyn std::error::Error>> {\n    match build_author_map_(repo, reviewers, mailmap, from, to) {\n        Ok(o) => Ok(o),\n        Err(err) => Err(ErrorContext(\n            format!(\n                \"build_author_map(repo={}, from={:?}, to={:?})\",\n                repo.path().display(),\n                from,\n                to\n            ),\n            err,\n        ))?,\n    }\n}", "id": 186, "concepts": ["conditional branching", "error handling with return values", "nested function composition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\npub fn channel_take_raw(target: CAddr) -> u64 {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Raw(v) => return v,\n        _ => panic!(),\n    };\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn channel_take_raw(target: CAddr) -> u64 {\n    let result = channel_take_nonpayload(target);\n    match result {\n        ChannelMessage::Raw(v) => return v,\n        _ => panic!(),\n    };\n}", "id": 187, "concepts": ["conditional branching", "panic handling", "return value destructuring"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\nfn a_table_should_reject_a_stale_write() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }]);\n  assert_eq!(table.write(0, &[Row { k: 0, v: 2 }]), WriteResult::Stale { cond: 0, max: 1 });\n  let mut vs = [Value::default(); 1];\n  table.read (1, &[0], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }]);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn a_table_should_reject_a_stale_write() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }]);\n  assert_eq!(table.write(0, &[Row { k: 0, v: 2 }]), WriteResult::Stale { cond: 0, max: 1 });\n  let mut vs = [Value::default(); 1];\n  table.read (1, &[0], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }]);\n}", "id": 188, "concepts": ["hash-map of tree-map", "conditional table write", "read-only table read", "table write result value", "database design"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 6\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\nfn\ntest_str\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\n\"\nhello\nworld\n!\n\"\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\ns\n]\n)\n?\n;\nlet\nfrom\n:\nString\n=\ndb\n.\none_column\n(\n\"\nSELECT\nt\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nfrom\ns\n)\n;\nOk\n(\n(\n)\n)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn\ntest_str\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\ns\n=\n\"\nhello\nworld\n!\n\"\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nt\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\ns\n]\n)\n?\n;\nlet\nfrom\n:\nString\n=\ndb\n.\none_column\n(\n\"\nSELECT\nt\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nfrom\ns\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 189, "concepts": ["database query execution", "string deserialization from database table", "list comprehension in function call", "string comparison"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\nfn tmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"i_hate_zed\");\n    let test_case = corpus.join(\"test-case\");\n    let project = project(\"tmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"i_hate_zed\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let s = String::from_utf8_lossy(data);\n                    if s.contains('z') {\n                        panic!(\"nooooooooo\");\n                    }\n                });\n            \"#,\n        )\n        .file(&test_case, \"pack my box with five dozen liquor jugs\")\n        .build();\n    let test_case = project.root().join(test_case);\n    project\n        .cargo_fuzz()\n        .arg(\"tmin\")\n        .arg(\"i_hate_zed\")\n        .arg(\"--sanitizer=none\")\n        .arg(&test_case)\n        .assert()\n        .stderr(\n            predicates::str::contains(\"CRASH_MIN: minimizing crash input: \")\n                .and(predicate::str::contains(\"(1 bytes) caused a crash\"))\n                .and(predicate::str::contains(\n                    \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\\n                     \\n\\\n                     Minimized artifact:\\n\\\n                     \\n\\\n                     \\tfuzz/artifacts/i_hate_zed/minimized-from-\"))\n                .and(predicate::str::contains(\n                    \"Reproduce with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz run --sanitizer=none i_hate_zed fuzz/artifacts/i_hate_zed/minimized-from-\"\n                )),\n        )\n        .success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn tmin() {\n    let corpus = Path::new(\"fuzz\").join(\"corpus\").join(\"i_hate_zed\");\n    let test_case = corpus.join(\"test-case\");\n    let project = project(\"tmin\")\n        .with_fuzz()\n        .fuzz_target(\n            \"i_hate_zed\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|data: &[u8]| {\n                    let s = String::from_utf8_lossy(data);\n                    if s.contains('z') {\n                        panic!(\"nooooooooo\");\n                    }\n                });\n            \"#,\n        )\n        .file(&test_case, \"pack my box with five dozen liquor jugs\")\n        .build();\n    let test_case = project.root().join(test_case);\n    project\n        .cargo_fuzz()\n        .arg(\"tmin\")\n        .arg(\"i_hate_zed\")\n        .arg(\"--sanitizer=none\")\n        .arg(&test_case)\n        .assert()\n        .stderr(\n            predicates::str::contains(\"CRASH_MIN: minimizing crash input: \")\n                .and(predicate::str::contains(\"(1 bytes) caused a crash\"))\n                .and(predicate::str::contains(\n                    \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\\n                     \\n\\\n                     Minimized artifact:\\n\\\n                     \\n\\\n                     \\tfuzz/artifacts/i_hate_zed/minimized-from-\"))\n                .and(predicate::str::contains(\n                    \"Reproduce with:\\n\\\n                     \\n\\\n                     \\tcargo fuzz run --sanitizer=none i_hate_zed fuzz/artifacts/i_hate_zed/minimized-from-\"\n                )),\n        )\n        .success();\n}", "id": 191, "concepts": ["fuzzing with libFuzzer", "command line options", "reading from test case files", "string comparison", "assertions", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 7\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\npub fn pivot<T: PartialOrd>(v: &mut [T]) -> usize {\n    let mut p = rand::read(v.len());\n    v.swap(p, 0);\n    p = 0;\n    for i in 1..v.len() {\n        if v[i] < v[p] {\n            // move our pivot forward 1, and put this element before it\n            v.swap(p+1, i);\n            v.swap(p, p+1);\n            p += 1\n        }\n    }\n    p\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn pivot<T: PartialOrd>(v: &mut [T]) -> usize {\n    let mut p = rand::read(v.len());\n    v.swap(p, 0);\n    p = 0;\n    for i in 1..v.len() {\n        if v[i] < v[p] {\n            // move our pivot forward 1, and put this element before it\n            v.swap(p+1, i);\n            v.swap(p, p+1);\n            p += 1\n        }\n    }\n    p\n}", "id": 194, "concepts": ["array element access", "random access", "in-place sorting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\nfn active_entity(entity: Entity, world: &World) -> bool {\n    return world.masks[entity] & VOXEL_PASS_MASK == VOXEL_PASS_MASK;\n}\n\n### Concepts", "fingerprint": null, "seed": "fn active_entity(entity: Entity, world: &World) -> bool {\n    return world.masks[entity] & VOXEL_PASS_MASK == VOXEL_PASS_MASK;\n}", "id": 195, "concepts": ["bitwise operations", "bitmasks", "bitwise comparison", "bitwise logical operators"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nfn main() -> ! {\n    let mut robot = init_peripherals(\n        stm32f446::Peripherals::take().unwrap(),\n        cortex_m::Peripherals::take().unwrap(),\n    );\n\n    init_servo(&mut robot);\n\n    let mut reader = TrameReader::new();\n\n    loop {\n        let b = block!(robot.pc_rx.read()).unwrap();\n        reader.step(b);\n        if let Some(trame) = reader.pop_trame() {\n            asm::bkpt();\n        }\n\n        /*\n        let mess = servos[0x05].stat();\n        for b in mess {\n            block!(robot.servo_tx.write(b)).unwrap();\n        }\n\n        robot.delay.delay_ms(70 as u16);\n*/\n        /*\n        if let Ok(byte) = pc_rx.read() {\n            reader.step(byte);\n        }\n        if let Some(trame) = reader.pop_trame() {\n            if let Some(sent) = handle_trame(trame) {\n                let (arr, size): ([u8; 15], usize) = sent.into();\n                for b in arr[0..size].iter() {\n                    block!(pc_tx.write(*b)).unwrap();\n                }\n            }\n        }*/\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() -> ! {\n    let mut robot = init_peripherals(\n        stm32f446::Peripherals::take().unwrap(),\n        cortex_m::Peripherals::take().unwrap(),\n    );\n\n    init_servo(&mut robot);\n\n    let mut reader = TrameReader::new();\n\n    loop {\n        let b = block!(robot.pc_rx.read()).unwrap();\n        reader.step(b);\n        if let Some(trame) = reader.pop_trame() {\n            asm::bkpt();\n        }\n\n        /*\n        let mess = servos[0x05].stat();\n        for b in mess {\n            block!(robot.servo_tx.write(b)).unwrap();\n        }\n\n        robot.delay.delay_ms(70 as u16);\n*/\n        /*\n        if let Ok(byte) = pc_rx.read() {\n            reader.step(byte);\n        }\n        if let Some(trame) = reader.pop_trame() {\n            if let Some(sent) = handle_trame(trame) {\n                let (arr, size): ([u8; 15], usize) = sent.into();\n                for b in arr[0..size].iter() {\n                    block!(pc_tx.write(*b)).unwrap();\n                }\n            }\n        }*/\n    }\n}", "id": 196, "concepts": ["async-await", "blocking io", "async io", "error handling", "try-catch", "task-based concurrency"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\nfn read_num(cursor: &mut Cursor<Vec<u8>>) -> Result<u32, Box<std::error::Error>> {\n    let mut v: Vec<u8> = vec![];\n    let mut c: [u8; 1] = [0];\n\n    // consume whitespace\n    loop {\n        cursor.read(&mut c)?;\n        match &c {\n            b\" \" | b\"\\t\" | b\"\\n\" => { },\n              _                  => { cursor.seek(std::io::SeekFrom::Current(-1)); break; }\n        }\n    }\n\n    // read number\n    loop {\n        cursor.read(&mut c)?;\n        match c[0] {\n            b'0' ... b'9'        => { v.push(c[0]); },\n            b' ' | b'\\t' | b'\\n' => { cursor.seek(std::io::SeekFrom::Current(-1)); break; },\n              _                  => { bail!(\"Parse error\") }\n        }\n    }\n\n    let num_str = std::str::from_utf8(&v)?;\n    let num     = num_str.parse::<u32>()?;\n    Ok(num)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn read_num(cursor: &mut Cursor<Vec<u8>>) -> Result<u32, Box<std::error::Error>> {\n    let mut v: Vec<u8> = vec![];\n    let mut c: [u8; 1] = [0];\n\n    // consume whitespace\n    loop {\n        cursor.read(&mut c)?;\n        match &c {\n            b\" \" | b\"\\t\" | b\"\\n\" => { },\n              _                  => { cursor.seek(std::io::SeekFrom::Current(-1)); break; }\n        }\n    }\n\n    // read number\n    loop {\n        cursor.read(&mut c)?;\n        match c[0] {\n            b'0' ... b'9'        => { v.push(c[0]); },\n            b' ' | b'\\t' | b'\\n' => { cursor.seek(std::io::SeekFrom::Current(-1)); break; },\n              _                  => { bail!(\"Parse error\") }\n        }\n    }\n\n    let num_str = std::str::from_utf8(&v)?;\n    let num     = num_str.parse::<u32>()?;\n    Ok(num)\n}", "id": 197, "concepts": ["string parsing", "string manipulation", "file reading", "input validation with assertions", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\nasync fn run_manpage(_args: Args) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing manpage\");\n\n\tlet man = Man::new(Args::command().long_version(None));\n\tlet mut buffer: Vec<u8> = Default::default();\n\tman.render(&mut buffer).into_diagnostic()?;\n\n\tif std::io::stdout().is_terminal() && which::which(\"man\").is_ok() {\n\t\tlet mut child = Command::new(\"man\")\n\t\t\t.arg(\"-l\")\n\t\t\t.arg(\"-\")\n\t\t\t.stdin(Stdio::piped())\n\t\t\t.stdout(Stdio::inherit())\n\t\t\t.stderr(Stdio::inherit())\n\t\t\t.group()\n\t\t\t.kill_on_drop(true)\n\t\t\t.spawn()\n\t\t\t.into_diagnostic()?;\n\t\tchild\n\t\t\t.inner()\n\t\t\t.stdin\n\t\t\t.as_mut()\n\t\t\t.unwrap()\n\t\t\t.write_all(&buffer)\n\t\t\t.await\n\t\t\t.into_diagnostic()?;\n\n\t\tif let Some(code) = child\n\t\t\t.wait()\n\t\t\t.await\n\t\t\t.into_diagnostic()?\n\t\t\t.code()\n\t\t\t.and_then(|code| if code == 0 { None } else { Some(code) })\n\t\t{\n\t\t\treturn Err(miette::miette!(\"Exited with status code {}\", code));\n\t\t}\n\t} else {\n\t\tstd::io::stdout()\n\t\t\t.lock()\n\t\t\t.write_all(&buffer)\n\t\t\t.into_diagnostic()?;\n\t}\n\n\tOk(())\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn run_manpage(_args: Args) -> Result<()> {\n\tinfo!(version=%env!(\"CARGO_PKG_VERSION\"), \"constructing manpage\");\n\n\tlet man = Man::new(Args::command().long_version(None));\n\tlet mut buffer: Vec<u8> = Default::default();\n\tman.render(&mut buffer).into_diagnostic()?;\n\n\tif std::io::stdout().is_terminal() && which::which(\"man\").is_ok() {\n\t\tlet mut child = Command::new(\"man\")\n\t\t\t.arg(\"-l\")\n\t\t\t.arg(\"-\")\n\t\t\t.stdin(Stdio::piped())\n\t\t\t.stdout(Stdio::inherit())\n\t\t\t.stderr(Stdio::inherit())\n\t\t\t.group()\n\t\t\t.kill_on_drop(true)\n\t\t\t.spawn()\n\t\t\t.into_diagnostic()?;\n\t\tchild\n\t\t\t.inner()\n\t\t\t.stdin\n\t\t\t.as_mut()\n\t\t\t.unwrap()\n\t\t\t.write_all(&buffer)\n\t\t\t.await\n\t\t\t.into_diagnostic()?;\n\n\t\tif let Some(code) = child\n\t\t\t.wait()\n\t\t\t.await\n\t\t\t.into_diagnostic()?\n\t\t\t.code()\n\t\t\t.and_then(|code| if code == 0 { None } else { Some(code) })\n\t\t{\n\t\t\treturn Err(miette::miette!(\"Exited with status code {}\", code));\n\t\t}\n\t} else {\n\t\tstd::io::stdout()\n\t\t\t.lock()\n\t\t\t.write_all(&buffer)\n\t\t\t.into_diagnostic()?;\n\t}\n\n\tOk(())\n}", "id": 198, "concepts": ["process execution", "asynchronous i/o", "terminal handling", "process output retrieval", "process status handling", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\npub fn get_home() -> Result<String, ()> {\n    match dirs::home_dir() {\n        None => Ok(String::new()),\n        Some(path) => Ok(path.to_str().unwrap().to_string()),\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn get_home() -> Result<String, ()> {\n    match dirs::home_dir() {\n        None => Ok(String::new()),\n        Some(path) => Ok(path.to_str().unwrap().to_string()),\n    }\n}", "id": 199, "concepts": ["return value handling for error cases", "conditional return", "error handling for null values", "string conversion from path"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nfn modules_file(repo: &Repository, at: &Commit) -> Result<String, Box<dyn std::error::Error>> {\n    if let Some(modules) = at.tree()?.get_name(\".gitmodules\") {\n        Ok(String::from_utf8(\n            modules.to_object(&repo)?.peel_to_blob()?.content().into(),\n        )?)\n    } else {\n        return Ok(String::new());\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn modules_file(repo: &Repository, at: &Commit) -> Result<String, Box<dyn std::error::Error>> {\n    if let Some(modules) = at.tree()?.get_name(\".gitmodules\") {\n        Ok(String::from_utf8(\n            modules.to_object(&repo)?.peel_to_blob()?.content().into(),\n        )?)\n    } else {\n        return Ok(String::new());\n    }\n}", "id": 200, "concepts": ["string parsing", "UTF8 parsing", "file content reading", "object deserialization", "branch access"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nfn loadImageFromMaterial(model: &mut Model, materialPath: &str) {\r\n    model.albedo_map = materialPath + \"_albedo.png\";\r\n    model.normal_map = materialPath + \"_normal.png\";\r\n    model.ambient_ligth = materialPath + \"_ao.png\";\r\n    model.roughness_map = materialPath + \"_rough.png\"\r\n}\n\n### Concepts", "fingerprint": null, "seed": "fn loadImageFromMaterial(model: &mut Model, materialPath: &str) {\r\n    model.albedo_map = materialPath + \"_albedo.png\";\r\n    model.normal_map = materialPath + \"_normal.png\";\r\n    model.ambient_ligth = materialPath + \"_ao.png\";\r\n    model.roughness_map = materialPath + \"_rough.png\"\r\n}", "id": 201, "concepts": ["string concatenation", "text parsing", "file loading", "function parameter deconstruction", "function return value reassignment"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nfn mailmap_from_repo(repo: &git2::Repository) -> Result<Mailmap, Box<dyn std::error::Error>> {\n    let file = String::from_utf8(\n        repo.revparse_single(\"master\")?\n            .peel_to_commit()?\n            .tree()?\n            .get_name(\".mailmap\")\n            .unwrap()\n            .to_object(&repo)?\n            .peel_to_blob()?\n            .content()\n            .into(),\n    )?;\n    Mailmap::from_string(file)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn mailmap_from_repo(repo: &git2::Repository) -> Result<Mailmap, Box<dyn std::error::Error>> {\n    let file = String::from_utf8(\n        repo.revparse_single(\"master\")?\n            .peel_to_commit()?\n            .tree()?\n            .get_name(\".mailmap\")\n            .unwrap()\n            .to_object(&repo)?\n            .peel_to_blob()?\n            .content()\n            .into(),\n    )?;\n    Mailmap::from_string(file)\n}", "id": 202, "concepts": ["string parsing", "string manipulation", "creation of an instance of a data structure from an external source", "error handling in Rust"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\npub fn force_reset() -> Result<(), ()> {\n    let mut configurator = Configurator::new();\n    configurator.force_reset();\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn force_reset() -> Result<(), ()> {\n    let mut configurator = Configurator::new();\n    configurator.force_reset();\n    Ok(())\n}", "id": 203, "concepts": ["custom error type", "error handling", "conditional return", "error type conversions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nfn get_versions(repo: &Repository) -> Result<Vec<VersionTag>, Box<dyn std::error::Error>> {\n    let tags = repo\n        .tag_names(None)?\n        .into_iter()\n        .filter_map(|v| v)\n        .map(|v| v.to_owned())\n        .collect::<Vec<_>>();\n    let mut versions = tags\n        .iter()\n        .filter_map(|tag| {\n            Version::parse(&tag)\n                .or_else(|_| Version::parse(&format!(\"{}.0\", tag)))\n                .ok()\n                .map(|v| VersionTag {\n                    name: format!(\"Rust {}\", v),\n                    version: v,\n                    raw_tag: tag.clone(),\n                    commit: repo\n                        .revparse_single(&tag)\n                        .unwrap()\n                        .peel_to_commit()\n                        .unwrap()\n                        .id(),\n                    in_progress: false,\n                })\n        })\n        .collect::<Vec<_>>();\n    versions.sort();\n    Ok(versions)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn get_versions(repo: &Repository) -> Result<Vec<VersionTag>, Box<dyn std::error::Error>> {\n    let tags = repo\n        .tag_names(None)?\n        .into_iter()\n        .filter_map(|v| v)\n        .map(|v| v.to_owned())\n        .collect::<Vec<_>>();\n    let mut versions = tags\n        .iter()\n        .filter_map(|tag| {\n            Version::parse(&tag)\n                .or_else(|_| Version::parse(&format!(\"{}.0\", tag)))\n                .ok()\n                .map(|v| VersionTag {\n                    name: format!(\"Rust {}\", v),\n                    version: v,\n                    raw_tag: tag.clone(),\n                    commit: repo\n                        .revparse_single(&tag)\n                        .unwrap()\n                        .peel_to_commit()\n                        .unwrap()\n                        .id(),\n                    in_progress: false,\n                })\n        })\n        .collect::<Vec<_>>();\n    versions.sort();\n    Ok(versions)\n}", "id": 204, "concepts": ["version string parsing", "text parsing", "conditional logic", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nfn parse_bors_reviewer(\n    reviewers: &Reviewers,\n    repo: &Repository,\n    commit: &Commit,\n) -> Result<Option<Vec<Author>>, ErrorContext> {\n    if commit.author().name_bytes() != b\"bors\" || commit.committer().name_bytes() != b\"bors\" {\n        if commit.committer().name_bytes() != b\"GitHub\" || !is_rollup_commit(commit) {\n            return Ok(None);\n        }\n    }\n\n    // Skip non-merge commits\n    if commit.parents().count() == 1 {\n        return Ok(None);\n    }\n\n    let to_author = |list: &str| -> Result<Vec<Author>, ErrorContext> {\n        list.trim_end_matches('.')\n            .split(|c| c == ',' || c == '+')\n            .map(|r| r.trim_start_matches('@'))\n            .map(|r| r.trim_end_matches('`'))\n            .map(|r| r.trim())\n            .filter(|r| !r.is_empty())\n            .filter(|r| *r != \"<try>\")\n            .inspect(|r| {\n                if !r.chars().all(|c| {\n                    c.is_alphabetic() || c.is_digit(10) || c == '-' || c == '_' || c == '='\n                }) {\n                    eprintln!(\n                        \"warning: to_author for {} contained non-alphabetic characters: {:?}\",\n                        commit.id(),\n                        r\n                    );\n                }\n            })\n            .map(|r| {\n                reviewers.to_author(r).map_err(|e| {\n                    ErrorContext(\n                        format!(\"reviewer: {:?}, commit: {}\", r, commit.id()),\n                        e.into(),\n                    )\n                })\n            })\n            .flat_map(|r| r.transpose())\n            .collect::<Result<Vec<_>, ErrorContext>>()\n    };\n\n    let message = commit.message().unwrap_or(\"\");\n    let mut reviewers = if let Some(line) = message.lines().find(|l| l.contains(\" r=\")) {\n        let start = line.find(\"r=\").unwrap() + 2;\n        let end = line[start..]\n            .find(' ')\n            .map(|pos| pos + start)\n            .unwrap_or(line.len());\n        to_author(&line[start..end])?\n    } else if let Some(line) = message.lines().find(|l| l.starts_with(\"Reviewed-by: \")) {\n        let line = &line[\"Reviewed-by: \".len()..];\n        to_author(&line)?\n    } else {\n        // old bors didn't include r=\n        if message != \"automated merge\\n\" {\n            panic!(\n                \"expected reviewer for bors merge commit {} in {:?}, message: {:?}\",\n                commit.id(),\n                repo.path(),\n                message\n            );\n        }\n        return Ok(None);\n    };\n    reviewers.sort();\n    reviewers.dedup();\n    Ok(Some(reviewers))\n}\n\n### Concepts", "fingerprint": null, "seed": "fn parse_bors_reviewer(\n    reviewers: &Reviewers,\n    repo: &Repository,\n    commit: &Commit,\n) -> Result<Option<Vec<Author>>, ErrorContext> {\n    if commit.author().name_bytes() != b\"bors\" || commit.committer().name_bytes() != b\"bors\" {\n        if commit.committer().name_bytes() != b\"GitHub\" || !is_rollup_commit(commit) {\n            return Ok(None);\n        }\n    }\n\n    // Skip non-merge commits\n    if commit.parents().count() == 1 {\n        return Ok(None);\n    }\n\n    let to_author = |list: &str| -> Result<Vec<Author>, ErrorContext> {\n        list.trim_end_matches('.')\n            .split(|c| c == ',' || c == '+')\n            .map(|r| r.trim_start_matches('@'))\n            .map(|r| r.trim_end_matches('`'))\n            .map(|r| r.trim())\n            .filter(|r| !r.is_empty())\n            .filter(|r| *r != \"<try>\")\n            .inspect(|r| {\n                if !r.chars().all(|c| {\n                    c.is_alphabetic() || c.is_digit(10) || c == '-' || c == '_' || c == '='\n                }) {\n                    eprintln!(\n                        \"warning: to_author for {} contained non-alphabetic characters: {:?}\",\n                        commit.id(),\n                        r\n                    );\n                }\n            })\n            .map(|r| {\n                reviewers.to_author(r).map_err(|e| {\n                    ErrorContext(\n                        format!(\"reviewer: {:?}, commit: {}\", r, commit.id()),\n                        e.into(),\n                    )\n                })\n            })\n            .flat_map(|r| r.transpose())\n            .collect::<Result<Vec<_>, ErrorContext>>()\n    };\n\n    let message = commit.message().unwrap_or(\"\");\n    let mut reviewers = if let Some(line) = message.lines().find(|l| l.contains(\" r=\")) {\n        let start = line.find(\"r=\").unwrap() + 2;\n        let end = line[start..]\n            .find(' ')\n            .map(|pos| pos + start)\n            .unwrap_or(line.len());\n        to_author(&line[start..end])?\n    } else if let Some(line) = message.lines().find(|l| l.starts_with(\"Reviewed-by: \")) {\n        let line = &line[\"Reviewed-by: \".len()..];\n        to_author(&line)?\n    } else {\n        // old bors didn't include r=\n        if message != \"automated merge\\n\" {\n            panic!(\n                \"expected reviewer for bors merge commit {} in {:?}, message: {:?}\",\n                commit.id(),\n                repo.path(),\n                message\n            );\n        }\n        return Ok(None);\n    };\n    reviewers.sort();\n    reviewers.dedup();\n    Ok(Some(reviewers))\n}", "id": 205, "concepts": ["conditional parsing logic", "string slicing and traversal", "string parsing", "array slicing and traversal", "string comparison", "string matching", "string manipulation", "array slicing and traversal", "string sorting", "array deduplication"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 6\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn build_one() {\n    let project = project(\"build_one\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_b\")\n        .assert()\n        .success();\n\n    // Build to ensure that the build directory is created and\n    // `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n    let a_bin = build_dir.join(\"build_one_a\");\n    let b_bin = build_dir.join(\"build_one_b\");\n\n    // Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    // Test that we can build one and not the other.\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n\n    assert!(a_bin.is_file());\n    assert!(!b_bin.is_file());\n}\n\n### Concepts", "fingerprint": null, "seed": "fn build_one() {\n    let project = project(\"build_one\").with_fuzz().build();\n\n    // Create some targets.\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"build_one_b\")\n        .assert()\n        .success();\n\n    // Build to ensure that the build directory is created and\n    // `fuzz_build_dir()` won't panic.\n    project.cargo_fuzz().arg(\"build\").assert().success();\n\n    let build_dir = project.fuzz_build_dir().join(\"release\");\n    let a_bin = build_dir.join(\"build_one_a\");\n    let b_bin = build_dir.join(\"build_one_b\");\n\n    // Remove the files we just built.\n    fs::remove_file(&a_bin).unwrap();\n    fs::remove_file(&b_bin).unwrap();\n\n    assert!(!a_bin.is_file());\n    assert!(!b_bin.is_file());\n\n    // Test that we can build one and not the other.\n    project\n        .cargo_fuzz()\n        .arg(\"build\")\n        .arg(\"build_one_a\")\n        .assert()\n        .success();\n\n    assert!(a_bin.is_file());\n    assert!(!b_bin.is_file());\n}", "id": 206, "concepts": ["file system operations", "file creation", "file deletion", "file path manipulation", "conditional file existence check"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\nfn docker_metric_entry_from_two_stats(time_diff: Duration, first: InstantDockerContainerMetricEntry, second: InstantDockerContainerMetricEntry) -> DockerContainerMetricEntry {\n    let diff = time_diff.num_milliseconds() as f64 / 1000.0; // seconds\n\n    DockerContainerMetricEntry {\n        name: second.name,\n        state: second.state,\n\n        cpu_usage: ((second.cpu_usage - first.cpu_usage) as f64 / (second.system_cpu_usage - first.system_cpu_usage) as f64) / diff,\n\n        memory_usage: second.memory_usage,\n        memory_cache: second.memory_cache,\n\n        network_tx: (second.network_tx - first.network_tx) as f64 / diff,\n        network_rx: (second.network_rx - first.network_rx) as f64 / diff\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn docker_metric_entry_from_two_stats(time_diff: Duration, first: InstantDockerContainerMetricEntry, second: InstantDockerContainerMetricEntry) -> DockerContainerMetricEntry {\n    let diff = time_diff.num_milliseconds() as f64 / 1000.0; // seconds\n\n    DockerContainerMetricEntry {\n        name: second.name,\n        state: second.state,\n\n        cpu_usage: ((second.cpu_usage - first.cpu_usage) as f64 / (second.system_cpu_usage - first.system_cpu_usage) as f64) / diff,\n\n        memory_usage: second.memory_usage,\n        memory_cache: second.memory_cache,\n\n        network_tx: (second.network_tx - first.network_tx) as f64 / diff,\n        network_rx: (second.network_rx - first.network_rx) as f64 / diff\n    }\n}", "id": 207, "concepts": ["time-based calculation", "floating-point arithmetic", "conditional branching", "conditional variable usage"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nfn\ntest_empty_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nempty\n=\nvec\n!\n[\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nempty\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nempty\n)\n;\nOk\n(\n(\n)\n)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn\ntest_empty_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nempty\n=\nvec\n!\n[\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nempty\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nempty\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 209, "concepts": ["database connection", "database query", "empty vector initialization", "assertion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\npub fn acrn_is_file(path: &str) -> bool {\n    fs::metadata(path)\n        .map(|metadata| metadata.is_file())\n        .unwrap_or(false)\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn acrn_is_file(path: &str) -> bool {\n    fs::metadata(path)\n        .map(|metadata| metadata.is_file())\n        .unwrap_or(false)\n}", "id": 210, "concepts": ["checking file existence", "file metadata access", "file conversion to boolean"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nfn map_params(tok: IRCToken) -> Result<IRCToken, ~str> {\n    // Sequence(~[Sequence(~[Sequence(~[Ignored, Unparsed(~\"##codelab\")])]), Sequence(~[Sequence(~[Ignored, Unparsed(~\":\"), Unparsed(~\"hi\")])])])\n    match tok {\n        Sequence(args) => Ok(Params(args.map(|arg| {\n            match arg.clone() {\n                Sequence([Sequence([Ignored, Unparsed(param)])]) => param,\n                Sequence([Sequence([Ignored, Unparsed(~\":\"), Unparsed(param)])]) => param,\n                _ => ~\"\"\n            }\n        }))),\n        _ => Err(~\"Malformed parameters\")\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn map_params(tok: IRCToken) -> Result<IRCToken, ~str> {\n    // Sequence(~[Sequence(~[Sequence(~[Ignored, Unparsed(~\"##codelab\")])]), Sequence(~[Sequence(~[Ignored, Unparsed(~\":\"), Unparsed(~\"hi\")])])])\n    match tok {\n        Sequence(args) => Ok(Params(args.map(|arg| {\n            match arg.clone() {\n                Sequence([Sequence([Ignored, Unparsed(param)])]) => param,\n                Sequence([Sequence([Ignored, Unparsed(~\":\"), Unparsed(param)])]) => param,\n                _ => ~\"\"\n            }\n        }))),\n        _ => Err(~\"Malformed parameters\")\n    }\n}", "id": 211, "concepts": ["pattern matching", "error handling", "functional programming in Rust", "trait implementation for Result types"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nfn get_disjoint<T>(ts: &mut [T], a: usize, b: usize) -> (&mut T, &mut T) {\n    assert!(a != b, \"a ({}) and b ({}) must be disjoint\", a, b);\n    assert!(a < ts.len(), \"a ({}) is out of bounds\", a);\n    assert!(b < ts.len(), \"b ({}) is out of bounds\", b);\n    if a < b {\n        let (al, bl) = ts.split_at_mut(b);\n        (&mut al[a], &mut bl[0])\n    } else {\n        let (bl, al) = ts.split_at_mut(a);\n        (&mut al[0], &mut bl[b])\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn get_disjoint<T>(ts: &mut [T], a: usize, b: usize) -> (&mut T, &mut T) {\n    assert!(a != b, \"a ({}) and b ({}) must be disjoint\", a, b);\n    assert!(a < ts.len(), \"a ({}) is out of bounds\", a);\n    assert!(b < ts.len(), \"b ({}) is out of bounds\", b);\n    if a < b {\n        let (al, bl) = ts.split_at_mut(b);\n        (&mut al[a], &mut bl[0])\n    } else {\n        let (bl, al) = ts.split_at_mut(a);\n        (&mut al[0], &mut bl[b])\n    }\n}", "id": 212, "concepts": ["mutating a slice", "default parameter initialization in functions", "input validation for parameter types"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 8\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\npub fn ap(f: Value, arg: Value) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::Apply(f, arg),\n        computed: false,\n    }))\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn ap(f: Value, arg: Value) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::Apply(f, arg),\n        computed: false,\n    }))\n}", "id": 213, "concepts": ["function application in functional programming", "functional programming in Rust", "trait implementation for function application"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\npub fn task_set_instruction_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetInstructionPointer {\n        request: (target, ptr),\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn task_set_instruction_pointer(target: CAddr, ptr: u64) {\n    system_call(SystemCall::TaskSetInstructionPointer {\n        request: (target, ptr),\n    });\n}", "id": 214, "concepts": ["system call function", "system call Rust module"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\npub fn channel_put<T: Any + Clone>(target: CAddr, value: T) {\n    system_call_put_payload(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Payload)\n    }, value);\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn channel_put<T: Any + Clone>(target: CAddr, value: T) {\n    system_call_put_payload(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Payload)\n    }, value);\n}", "id": 216, "concepts": ["thread communication", "synchronization primitives", "Rust ownership model", "ownership of shared state\n/Text_Programming_Concepts/README.md\n# Text Programming Concepts Exercises\n\nThis repository contains exercise solutions for:\n\n- [Text Programming Concepts](https://github.com/denniskuenzi/Text_Programming_Concepts)\n\n## Solutions\n\n#"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\npub fn channel_take<T: Any + Clone>(target: CAddr) -> T {\n    let (result, payload) = system_call_take_payload(SystemCall::ChannelTake {\n        request: target,\n        response: None\n    });\n    match result {\n        SystemCall::ChannelTake {\n            request: _,\n            response: Some(ChannelMessage::Payload),\n        } => {\n            return payload;\n        },\n        _ => panic!(),\n    };\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn channel_take<T: Any + Clone>(target: CAddr) -> T {\n    let (result, payload) = system_call_take_payload(SystemCall::ChannelTake {\n        request: target,\n        response: None\n    });\n    match result {\n        SystemCall::ChannelTake {\n            request: _,\n            response: Some(ChannelMessage::Payload),\n        } => {\n            return payload;\n        },\n        _ => panic!(),\n    };\n}", "id": 218, "concepts": ["channel take", "pattern matching", "Rust match statement", "payload extraction from system call response"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn parse_file(file_name: &str) -> Vec<Instruction> {\n    let f = File::open(file_name).expect(\"Could not open the specified file.\");\n    let reader = BufReader::new(f);\n    \n    reader\n        .lines()\n        .map(|lr| lr.expect(\"Could not read a line.\"))\n        .map(|l| parse_instruction(&l))\n        .collect()\n}\n\n### Concepts", "fingerprint": null, "seed": "fn parse_file(file_name: &str) -> Vec<Instruction> {\n    let f = File::open(file_name).expect(\"Could not open the specified file.\");\n    let reader = BufReader::new(f);\n    \n    reader\n        .lines()\n        .map(|lr| lr.expect(\"Could not read a line.\"))\n        .map(|l| parse_instruction(&l))\n        .collect()\n}", "id": 222, "concepts": ["file reading", "line iteration", "Rust match statement", "input validation with assertions\n/Text_Programming_Concepts/README.md\n# Text Programming Concepts Exercises\n\nThis repository contains exercise solutions for:\n\n- [Text Programming Concepts](https://github.com/denniskuenzi/Text_Programming_Concepts)\n\n## Solutions\n\n#"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\npub fn b(b: BuiltIn) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::BuiltIn(b),\n        computed: true,\n    }))\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn b(b: BuiltIn) -> Value {\n    Rc::new(RefCell::new(V {\n        val: Value_::BuiltIn(b),\n        computed: true,\n    }))\n}", "id": 223, "concepts": ["Rust's boxing", "Rc", "RefCell", "Value", "Value_ enum", "BTreeMap", "mutex", "environment variable access", "conditional compilation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nconst fn null_ble_gatt_svc_def() -> ble_gatt_svc_def {\n    return ble_gatt_svc_def {\n        type_: BLE_GATT_SVC_TYPE_END as u8,\n        uuid: ptr::null(),\n        includes: ptr::null_mut(),\n        characteristics: ptr::null(),\n    };\n}\n\n### Concepts", "fingerprint": null, "seed": "const fn null_ble_gatt_svc_def() -> ble_gatt_svc_def {\n    return ble_gatt_svc_def {\n        type_: BLE_GATT_SVC_TYPE_END as u8,\n        uuid: ptr::null(),\n        includes: ptr::null_mut(),\n        characteristics: ptr::null(),\n    };\n}", "id": 224, "concepts": ["Rust's const function", "ptr::null", "ptr::null_mut", "no-op"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\nfn\nchecked_memory_handle\n(\n)\n-\n>\nResult\n<\nConnection\n>\n{\nlet\ndb\n=\nConnection\n:\n:\nopen_in_memory\n(\n)\n?\n;\ndb\n.\nexecute_batch\n(\n\"\nCREATE\nTABLE\nfoo\n(\nb\nBLOB\nt\nTEXT\ni\nINTEGER\nf\nFLOAT\nn\n)\n\"\n)\n?\n;\nOk\n(\ndb\n)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn\nchecked_memory_handle\n(\n)\n-\n>\nResult\n<\nConnection\n>\n{\nlet\ndb\n=\nConnection\n:\n:\nopen_in_memory\n(\n)\n?\n;\ndb\n.\nexecute_batch\n(\n\"\nCREATE\nTABLE\nfoo\n(\nb\nBLOB\nt\nTEXT\ni\nINTEGER\nf\nFLOAT\nn\n)\n\"\n)\n?\n;\nOk\n(\ndb\n)\n}", "id": 225, "concepts": ["Rust's boxing", "error handling", "two-phase construction", "SQLite transactions", "SQLite database management"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\npub fn open_devtools(window: Window) {\n    window.open_devtools()\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn open_devtools(window: Window) {\n    window.open_devtools()\n}", "id": 226, "concepts": ["using the Window API", "opening a window's devtools"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\npub fn print(buffer: [u8; 32], size: usize) {\n    let _ = system_call(SystemCall::Print {\n        request: (buffer, size)\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn print(buffer: [u8; 32], size: usize) {\n    let _ = system_call(SystemCall::Print {\n        request: (buffer, size)\n    });\n}", "id": 227, "concepts": ["Rust-specific system call", "print function", "byte array manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nfn run_with_different_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\n        \"project_likes_to_move_it\",\n        Some(\"dir_likes_to_move_it_move_it\"),\n    );\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"you_like_to_move_it\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|_data: &[u8]| {\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"you_like_to_move_it\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 2 runs\"))\n        .success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn run_with_different_fuzz_dir() {\n    let (fuzz_dir, mut project_builder) = project_with_fuzz_dir(\n        \"project_likes_to_move_it\",\n        Some(\"dir_likes_to_move_it_move_it\"),\n    );\n    let project = project_builder\n        .with_fuzz()\n        .fuzz_target(\n            \"you_like_to_move_it\",\n            r#\"\n                #![no_main]\n                use libfuzzer_sys::fuzz_target;\n\n                fuzz_target!(|_data: &[u8]| {\n                });\n            \"#,\n        )\n        .build();\n\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"--fuzz-dir\")\n        .arg(fuzz_dir)\n        .arg(\"you_like_to_move_it\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .stderr(predicate::str::contains(\"Done 2 runs\"))\n        .success();\n}", "id": 228, "concepts": ["fuzz tests", "fuzzing directory creation", "fuzzing build", "fuzzing run"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 9\n### Snippet\nfn main() {\n    println!(\"Run via `cargo run-wasm --example visualiser_for_wasm`\");\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    println!(\"Run via `cargo run-wasm --example visualiser_for_wasm`\");\n}", "id": 229, "concepts": ["Rust-WebAssembly integration", "custom `Cargo` build script", "binary file inclusion in `Cargo.toml`"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nfn update_repo(url: &str) -> Result<PathBuf, Box<dyn std::error::Error>> {\n    let mut slug = url;\n    let prefix = \"https://github.com/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let prefix = \"git://github.com/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let prefix = \"https://git.chromium.org/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let suffix = \".git\";\n    if slug.ends_with(suffix) {\n        slug = &slug[..slug.len() - suffix.len()];\n    }\n\n    let path_s = format!(\"repos/{}\", slug);\n    let path = PathBuf::from(&path_s);\n    if !UPDATED.lock().unwrap().insert(slug.to_string()) {\n        return Ok(path);\n    }\n    if path.exists() {\n        if should_update() {\n            // we know for sure the path_s does *not* contain .git as we strip it, so this is a safe\n            // temp directory\n            let tmp = format!(\"{}.git\", path_s);\n            std::fs::rename(&path, &tmp)?;\n            git(&[\n                \"clone\",\n                \"--bare\",\n                \"--dissociate\",\n                \"--reference\",\n                &tmp,\n                &url,\n                &path_s,\n            ])?;\n            std::fs::remove_dir_all(&tmp)?;\n        }\n    } else {\n        git(&[\"clone\", \"--bare\", &url, &path_s])?;\n    }\n    Ok(path)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn update_repo(url: &str) -> Result<PathBuf, Box<dyn std::error::Error>> {\n    let mut slug = url;\n    let prefix = \"https://github.com/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let prefix = \"git://github.com/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let prefix = \"https://git.chromium.org/\";\n    if slug.starts_with(prefix) {\n        slug = &slug[prefix.len()..];\n    }\n    let suffix = \".git\";\n    if slug.ends_with(suffix) {\n        slug = &slug[..slug.len() - suffix.len()];\n    }\n\n    let path_s = format!(\"repos/{}\", slug);\n    let path = PathBuf::from(&path_s);\n    if !UPDATED.lock().unwrap().insert(slug.to_string()) {\n        return Ok(path);\n    }\n    if path.exists() {\n        if should_update() {\n            // we know for sure the path_s does *not* contain .git as we strip it, so this is a safe\n            // temp directory\n            let tmp = format!(\"{}.git\", path_s);\n            std::fs::rename(&path, &tmp)?;\n            git(&[\n                \"clone\",\n                \"--bare\",\n                \"--dissociate\",\n                \"--reference\",\n                &tmp,\n                &url,\n                &path_s,\n            ])?;\n            std::fs::remove_dir_all(&tmp)?;\n        }\n    } else {\n        git(&[\"clone\", \"--bare\", &url, &path_s])?;\n    }\n    Ok(path)\n}", "id": 231, "concepts": ["OS-level file system operations", "Git repository operations", "locking and mutability of variables", "string manipulation", "IO operations", "refactor", "conditional mutation of values"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\npub fn init(\n    src: String,\n    dst: String,\n    width: u32,\n) -> std::io::Result<()> {\n    let mut logger = env_logger::Builder::new();\n    logger.init();\n\n    let mut window = Window::new((width, 200)).unwrap();\n    let mut popup = Popup::new(width, window.hidpi);\n    let mut renderer = popup.get_renderer(&mut window.handle);\n    window.run(&mut popup, &mut renderer);\n\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn init(\n    src: String,\n    dst: String,\n    width: u32,\n) -> std::io::Result<()> {\n    let mut logger = env_logger::Builder::new();\n    logger.init();\n\n    let mut window = Window::new((width, 200)).unwrap();\n    let mut popup = Popup::new(width, window.hidpi);\n    let mut renderer = popup.get_renderer(&mut window.handle);\n    window.run(&mut popup, &mut renderer);\n\n    Ok(())\n}", "id": 232, "concepts": ["async function execution", "window creation", "renderer creation", "window and renderer execution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\npub fn test_outofcycles_in_syscall() {\n    let buffer = fs::read(\"tests/programs/syscall64\").unwrap().into();\n    let core_machine = DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, 20);\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .instruction_cycle_func(Box::new(constant_cycles))\n        .syscall(Box::new(OutOfCyclesSyscall {}))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"syscall\".into()])\n        .unwrap();\n    let result = machine.run();\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), Error::CyclesExceeded);\n    assert_eq!(machine.cycles(), 108);\n    assert_eq!(machine.registers()[A0], 39);\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_outofcycles_in_syscall() {\n    let buffer = fs::read(\"tests/programs/syscall64\").unwrap().into();\n    let core_machine = DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, 20);\n    let mut machine = DefaultMachineBuilder::new(core_machine)\n        .instruction_cycle_func(Box::new(constant_cycles))\n        .syscall(Box::new(OutOfCyclesSyscall {}))\n        .build();\n    machine\n        .load_program(&buffer, &vec![\"syscall\".into()])\n        .unwrap();\n    let result = machine.run();\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), Error::CyclesExceeded);\n    assert_eq!(machine.cycles(), 108);\n    assert_eq!(machine.registers()[A0], 39);\n}", "id": 233, "concepts": ["async/await feature", "runtime system", "monolithic Turing machine", "system calls", "program execution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\npub fn acrn_remove_dir(path: &str) -> Result<(), String> {\n    fs::remove_dir_all(path).map_err(|e| e.to_string())\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn acrn_remove_dir(path: &str) -> Result<(), String> {\n    fs::remove_dir_all(path).map_err(|e| e.to_string())\n}", "id": 234, "concepts": ["async function call", "file system read/write/delete", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\nfn add_twice() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"could not add target\")\n                .and(predicate::str::contains(\"File exists (os error 17)\")),\n        )\n        .failure();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn add_twice() {\n    let project = project(\"add\").with_fuzz().build();\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .success();\n    assert!(project.fuzz_target_path(\"new_fuzz_target\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"add\")\n        .arg(\"new_fuzz_target\")\n        .assert()\n        .stderr(\n            predicate::str::contains(\"could not add target\")\n                .and(predicate::str::contains(\"File exists (os error 17)\")),\n        )\n        .failure();\n}", "id": 235, "concepts": ["conditional branching", "file existence checking", "string manipulation", "project management"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nasync fn init() -> Nash {\n    dotenv().ok();\n\n    let parameters = NashParameters {\n        credentials: Some(NashCredentials {\n            secret: env::var(\"NASH_API_SECRET\").unwrap(),\n            session: env::var(\"NASH_API_KEY\").unwrap(),\n        }),\n        environment: Environment::Sandbox,\n        client_id: 1,\n        timeout: 1000,\n    };\n\n    OpenLimits::instantiate(parameters).await\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn init() -> Nash {\n    dotenv().ok();\n\n    let parameters = NashParameters {\n        credentials: Some(NashCredentials {\n            secret: env::var(\"NASH_API_SECRET\").unwrap(),\n            session: env::var(\"NASH_API_KEY\").unwrap(),\n        }),\n        environment: Environment::Sandbox,\n        client_id: 1,\n        timeout: 1000,\n    };\n\n    OpenLimits::instantiate(parameters).await\n}", "id": 237, "concepts": ["async function execution", "async runtime", "async monad", "traits and associated functions", "async trait", "async function call"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nasync fn get_historic_trades() {\n    let exchange = init().await;\n    let req = GetHistoricTradesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        paginator: Some(Paginator {\n            limit: Some(100),\n            ..Default::default()\n        }),\n    };\n    let resp = exchange.get_historic_trades(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn get_historic_trades() {\n    let exchange = init().await;\n    let req = GetHistoricTradesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        paginator: Some(Paginator {\n            limit: Some(100),\n            ..Default::default()\n        }),\n    };\n    let resp = exchange.get_historic_trades(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 238, "concepts": ["async/await syntax", "futures", "async monad", "traits"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nfn align_to(size: uint, align: uint) -> uint {\n\t    assert!(align != 0);\n\t\t    (size + align - 1) & !(align - 1)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn align_to(size: uint, align: uint) -> uint {\n\t    assert!(align != 0);\n\t\t    (size + align - 1) & !(align - 1)\n}", "id": 239, "concepts": ["bitwise arithmetic operations", "binary arithmetic", "monadic composition", "asserts"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 2\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 4\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 5\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\npub fn acrn_read(file_path: &str) -> Result<String, String> {\n    let mut file = File::open(file_path).map_err(|e| e.to_string())?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)\n        .map_err(|e| e.to_string())?;\n    Ok(contents)\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn acrn_read(file_path: &str) -> Result<String, String> {\n    let mut file = File::open(file_path).map_err(|e| e.to_string())?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)\n        .map_err(|e| e.to_string())?;\n    Ok(contents)\n}", "id": 240, "concepts": ["file I/O", "error handling", "string parsing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nfn tuple_test() {\n    let text = \"I see the eigenvalue in thine eye\";\n    let (head, tail) = text.split_at(21);\n    assert_eq!(head, \"I see the eigenvalue \");\n    assert_eq!(tail, \"in thine eye\");\n}\n\n### Concepts", "fingerprint": null, "seed": "fn tuple_test() {\n    let text = \"I see the eigenvalue in thine eye\";\n    let (head, tail) = text.split_at(21);\n    assert_eq!(head, \"I see the eigenvalue \");\n    assert_eq!(tail, \"in thine eye\");\n}", "id": 242, "concepts": ["tuple unpacking", "string splitting", "string indexing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 7\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\npub async fn dump_wifi_passwords() -> Option<WifiLogins> {\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    let mut wifi_logins = WifiLogins::new();\n\n    let list_of_process = String::from_utf8_lossy(&output.stdout);\n    for line in list_of_process.lines() {\n        if line\n            .to_lowercase()\n            .contains(obfstr::obfstr!(\"all user profile\"))\n            && line.contains(\":\")\n        {\n            let ssid = line.split(':').nth(1)?.trim();\n            let profile = get_wifi_profile(ssid).await?;\n            for pline in profile.lines() {\n                if pline\n                    .to_lowercase()\n                    .contains(obfstr::obfstr!(\"key content\"))\n                    && pline.contains(\":\")\n                {\n                    let key = pline.split(\": \").nth(1)?;\n                    wifi_logins.insert(ssid.to_string(), key.to_string());\n                }\n            }\n        }\n    }\n\n    Some(wifi_logins)\n}\n\n### Concepts", "fingerprint": null, "seed": "pub async fn dump_wifi_passwords() -> Option<WifiLogins> {\n    let output = Command::new(obfstr::obfstr!(\"netsh.exe\"))\n        .args(&[\n            obfstr::obfstr!(\"wlan\"),\n            obfstr::obfstr!(\"show\"),\n            obfstr::obfstr!(\"profile\"),\n        ])\n        .creation_flags(CREATE_NO_WINDOW)\n        .output()\n        .ok()?;\n\n    let mut wifi_logins = WifiLogins::new();\n\n    let list_of_process = String::from_utf8_lossy(&output.stdout);\n    for line in list_of_process.lines() {\n        if line\n            .to_lowercase()\n            .contains(obfstr::obfstr!(\"all user profile\"))\n            && line.contains(\":\")\n        {\n            let ssid = line.split(':').nth(1)?.trim();\n            let profile = get_wifi_profile(ssid).await?;\n            for pline in profile.lines() {\n                if pline\n                    .to_lowercase()\n                    .contains(obfstr::obfstr!(\"key content\"))\n                    && pline.contains(\":\")\n                {\n                    let key = pline.split(\": \").nth(1)?;\n                    wifi_logins.insert(ssid.to_string(), key.to_string());\n                }\n            }\n        }\n    }\n\n    Some(wifi_logins)\n}", "id": 243, "concepts": ["system call and stdin/stdout process communication", "parsing command output", "string manipulation", "option handling", "list comprehension"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\npub fn channel_put_raw(target: CAddr, value: u64) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Raw(value))\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn channel_put_raw(target: CAddr, value: u64) {\n    system_call(SystemCall::ChannelPut {\n        request: (target, ChannelMessage::Raw(value))\n    });\n}", "id": 244, "concepts": ["system call", "function signature", "process communication"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nfn system_call_take_payload<T: Any + Clone>(message: SystemCall) -> (SystemCall, T) {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        system_call_raw();\n\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &*payload_addr;\n        assert!(buffer.payload_length != 0 && buffer.payload_length == size_of::<T>());\n\n        (buffer.call.take().unwrap(), payload_data.clone())\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn system_call_take_payload<T: Any + Clone>(message: SystemCall) -> (SystemCall, T) {\n    use core::mem::{size_of};\n    let addr = task_buffer_addr();\n\n    unsafe {\n        let buffer = &mut *(addr as *mut TaskBuffer);\n        buffer.call = Some(message);\n\n        system_call_raw();\n\n        let payload_addr = &mut buffer.payload_data as *mut _ as *mut T;\n        let payload_data = &*payload_addr;\n        assert!(buffer.payload_length != 0 && buffer.payload_length == size_of::<T>());\n\n        (buffer.call.take().unwrap(), payload_data.clone())\n    }\n}", "id": 245, "concepts": ["system call implementation", "dynamic memory allocation", "mutable and non-mutable references"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nfn append_text_column(tree: &mut gtk::TreeView) {\n    let column = gtk::TreeViewColumn::new().unwrap();\n    let cell = gtk::CellRendererText::new().unwrap();\n\n    column.pack_start(&cell, true);\n    column.add_attribute(&cell, \"text\", 0);\n    tree.append_column(&column);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn append_text_column(tree: &mut gtk::TreeView) {\n    let column = gtk::TreeViewColumn::new().unwrap();\n    let cell = gtk::CellRendererText::new().unwrap();\n\n    column.pack_start(&cell, true);\n    column.add_attribute(&cell, \"text\", 0);\n    tree.append_column(&column);\n}", "id": 246, "concepts": ["creating a new column in the tree view", "accessing its attributes", "adding cells to the column", "adding the column to the tree view"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 8\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\nunsafe fn system_call_raw() {\n    asm!(\"int 80h\"\n         ::\n         : \"rax\", \"rbx\", \"rcx\", \"rdx\",\n         \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n         : \"volatile\", \"intel\");\n}\n\n### Concepts", "fingerprint": null, "seed": "unsafe fn system_call_raw() {\n    asm!(\"int 80h\"\n         ::\n         : \"rax\", \"rbx\", \"rcx\", \"rdx\",\n         \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n         : \"volatile\", \"intel\");\n}", "id": 247, "concepts": ["system call and assembly"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\npub fn parse(raw: &str) -> Option<game::Game> {\n    let game_raw: GameRaw = serde_json::from_str(raw).ok()?;\n\n    let even_initial_timelines = game_raw\n        .timelines\n        .iter()\n        .any(|tl| tl.index == -0.5 || tl.index == 0.5);\n\n    let min_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .min_by_key(|x| (*x) as isize)?;\n    let max_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .max_by_key(|x| (*x) as isize)?;\n\n    let timeline_width = ((-min_timeline).min(max_timeline) + 1.0).round();\n    let active_timelines = game_raw.timelines\n        .iter()\n        .filter(|tl| tl.index.abs() <= timeline_width);\n    let present = active_timelines\n        .map(|tl| tl.begins_at + (tl.states.len() as isize) - 1)\n        .min()?;\n\n    let mut res = game::Game::new(game_raw.width, game_raw.height);\n\n    res.info.present = present;\n    res.info.min_timeline = de_l(min_timeline, even_initial_timelines);\n    res.info.max_timeline = de_l(max_timeline, even_initial_timelines);\n    res.info.active_player = game_raw.active_player;\n    res.info.even_initial_timelines = even_initial_timelines;\n\n    for tl in game_raw.timelines.into_iter() {\n        res.timelines.insert(\n            de_l(tl.index, even_initial_timelines),\n            de_timeline(tl, even_initial_timelines),\n        );\n    }\n\n    Some(res)\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn parse(raw: &str) -> Option<game::Game> {\n    let game_raw: GameRaw = serde_json::from_str(raw).ok()?;\n\n    let even_initial_timelines = game_raw\n        .timelines\n        .iter()\n        .any(|tl| tl.index == -0.5 || tl.index == 0.5);\n\n    let min_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .min_by_key(|x| (*x) as isize)?;\n    let max_timeline = game_raw.timelines\n        .iter()\n        .map(|tl| tl.index)\n        .max_by_key(|x| (*x) as isize)?;\n\n    let timeline_width = ((-min_timeline).min(max_timeline) + 1.0).round();\n    let active_timelines = game_raw.timelines\n        .iter()\n        .filter(|tl| tl.index.abs() <= timeline_width);\n    let present = active_timelines\n        .map(|tl| tl.begins_at + (tl.states.len() as isize) - 1)\n        .min()?;\n\n    let mut res = game::Game::new(game_raw.width, game_raw.height);\n\n    res.info.present = present;\n    res.info.min_timeline = de_l(min_timeline, even_initial_timelines);\n    res.info.max_timeline = de_l(max_timeline, even_initial_timelines);\n    res.info.active_player = game_raw.active_player;\n    res.info.even_initial_timelines = even_initial_timelines;\n\n    for tl in game_raw.timelines.into_iter() {\n        res.timelines.insert(\n            de_l(tl.index, even_initial_timelines),\n            de_timeline(tl, even_initial_timelines),\n        );\n    }\n\n    Some(res)\n}", "id": 248, "concepts": ["struct initialization and field initialization", "iterator usage in loops", "conditional branches based on types", "field access", "order of operations"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 6\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nasync fn get_historic_rates() {\n    let exchange = init().await;\n    let req = GetHistoricRatesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        interval: Interval::OneHour,\n        paginator: None,\n    };\n    let resp = exchange.get_historic_rates(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn get_historic_rates() {\n    let exchange = init().await;\n    let req = GetHistoricRatesRequest {\n        market_pair: \"eth_btc\".to_string(),\n        interval: Interval::OneHour,\n        paginator: None,\n    };\n    let resp = exchange.get_historic_rates(&req).await.unwrap();\n    println!(\"{:?}\", resp);\n}", "id": 249, "concepts": ["async/await syntax", "error handling", "I/O with futures"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 3\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nfn handle_task(client: &mut Client, main_out_c: Sender<String>) {\n    let (channel_out, channel_in) = unbounded();\n    let task_types = TaskCommandTypes::new();\n\n    // walk over the task queue. For any task_queue.state == 0, handle it.\n    for task in &mut client.task_queue {\n        // all tasks will have at least 1 iteration, but may have more. We also may have a sleep\n        // between iterations\n        let duration = (task.iteration_delay * 1000) as u64;\n        let sleep_duration = time::Duration::from_millis(duration);\n        for _iteration in 0..task.iterations {\n            let task_type = task_types.determine_task_type(task.command_type);\n            if task_type == \"filesystem\" {\n                // start the filesystem thread and go go go\n                let out_c = channel_out.clone();\n                filesystem::handle_filesystem(task, out_c);\n                task.state = 1;\n            }\n            // peek into the channel from our thread to see if there is data\n            // if there is, send it back\n            if let Ok(resp_from_thread) = channel_in.try_recv() {\n                println!(\"handle_task got something: {}\", &resp_from_thread);\n                // should send the task ID back out if successful. Otherwise, an err string\n                main_out_c.send(resp_from_thread).unwrap();\n                task.state = 2;\n            }\n            thread::sleep(sleep_duration);\n        }\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn handle_task(client: &mut Client, main_out_c: Sender<String>) {\n    let (channel_out, channel_in) = unbounded();\n    let task_types = TaskCommandTypes::new();\n\n    // walk over the task queue. For any task_queue.state == 0, handle it.\n    for task in &mut client.task_queue {\n        // all tasks will have at least 1 iteration, but may have more. We also may have a sleep\n        // between iterations\n        let duration = (task.iteration_delay * 1000) as u64;\n        let sleep_duration = time::Duration::from_millis(duration);\n        for _iteration in 0..task.iterations {\n            let task_type = task_types.determine_task_type(task.command_type);\n            if task_type == \"filesystem\" {\n                // start the filesystem thread and go go go\n                let out_c = channel_out.clone();\n                filesystem::handle_filesystem(task, out_c);\n                task.state = 1;\n            }\n            // peek into the channel from our thread to see if there is data\n            // if there is, send it back\n            if let Ok(resp_from_thread) = channel_in.try_recv() {\n                println!(\"handle_task got something: {}\", &resp_from_thread);\n                // should send the task ID back out if successful. Otherwise, an err string\n                main_out_c.send(resp_from_thread).unwrap();\n                task.state = 2;\n            }\n            thread::sleep(sleep_duration);\n        }\n    }\n}", "id": 250, "concepts": ["channel communication", "thread sleep", "shared-memory concurrency", "channel buffering"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nfn serializer(msg: String) -> Result<Task, Error> {\n    let v = match serde_json::from_str::<Task>(&msg){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn serializer(msg: String) -> Result<Task, Error> {\n    let v = match serde_json::from_str::<Task>(&msg){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}", "id": 251, "concepts": ["error handling", "serialization and deserialization", "error handling with error messages"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\nfn project_with_fuzz_dir(\n    project_name: &str,\n    fuzz_dir_opt: Option<&str>,\n) -> (String, ProjectBuilder) {\n    let fuzz_dir = fuzz_dir_opt.unwrap_or(\"custom_dir\");\n    let next_root = next_root();\n    let fuzz_dir_pb = next_root.join(fuzz_dir);\n    let fuzz_dir_sting = fuzz_dir_pb.display().to_string();\n    let pb = project_with_params(project_name, next_root, fuzz_dir_pb);\n    (fuzz_dir_sting, pb)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn project_with_fuzz_dir(\n    project_name: &str,\n    fuzz_dir_opt: Option<&str>,\n) -> (String, ProjectBuilder) {\n    let fuzz_dir = fuzz_dir_opt.unwrap_or(\"custom_dir\");\n    let next_root = next_root();\n    let fuzz_dir_pb = next_root.join(fuzz_dir);\n    let fuzz_dir_sting = fuzz_dir_pb.display().to_string();\n    let pb = project_with_params(project_name, next_root, fuzz_dir_pb);\n    (fuzz_dir_sting, pb)\n}", "id": 252, "concepts": ["string formatting", "conditional string concatenation", "number incrementation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nfn main() {\n    std::panic::set_hook(Box::new(console_error_panic_hook::hook));\n    console_log::init_with_level(log::Level::Warn).expect(\"could not initialize logger\");\n\n    let fighter_bytes = include_bytes!(\"subaction_data.bin\");\n    let subaction = bincode::deserialize(fighter_bytes).unwrap();\n    wasm_bindgen_futures::spawn_local(render_window_wasm(subaction));\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    std::panic::set_hook(Box::new(console_error_panic_hook::hook));\n    console_log::init_with_level(log::Level::Warn).expect(\"could not initialize logger\");\n\n    let fighter_bytes = include_bytes!(\"subaction_data.bin\");\n    let subaction = bincode::deserialize(fighter_bytes).unwrap();\n    wasm_bindgen_futures::spawn_local(render_window_wasm(subaction));\n}", "id": 253, "concepts": ["binary code serialization", "unsafe code execution", "panic handling", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nfn main() {}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {}", "id": 254, "concepts": ["CLI parsing", "function composition", "default arguments"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 4\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 9\n### Snippet\nfn is_aligned(value: usize, alignment: usize) -> bool {\n    (value & (alignment - 1)) == 0\n}\n\n### Concepts", "fingerprint": null, "seed": "fn is_aligned(value: usize, alignment: usize) -> bool {\n    (value & (alignment - 1)) == 0\n}", "id": 255, "concepts": ["bitwise operation", "unsigned integer comparison", "number alignment", "type definition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nfn main() {\n    // let name = String::from(\"rust\");\n    let mut client = Client::new();\n\n    // now loop forever getting tasks every now and then\n    let duration = (&client.interval * 1000.0) as u64;\n\n    let sleep_duration = time::Duration::from_millis(duration);\n\n    let (channel_out, channel_in) = unbounded();\n    // sleep for duration given by server, every interval wake up and ask for new tasks\n    loop {\n        thread::sleep(sleep_duration);\n\n        // get new tasks from the server\n        // need to return success/failure so we know if we should send something into the thread or not\n        client.get_task();\n        // fuck me\n        let mut c = client.clone();\n        let out_c = channel_out.clone();\n        // spawn a thread to deal with the new tasks\n        let thread_hndl = thread::spawn(move || {\n            handle_task(&mut c, out_c);\n        });\n        if let Ok(resp_from_thread) = channel_in.try_recv() {\n            println!(\"yayyy from main {}\", &resp_from_thread);\n            // need to send resp to server, and remvoe task from the queue\n            let resp_task_id = resp_from_thread.parse::<i32>().unwrap();\n            client.task_queue.retain(|x| x.task_id != resp_task_id);\n        }\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    // let name = String::from(\"rust\");\n    let mut client = Client::new();\n\n    // now loop forever getting tasks every now and then\n    let duration = (&client.interval * 1000.0) as u64;\n\n    let sleep_duration = time::Duration::from_millis(duration);\n\n    let (channel_out, channel_in) = unbounded();\n    // sleep for duration given by server, every interval wake up and ask for new tasks\n    loop {\n        thread::sleep(sleep_duration);\n\n        // get new tasks from the server\n        // need to return success/failure so we know if we should send something into the thread or not\n        client.get_task();\n        // fuck me\n        let mut c = client.clone();\n        let out_c = channel_out.clone();\n        // spawn a thread to deal with the new tasks\n        let thread_hndl = thread::spawn(move || {\n            handle_task(&mut c, out_c);\n        });\n        if let Ok(resp_from_thread) = channel_in.try_recv() {\n            println!(\"yayyy from main {}\", &resp_from_thread);\n            // need to send resp to server, and remvoe task from the queue\n            let resp_task_id = resp_from_thread.parse::<i32>().unwrap();\n            client.task_queue.retain(|x| x.task_id != resp_task_id);\n        }\n    }\n}", "id": 256, "concepts": ["spawn child threads", "sleeping functionality", "number conversion", "channel communication"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\nfn\ntest_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nv1234\n=\nvec\n!\n[\n1u8\n2\n3\n4\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nv1234\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nv1234\n)\n;\nOk\n(\n(\n)\n)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn\ntest_blob\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\nlet\nv1234\n=\nvec\n!\n[\n1u8\n2\n3\n4\n]\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\nb\n)\nVALUES\n(\n?\n1\n)\n\"\n[\n&\nv1234\n]\n)\n?\n;\nlet\nv\n:\nVec\n<\nu8\n>\n=\ndb\n.\none_column\n(\n\"\nSELECT\nb\nFROM\nfoo\n\"\n)\n?\n;\nassert_eq\n!\n(\nv\nv1234\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 257, "concepts": ["database interaction using SQLite", "database interaction using SQLite with parameterized data", "list comprehension", "list extension", "conditional list comprehension"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn git(args: &[&str]) -> Result<String, Box<dyn std::error::Error>> {\n    let mut cmd = Command::new(\"git\");\n    cmd.args(args);\n    cmd.stdout(Stdio::piped());\n    let out = cmd.spawn();\n    let mut out = match out {\n        Ok(v) => v,\n        Err(err) => {\n            panic!(\"Failed to spawn command `{:?}`: {:?}\", cmd, err);\n        }\n    };\n\n    let status = out.wait().expect(\"waited\");\n\n    if !status.success() {\n        eprintln!(\"failed to run `git {:?}`: {:?}\", args, status);\n        return Err(std::io::Error::from(std::io::ErrorKind::Other).into());\n    }\n\n    let mut stdout = Vec::new();\n    out.stdout.unwrap().read_to_end(&mut stdout).unwrap();\n    Ok(String::from_utf8_lossy(&stdout).into_owned())\n}\n\n### Concepts", "fingerprint": null, "seed": "fn git(args: &[&str]) -> Result<String, Box<dyn std::error::Error>> {\n    let mut cmd = Command::new(\"git\");\n    cmd.args(args);\n    cmd.stdout(Stdio::piped());\n    let out = cmd.spawn();\n    let mut out = match out {\n        Ok(v) => v,\n        Err(err) => {\n            panic!(\"Failed to spawn command `{:?}`: {:?}\", cmd, err);\n        }\n    };\n\n    let status = out.wait().expect(\"waited\");\n\n    if !status.success() {\n        eprintln!(\"failed to run `git {:?}`: {:?}\", args, status);\n        return Err(std::io::Error::from(std::io::ErrorKind::Other).into());\n    }\n\n    let mut stdout = Vec::new();\n    out.stdout.unwrap().read_to_end(&mut stdout).unwrap();\n    Ok(String::from_utf8_lossy(&stdout).into_owned())\n}", "id": 258, "concepts": ["command execution using `Command` builder", "`Output` value and `status` check", "`std::error::Error` implementation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\npub fn task_set_cpool(target: CAddr, cpool: CAddr) {\n    system_call(SystemCall::TaskSetCPool {\n        request: (target, cpool),\n    });\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn task_set_cpool(target: CAddr, cpool: CAddr) {\n    system_call(SystemCall::TaskSetCPool {\n        request: (target, cpool),\n    });\n}", "id": 259, "concepts": ["system call function", "tuple deconstruction", "function argument passing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 8\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 9\n### Snippet\nfn a_table_should_read_0_for_any_key() {\n  let mut table = HashMapOfTreeMap::new();\n  let mut vs = [Value::default(); 1];\n  table.read (0, &[0], &mut vs);\n  match vs {\n    [Value { v: 0, t: 0}] => (),\n    _ => assert!(false)\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn a_table_should_read_0_for_any_key() {\n  let mut table = HashMapOfTreeMap::new();\n  let mut vs = [Value::default(); 1];\n  table.read (0, &[0], &mut vs);\n  match vs {\n    [Value { v: 0, t: 0}] => (),\n    _ => assert!(false)\n  }\n}", "id": 260, "concepts": ["hashmap and hashmap mutability", "value type", "value data type", "value traits", "value conversions", "value comparisons"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 7\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nasync fn save_metric_entry(mut database: &Database, hostname: &str, timestamp: &DateTime<Utc>, entry: DockerContainerMetricEntry) -> Result<(), MetricSaveError> {\n    sqlx::query!(\n        \"insert into metric_docker_containers (hostname, timestamp, name, state, cpu_usage, memory_usage, memory_cache, network_tx, network_rx) values ($1, $2, $3, $4, $5, $6, $7, $8, $9) returning name\",\n        hostname.to_string(), *timestamp, entry.name, entry.state, entry.cpu_usage, entry.memory_usage as i64, entry.memory_cache as i64, entry.network_tx, entry.network_rx\n    ).fetch_one(&mut database).await?;\n\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "async fn save_metric_entry(mut database: &Database, hostname: &str, timestamp: &DateTime<Utc>, entry: DockerContainerMetricEntry) -> Result<(), MetricSaveError> {\n    sqlx::query!(\n        \"insert into metric_docker_containers (hostname, timestamp, name, state, cpu_usage, memory_usage, memory_cache, network_tx, network_rx) values ($1, $2, $3, $4, $5, $6, $7, $8, $9) returning name\",\n        hostname.to_string(), *timestamp, entry.name, entry.state, entry.cpu_usage, entry.memory_usage as i64, entry.memory_cache as i64, entry.network_tx, entry.network_rx\n    ).fetch_one(&mut database).await?;\n\n    Ok(())\n}", "id": 261, "concepts": ["async function execution", "query building with SQLx", "database access with SQLx"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 4\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 7\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn map_ignored(_: IRCToken) -> Result<IRCToken, ~str> {\n    Ok(Ignored)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn map_ignored(_: IRCToken) -> Result<IRCToken, ~str> {\n    Ok(Ignored)\n}", "id": 262, "concepts": ["enum pattern matching", "function composition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 6\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nfn find_common_id() -> Option<String> {\n    let input = fs::File::open(\"input.txt\")\n        .expect(\"Something went wrong reading the file\");\n    let reader = io::BufReader::new(input);\n    let mut box_ids: Vec<String> = reader.lines().map(|l| l.unwrap()).collect();\n    box_ids.sort();\n\n    for i in 0..box_ids.len() {\n        let mut diff = 0;\n        if i != box_ids.len() - 1 {\n            for (a, b) in box_ids[i].chars().zip(box_ids[i+1].chars()) {\n                if a != b {\n                    diff += 1;\n                }\n            }\n            if diff == 1 {\n                return Some(get_common_chars(&box_ids[i], &box_ids[i+1]));\n            }\n        }\n    }\n    None\n}\n\n### Concepts", "fingerprint": null, "seed": "fn find_common_id() -> Option<String> {\n    let input = fs::File::open(\"input.txt\")\n        .expect(\"Something went wrong reading the file\");\n    let reader = io::BufReader::new(input);\n    let mut box_ids: Vec<String> = reader.lines().map(|l| l.unwrap()).collect();\n    box_ids.sort();\n\n    for i in 0..box_ids.len() {\n        let mut diff = 0;\n        if i != box_ids.len() - 1 {\n            for (a, b) in box_ids[i].chars().zip(box_ids[i+1].chars()) {\n                if a != b {\n                    diff += 1;\n                }\n            }\n            if diff == 1 {\n                return Some(get_common_chars(&box_ids[i], &box_ids[i+1]));\n            }\n        }\n    }\n    None\n}", "id": 263, "concepts": ["string comparison and manipulation", "bag-of-character approach"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 7\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn main() {\n\n  let nhits = 20;\n  let ntrials = 2000;\n  let nnanos = 60 * 1000 * 1000 * 1000;\n  let ntransfers = 1000;\n  let nbrokers = 8;\n  let tolerance = 0.05;\n  let ops = (ntransfers * nbrokers) as f64;\n  let million = (1000 * 1000) as f64;\n\n  let mut sum = 0.0;\n\n  let mut hits = 0;\n  let mut trial = 0;\n  let limit = time::precise_time_ns() + nnanos;\n  while hits < nhits && trial < ntrials && time::precise_time_ns() < limit {\n    let mut table = HashMapOfTreeMap::new();\n    let start = time::precise_time_ns();\n    for _ in 0..nbrokers {\n      broker(&mut table, ntransfers);\n    }\n    let end = time::precise_time_ns();\n    let ns = (end - start) as f64;\n    let x = ops / ns * million;\n    sum += x;\n    let n = (trial + 1) as f64;\n    let mean = sum / n;\n    let dev = (x - mean).abs() / mean;\n    if dev <= tolerance {\n      println!(\"{:5} {:8.2} ops/ms ({:8.2})\", trial, x, mean);\n      hits += 1;\n    }\n    trial += 1;\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n\n  let nhits = 20;\n  let ntrials = 2000;\n  let nnanos = 60 * 1000 * 1000 * 1000;\n  let ntransfers = 1000;\n  let nbrokers = 8;\n  let tolerance = 0.05;\n  let ops = (ntransfers * nbrokers) as f64;\n  let million = (1000 * 1000) as f64;\n\n  let mut sum = 0.0;\n\n  let mut hits = 0;\n  let mut trial = 0;\n  let limit = time::precise_time_ns() + nnanos;\n  while hits < nhits && trial < ntrials && time::precise_time_ns() < limit {\n    let mut table = HashMapOfTreeMap::new();\n    let start = time::precise_time_ns();\n    for _ in 0..nbrokers {\n      broker(&mut table, ntransfers);\n    }\n    let end = time::precise_time_ns();\n    let ns = (end - start) as f64;\n    let x = ops / ns * million;\n    sum += x;\n    let n = (trial + 1) as f64;\n    let mean = sum / n;\n    let dev = (x - mean).abs() / mean;\n    if dev <= tolerance {\n      println!(\"{:5} {:8.2} ops/ms ({:8.2})\", trial, x, mean);\n      hits += 1;\n    }\n    trial += 1;\n  }\n}", "id": 264, "concepts": ["hashmap and hashmap iteration", "guarded execution", "time measurements", "floating point accuracy"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 2\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nfn desearlizer_client(req: &mut reqwest::Response) -> Result<Client, Error> {\n    let mut buffer = String::new();\n    match req.read_to_string(&mut buffer) {\n        Ok(_) => (),\n        Err(e) => println!(\"error : {}\", e.to_string())\n    };\n    println!(\"buffer before serializaztion: {}\", buffer);\n\n    let v = match serde_json::from_str::<Client>(&buffer){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn desearlizer_client(req: &mut reqwest::Response) -> Result<Client, Error> {\n    let mut buffer = String::new();\n    match req.read_to_string(&mut buffer) {\n        Ok(_) => (),\n        Err(e) => println!(\"error : {}\", e.to_string())\n    };\n    println!(\"buffer before serializaztion: {}\", buffer);\n\n    let v = match serde_json::from_str::<Client>(&buffer){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}", "id": 265, "concepts": ["deserialization of a JSON string", "error handling", "JSON parsing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 4\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 9\n### Snippet\nfn init_servo(robot: &mut Robot) {\n    let servos = ServoManager::new();\n\n    let m2 = servos[0xFE].reboot();\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    for _ in 0..5 {\n        robot.delay.delay_ms(70 as u32);\n    }\n\n    let m2 = servos[0xFE].ram_write(WritableRamAddr::AckPolicy(2));\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    let m1 = servos[0xFE].enable_torque();\n\n    for b in m1 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn init_servo(robot: &mut Robot) {\n    let servos = ServoManager::new();\n\n    let m2 = servos[0xFE].reboot();\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    for _ in 0..5 {\n        robot.delay.delay_ms(70 as u32);\n    }\n\n    let m2 = servos[0xFE].ram_write(WritableRamAddr::AckPolicy(2));\n\n    for b in m2 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n\n    let m1 = servos[0xFE].enable_torque();\n\n    for b in m1 {\n        block!(robot.servo_tx.write(b)).unwrap();\n    }\n}", "id": 267, "concepts": ["initialization of a servo and its operations", "usage of an iterator", "writing data to a servo", "reading data from a servo"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 4\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\nfn init() {\n    let project = project(\"init\").build();\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"fuzz_target_1\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}\n\n### Concepts", "fingerprint": null, "seed": "fn init() {\n    let project = project(\"init\").build();\n    project.cargo_fuzz().arg(\"init\").assert().success();\n    assert!(project.fuzz_dir().is_dir());\n    assert!(project.fuzz_cargo_toml().is_file());\n    assert!(project.fuzz_targets_dir().is_dir());\n    assert!(project.fuzz_target_path(\"fuzz_target_1\").is_file());\n    project\n        .cargo_fuzz()\n        .arg(\"run\")\n        .arg(\"fuzz_target_1\")\n        .arg(\"--\")\n        .arg(\"-runs=1\")\n        .assert()\n        .success();\n}", "id": 269, "concepts": ["cargo package management", "executing cargo commands", "process spawning", "writing to files"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn create_mesh_buffer_verts(\n    chunk: &Chunk,\n    device: &wgpu::Device,\n    queue: &wgpu::Queue,\n) -> MeshBufferVerts {\n    // Calculate total length of buffer e.g. a full chunk of different voxels. This way a new buffer only has to be created when the voxel capacity is changed.\n\n    let verts = Mesh::verts(chunk);\n    let vert_len = verts.len();\n\n    let single_cube_verts = Mesh::cube_verts().len();\n    let single_cube_color_verts = (single_cube_verts / 3) * std::mem::size_of::<PaletteIndexType>(); // One PaletteIndexType per 3 verts\n\n    let max_voxels = {\n        let (x, y, z) = chunk.capacity();\n        x * y * z\n    };\n\n    let max_buf_size =\n        (single_cube_verts + single_cube_color_verts) * max_voxels * std::mem::size_of::<f32>();\n\n    let buffer = device.create_buffer(&wgpu::BufferDescriptor {\n        label: None,\n        mapped_at_creation: false,\n        size: max_buf_size as u64,\n        usage: wgpu::BufferUsage::VERTEX | wgpu::BufferUsage::COPY_DST,\n    });\n\n    if vert_len > 0 {\n        queue.write_buffer(&buffer, 0, bytemuck::cast_slice(&verts));\n    }\n\n    MeshBufferVerts {\n        buffer,\n        vert_len,\n        max_capacity: chunk.capacity(),\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn create_mesh_buffer_verts(\n    chunk: &Chunk,\n    device: &wgpu::Device,\n    queue: &wgpu::Queue,\n) -> MeshBufferVerts {\n    // Calculate total length of buffer e.g. a full chunk of different voxels. This way a new buffer only has to be created when the voxel capacity is changed.\n\n    let verts = Mesh::verts(chunk);\n    let vert_len = verts.len();\n\n    let single_cube_verts = Mesh::cube_verts().len();\n    let single_cube_color_verts = (single_cube_verts / 3) * std::mem::size_of::<PaletteIndexType>(); // One PaletteIndexType per 3 verts\n\n    let max_voxels = {\n        let (x, y, z) = chunk.capacity();\n        x * y * z\n    };\n\n    let max_buf_size =\n        (single_cube_verts + single_cube_color_verts) * max_voxels * std::mem::size_of::<f32>();\n\n    let buffer = device.create_buffer(&wgpu::BufferDescriptor {\n        label: None,\n        mapped_at_creation: false,\n        size: max_buf_size as u64,\n        usage: wgpu::BufferUsage::VERTEX | wgpu::BufferUsage::COPY_DST,\n    });\n\n    if vert_len > 0 {\n        queue.write_buffer(&buffer, 0, bytemuck::cast_slice(&verts));\n    }\n\n    MeshBufferVerts {\n        buffer,\n        vert_len,\n        max_capacity: chunk.capacity(),\n    }\n}", "id": 270, "concepts": ["slice initialization", "type conversions", "Rust's bytemuck crate", "buffer creation with device and queue"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 2\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 3\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\n    while left < arr.len() && ryt >= start && left <= ryt {\n        let mid = (left + ryt) / 2;\n        if arr[mid] == target {\n            return mid;\n        } else if arr[mid] > target {\n            ryt = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    left\n}\n\nfn triplets_sorting(nums: &mut [i32], t: i32) -> i32 {\n    // Time complexity = O((n^2)logn)\n    nums.sort();\n    let mut count = 0;\n    for i in 0..nums.len() {\n        // Add further logic for triplet counting based on the requirement\n    }\n    count\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nfn a_table_should_read_and_write_batches() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }, Row { k: 1, v: 2 }]);\n  let mut vs = [Value::default(); 2];\n  table.read (1, &[0, 1], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }, Value { v: 2, t: 1 }]);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn a_table_should_read_and_write_batches() {\n  let mut table = HashMapOfTreeMap::new();\n  table.write(0, &[Row { k: 0, v: 1 }, Row { k: 1, v: 2 }]);\n  let mut vs = [Value::default(); 2];\n  table.read (1, &[0, 1], &mut vs);\n  assert_eq!(vs, [Value { v: 1, t: 1 }, Value { v: 2, t: 1 }]);\n}", "id": 271, "concepts": ["hashmap", "nested and recursive data structure access", "mutable reference usage"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 2\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 6\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 9\n### Snippet\nfn assert_memory_load_bytes<R: Rng, M: Memory>(\n    rng: &mut R,\n    memory: &mut M,\n    buffer_size: usize,\n    addr: u64,\n) {\n    let mut buffer_store = Vec::<u8>::new();\n    buffer_store.resize(buffer_size, 0);\n    rng.fill(buffer_store.as_mut_slice());\n\n    memory\n        .store_bytes(addr, &buffer_store.as_slice())\n        .expect(\"store bytes failed\");\n\n    let buffer_load = memory\n        .load_bytes(addr, buffer_store.len() as u64)\n        .expect(\"load bytes failed\")\n        .to_vec();\n\n    assert!(buffer_load.cmp(&buffer_store).is_eq());\n\n    // length out of bound\n    let outofbound_size = if buffer_store.is_empty() {\n        memory.memory_size() + 1\n    } else {\n        buffer_store.len() + memory.memory_size()\n    };\n    let ret = memory.load_bytes(addr, outofbound_size as u64);\n    assert!(ret.is_err());\n    assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n\n    // address out of bound\n    let ret = memory.load_bytes(\n        addr + memory.memory_size() as u64 + 1,\n        buffer_store.len() as u64,\n    );\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok())\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n\n    // addr + size is overflow\n    let ret = memory.load_bytes(addr + (0xFFFFFFFFFFFFFF - addr), buffer_store.len() as u64);\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok());\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn assert_memory_load_bytes<R: Rng, M: Memory>(\n    rng: &mut R,\n    memory: &mut M,\n    buffer_size: usize,\n    addr: u64,\n) {\n    let mut buffer_store = Vec::<u8>::new();\n    buffer_store.resize(buffer_size, 0);\n    rng.fill(buffer_store.as_mut_slice());\n\n    memory\n        .store_bytes(addr, &buffer_store.as_slice())\n        .expect(\"store bytes failed\");\n\n    let buffer_load = memory\n        .load_bytes(addr, buffer_store.len() as u64)\n        .expect(\"load bytes failed\")\n        .to_vec();\n\n    assert!(buffer_load.cmp(&buffer_store).is_eq());\n\n    // length out of bound\n    let outofbound_size = if buffer_store.is_empty() {\n        memory.memory_size() + 1\n    } else {\n        buffer_store.len() + memory.memory_size()\n    };\n    let ret = memory.load_bytes(addr, outofbound_size as u64);\n    assert!(ret.is_err());\n    assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n\n    // address out of bound\n    let ret = memory.load_bytes(\n        addr + memory.memory_size() as u64 + 1,\n        buffer_store.len() as u64,\n    );\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok())\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n\n    // addr + size is overflow\n    let ret = memory.load_bytes(addr + (0xFFFFFFFFFFFFFF - addr), buffer_store.len() as u64);\n    if buffer_store.is_empty() {\n        assert!(ret.is_ok());\n    } else {\n        assert!(ret.is_err());\n        assert_eq!(ret.err().unwrap(), Error::MemOutOfBound);\n    }\n}", "id": 272, "concepts": ["random number generation", "memory access check", "error handling with assertions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 9\n### Snippet\npub fn set_working_folder(working_folder: String) -> Result<(), ()> {\n    unsafe {\n        WORKING_FOLDER = working_folder;\n    }\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn set_working_folder(working_folder: String) -> Result<(), ()> {\n    unsafe {\n        WORKING_FOLDER = working_folder;\n    }\n    Ok(())\n}", "id": 273, "concepts": ["unsafe code", "global variables", "input validation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 3\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 5\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 8\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nfn main() \n{\n    let args: Vec<String> = std::env::args().collect();\n\n    if args.len() < 2 {\n        eprintln!(\"Syntax: {} <filename>\", args[0]);\n        return;\n    }\n\n    let path    = Path::new(&args[1]);\n    let display = path.display();\n\n    let mut file = match File::open(&path)    {\n        Err(why) => panic!(\"Could not open file: {} (Reason: {})\", \n            display, why.description()),\n        Ok(file) => file\n    };\n\n    // read the full file into memory. panic on failure\n    let mut raw_file = Vec::new();\n    file.read_to_end(&mut raw_file).unwrap();\n\n    // construct a cursor so we can seek in the raw buffer\n    let mut cursor = Cursor::new(raw_file);\n    let mut image  = match decode_ppm_image(&mut cursor) {\n        Ok (img) => img,\n        Err(why) => panic!(\"Could not parse PPM file - Desc: {}\", why.description()),\n    };\n\n    show_image(&image);\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() \n{\n    let args: Vec<String> = std::env::args().collect();\n\n    if args.len() < 2 {\n        eprintln!(\"Syntax: {} <filename>\", args[0]);\n        return;\n    }\n\n    let path    = Path::new(&args[1]);\n    let display = path.display();\n\n    let mut file = match File::open(&path)    {\n        Err(why) => panic!(\"Could not open file: {} (Reason: {})\", \n            display, why.description()),\n        Ok(file) => file\n    };\n\n    // read the full file into memory. panic on failure\n    let mut raw_file = Vec::new();\n    file.read_to_end(&mut raw_file).unwrap();\n\n    // construct a cursor so we can seek in the raw buffer\n    let mut cursor = Cursor::new(raw_file);\n    let mut image  = match decode_ppm_image(&mut cursor) {\n        Ok (img) => img,\n        Err(why) => panic!(\"Could not parse PPM file - Desc: {}\", why.description()),\n    };\n\n    show_image(&image);\n}", "id": 274, "concepts": ["file system access", "file read operations", "file iteration", "file read into memory", "file seek", "reading a file into memory"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 3\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 9\n### Snippet\nfn\ntest_value\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\ni\n)\nVALUES\n(\n?\n1\n)\n\"\n[\nValue\n:\n:\nInteger\n(\n10\n)\n]\n)\n?\n;\nassert_eq\n!\n(\n10i64\ndb\n.\none_column\n:\n:\n<\ni64\n>\n(\n\"\nSELECT\ni\nFROM\nfoo\n\"\n)\n?\n)\n;\nOk\n(\n(\n)\n)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn\ntest_value\n(\n)\n-\n>\nResult\n<\n(\n)\n>\n{\nlet\ndb\n=\nchecked_memory_handle\n(\n)\n?\n;\ndb\n.\nexecute\n(\n\"\nINSERT\nINTO\nfoo\n(\ni\n)\nVALUES\n(\n?\n1\n)\n\"\n[\nValue\n:\n:\nInteger\n(\n10\n)\n]\n)\n?\n;\nassert_eq\n!\n(\n10i64\ndb\n.\none_column\n:\n:\n<\ni64\n>\n(\n\"\nSELECT\ni\nFROM\nfoo\n\"\n)\n?\n)\n;\nOk\n(\n(\n)\n)\n}", "id": 275, "concepts": ["result value handling", "database operations", "error handling", "assertion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 2\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 3\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 4\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nfn duration(string: &str, pattern: &Regex, suffix_map: &HashMap<&str, i32>) -> Result<i32, String> {\n    let captures = pattern.captures(string).ok_or_else(|| format!(\"Invalid duration: {}\", string))?;\n\n    let suffix = captures.get(2).map(|m| m.as_str()).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let multiplier = suffix_map.get(suffix).ok_or_else(|| format!(\"Invalid duration suffix: {}\", string))?;\n    \n    let value: i32 = captures.get(1).unwrap().as_str().parse().map_err(|_| format!(\"Invalid duration: {}\", string))?;\n    \n    Ok(value * multiplier)\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 8\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\npub fn test_load_elf_crash_64() {\n    let buffer = fs::read(\"tests/programs/load_elf_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"load_elf_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn test_load_elf_crash_64() {\n    let buffer = fs::read(\"tests/programs/load_elf_crash_64\").unwrap().into();\n    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec![\"load_elf_crash_64\".into()]);\n    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage));\n}", "id": 276, "concepts": ["low-level memory manipulation", "error handling", "type checking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 2\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 4\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 7\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn desearlizer_task(req: &mut reqwest::Response) -> Result<Task, Error> {\n    let mut buffer = String::new();\n    match req.read_to_string(&mut buffer) {\n        Ok(_) => (),\n        Err(e) => println!(\"error : {}\", e.to_string())\n    };\n    println!(\"buffer before serializaztion: {}\", buffer);\n\n    let v = match serde_json::from_str::<Task>(&buffer){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn desearlizer_task(req: &mut reqwest::Response) -> Result<Task, Error> {\n    let mut buffer = String::new();\n    match req.read_to_string(&mut buffer) {\n        Ok(_) => (),\n        Err(e) => println!(\"error : {}\", e.to_string())\n    };\n    println!(\"buffer before serializaztion: {}\", buffer);\n\n    let v = match serde_json::from_str::<Task>(&buffer){\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    };\n    Ok(v)\n}", "id": 277, "concepts": ["deserialization using the serde library", "error handling", "string to JSON conversion with serde_json"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 2\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 4\n### Snippet\nfn accuracy(output: &Tensor, target: &Tensor, topk: &[i64]) -> Vec<Tensor> {\n    let maxk = *topk.iter().max().unwrap();\n    let batch_size = target.size()[0];\n\n    let (_, pred) = output.topk(maxk, 1, true, true);\n    let pred = pred.transpose(0, 1);\n    let correct = pred.eq(&target.view([1, -1]).expand_as(&pred));\n\n    topk.iter().map(|&k| {\n        let correct_k = correct.slice(0, 0, k, 1).view(-1).to_kind(Kind::Float).sum(Kind::Float);\n        correct_k * (100.0 / batch_size as f64)\n    }).collect()\n}\n\n### Concepts\ntop-k accuracy computation, tensor operations in PyTorch, batch processing, default arguments\n\n## Example 5\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 6\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 7\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 8\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 9\n### Snippet\npub fn star1(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let (&sleepiest_guard_id, sleepiest_guard_days) = guard_map.iter()\n        .max_by_key(|(_, v)| v.iter()\n            .map(|day| 60 - day.minutes_awake)\n            .sum::<i32>()\n    ).unwrap();\n    let mut sleepiest_guard_awake_by_minutes = vec![0; 60];\n    for day in sleepiest_guard_days {\n        // println!(\"Day: {:?}\", day);\n        for minute in 0..60 {\n            sleepiest_guard_awake_by_minutes[minute] += i32::from(day.minutes[minute]);\n        }\n    }\n    let (max_minute, _) = sleepiest_guard_awake_by_minutes.iter().enumerate().min_by_key(|(_, times)| *times).unwrap();\n\n    println!(\"Min minute: {}, max guard: {}\", max_minute, sleepiest_guard_id);\n\n    (sleepiest_guard_id * max_minute as i32).to_string()\n}\n\n### Concepts", "fingerprint": null, "seed": "pub fn star1(lines: &Vec<String>) -> String {\n    let days = initialize(lines);\n\n    let mut guard_map = HashMap::new();\n    for day in days {\n        guard_map.entry(day.guard_id)\n            .or_insert(vec![])\n            .push(day);\n    }\n\n    let (&sleepiest_guard_id, sleepiest_guard_days) = guard_map.iter()\n        .max_by_key(|(_, v)| v.iter()\n            .map(|day| 60 - day.minutes_awake)\n            .sum::<i32>()\n    ).unwrap();\n    let mut sleepiest_guard_awake_by_minutes = vec![0; 60];\n    for day in sleepiest_guard_days {\n        // println!(\"Day: {:?}\", day);\n        for minute in 0..60 {\n            sleepiest_guard_awake_by_minutes[minute] += i32::from(day.minutes[minute]);\n        }\n    }\n    let (max_minute, _) = sleepiest_guard_awake_by_minutes.iter().enumerate().min_by_key(|(_, times)| *times).unwrap();\n\n    println!(\"Min minute: {}, max guard: {}\", max_minute, sleepiest_guard_id);\n\n    (sleepiest_guard_id * max_minute as i32).to_string()\n}", "id": 279, "concepts": ["hashmap usage", "map iteration", "tuple unpacking", "vector computation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 2\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 5\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 6\n### Snippet\nwhile cur_num < sorted_importances.len() {\n    let cluster_idx = sorted_importances[cur_num][1] as usize;\n    let filter_idx = sorted_importances[cur_num][2] as usize;\n\n    if tmp_pruning_quotas[cluster_idx] > 0 {\n        tmp_pruning_quotas[cluster_idx] -= 1;\n    } else {\n        cur_num += 1;\n        continue;\n    }\n\n    let cluster = self.pruned_module_groups_info.get_cluster_by_id(cluster_idx);\n    for node in &cluster.elements {\n        // Additional operations on `node` as needed\n    }\n}\n\n### Concepts\niteration with a while loop, index-based data access, conditional branching, nested loops\n\n## Example 7\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 8\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 9\n### Snippet\nfn initialize(lines: &Vec<String>) -> Vec<Day> {\n    let regex = Regex::new(r\"(\\d\\d-\\d\\d) ((?:23|00):\\d\\d)\\] (Guard #(\\d*)|wakes|falls)\").expect(\"Building Regex failed\");\n    let mut events = lines.iter().map(|l| GuardEvent::from_line(l, &regex)).collect::<Vec<GuardEvent>>();\n    events.sort_by(|GuardEvent {date: date1, minute: minute1, ..}, GuardEvent {date: date2, minute: minute2, ..}| {\n        date1.cmp(date2).then(minute1.cmp(minute2))\n    });\n\n    let mut days = Vec::new();\n    let mut events_iter = events.iter();\n    let mut event_option = events_iter.next();\n    while event_option.is_some() {\n        let event = event_option.unwrap();\n        assert_eq!(event.action, BeginsShift);\n        let mut current_day = Day::new(event.guard_id.unwrap());\n        let mut is_awake = true;\n        event_option = events_iter.next();\n        for minute in 0..60 {\n            if event_option.map_or(false, |e| e.action != BeginsShift && e.minute == minute) {\n                is_awake = !is_awake;\n                event_option = events_iter.next();\n            }\n            current_day.set_next_minute(is_awake);\n        }\n        days.push(current_day);\n    }\n    days\n}\n\n### Concepts", "fingerprint": null, "seed": "fn initialize(lines: &Vec<String>) -> Vec<Day> {\n    let regex = Regex::new(r\"(\\d\\d-\\d\\d) ((?:23|00):\\d\\d)\\] (Guard #(\\d*)|wakes|falls)\").expect(\"Building Regex failed\");\n    let mut events = lines.iter().map(|l| GuardEvent::from_line(l, &regex)).collect::<Vec<GuardEvent>>();\n    events.sort_by(|GuardEvent {date: date1, minute: minute1, ..}, GuardEvent {date: date2, minute: minute2, ..}| {\n        date1.cmp(date2).then(minute1.cmp(minute2))\n    });\n\n    let mut days = Vec::new();\n    let mut events_iter = events.iter();\n    let mut event_option = events_iter.next();\n    while event_option.is_some() {\n        let event = event_option.unwrap();\n        assert_eq!(event.action, BeginsShift);\n        let mut current_day = Day::new(event.guard_id.unwrap());\n        let mut is_awake = true;\n        event_option = events_iter.next();\n        for minute in 0..60 {\n            if event_option.map_or(false, |e| e.action != BeginsShift && e.minute == minute) {\n                is_awake = !is_awake;\n                event_option = events_iter.next();\n            }\n            current_day.set_next_minute(is_awake);\n        }\n        days.push(current_day);\n    }\n    days\n}", "id": 280, "concepts": ["regex parsing", "iterator usage", "input validation", "iterative list extension"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n    (a + 1) * (b + 1) - 1\n}\n\nfn keys_count(a: i64, b: i64) -> i64 {\n    powerset(a, b) * 2 - a - b\n}\n\nfn formula(k: i64) -> f64 {\n    if k % 2 != 0 {\n        ((k + 1) as f64).powi(2) / 2.0 + (k as f64) + 1.0\n    } else {\n        (k as f64).powi(2) / 2.0 + 2.0 * (k as f64) + 1.0\n    }\n}\n\nfn multiset_powerset(multiset: &mut Vec<i32>) {\n    let n = multiset.len();\n    let mut c = vec![0; n];\n    loop {\n        let mut changed = false;\n        let mut i = n - 1;\n        while i >= 0 && !changed {\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\nfn get_hashes<P: AsRef<Path>>(path_or_buffer: P) -> Result<Digests, Box<dyn std::error::Error>> {\n    let mut buf = Vec::new();\n    \n    // Check if input is a file path or buffer content\n    if path_or_buffer.as_ref().is_file() {\n        let mut file = File::open(path_or_buffer)?;\n        file.read_to_end(&mut buf)?;\n    } else {\n        buf = path_or_buffer.as_ref().to_vec();\n    }\n\n    // Compute the various hashes\n    let md5 = hex_digest(MD5, &buf);\n    let sha1 = hex_digest(SHA1_FOR_LEGACY_USE_ONLY, &buf);\n    let sha256 = hex_digest(SHA256, &buf);\n    let sha512 = hex_digest(SHA512, &buf);\n    let ctph = ssdeep::hash(&buf).unwrap_or_default();\n\n    Ok(Digests {\n        md5,\n        sha1,\n        sha256,\n        sha512,\n        ctph,\n    })\n}\n\nfn hex_digest(algorithm: ring::digest::Algorithm, data: &[u8]) -> String {\n    let mut context = Context::new(&algorithm);\n    context.update(data);\n    hex::encode(context.finish().as_ref())\n}\n\n### Concepts\nbinary string hash computation, file content reading, string hashing, named tuples, conditional file content reading\n\n## Example 4\n### Snippet\nlet mut data = Array2::<f64>::zeros((break_points.last().unwrap().clone(), size_blocks));\nlet mut data_stacked = Array2::<f64>::zeros((\n    break_points.last().unwrap() - num_blocks + 1,\n    size_blocks * num_blocks,\n));\nlet mut cluster_point_list = Vec::new();\n\nfor (counter, &break_pt) in break_points.iter().enumerate() {\n    let cluster = seg_ids[counter];\n    let old_break_pt = if counter == 0 { 0 } else { break_points[counter - 1] };\n\n    for num in old_break_pt..break_pt {\n        // Generate the point from this cluster\n        // println!(\"num is: {}\", num);\n        if num == 0 {\n            // Your logic here when num == 0\n        }\n    }\n}\n\n### Concepts\nNumPy array initialization, iteration over break points, cluster segmentation, nested loops\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n/// Converts a phrase with an Oxford comma structure to a list of items.\n/// Examples:\n/// - \"Eeeny, Meeny, Miney, and Moe\" --> [\"Eeeny\", \"Meeny\", \"Miney\", \"Moe\"]\n/// - \"Black and White\" --> [\"Black\", \"White\"]\n/// - \"San Francisco and Saint Francis\" --> [\"San Francisco\", \"Saint Francis\"]\nfn oxford_comma_text_to_list(phrase: &str) -> Vec<String> {\n    let mut items = Vec::new();\n    for subphrase in phrase.split(\", \") {\n        items.extend(\n            subphrase.split(\" and \").map(|item| item.trim().to_string())\n        );\n    }\n    items\n}\n\n### Concepts\nstring manipulation and parsing, list comprehension, iterative list extension, handling text connectors\n\n## Example 9\n### Snippet\nfn main() -> Result<()> {\n    let args = Args::parse();\n    let Args {\n        aspect_ratio,\n        image_width,\n        image_height,\n        samples_per_pixel,\n        outfile,\n        max_depth,\n    } = args;\n\n    let (stats_tx, stats_rx) = unbounded();\n    let (render_tx, render_rx) = bounded(1024);\n\n    let look_from = Point3::new(13.0, 2.0, 3.0);\n    let look_at = Point3::new(0.0, 0.0, 0.0);\n\n    // Camera\n    let camera = Camera::new(\n        look_from,\n        look_at,\n        Vec3::new(0.0, 1.0, 0.0),\n        20.0,\n        aspect_ratio,\n        0.1,\n        10.0,\n    );\n\n    // World\n    let world = World::get_world(true);\n\n    let color_handle = thread::spawn(move || {\n        pixels::pixel_loop(\n            &camera,\n            &world,\n            image_width,\n            image_height,\n            samples_per_pixel,\n            max_depth,\n            stats_tx,\n            render_tx,\n        )\n    });\n\n    let stats_handle = thread::spawn(move || {\n        stats::stats_loop(\n            stats_rx,\n            ((image_width as f32 * image_height as f32 * 11.3) as usize + 24) as usize,\n        )\n    });\n    let render_handle = thread::spawn(move || render::render_loop(&outfile, render_rx));\n\n    let color_io_result = color_handle.join().unwrap();\n    let stats_io_result = stats_handle.join().unwrap();\n    let render_io_result = render_handle.join().unwrap();\n\n    color_io_result?;\n    stats_io_result?;\n    render_io_result?;\n\n    Ok(())\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() -> Result<()> {\n    let args = Args::parse();\n    let Args {\n        aspect_ratio,\n        image_width,\n        image_height,\n        samples_per_pixel,\n        outfile,\n        max_depth,\n    } = args;\n\n    let (stats_tx, stats_rx) = unbounded();\n    let (render_tx, render_rx) = bounded(1024);\n\n    let look_from = Point3::new(13.0, 2.0, 3.0);\n    let look_at = Point3::new(0.0, 0.0, 0.0);\n\n    // Camera\n    let camera = Camera::new(\n        look_from,\n        look_at,\n        Vec3::new(0.0, 1.0, 0.0),\n        20.0,\n        aspect_ratio,\n        0.1,\n        10.0,\n    );\n\n    // World\n    let world = World::get_world(true);\n\n    let color_handle = thread::spawn(move || {\n        pixels::pixel_loop(\n            &camera,\n            &world,\n            image_width,\n            image_height,\n            samples_per_pixel,\n            max_depth,\n            stats_tx,\n            render_tx,\n        )\n    });\n\n    let stats_handle = thread::spawn(move || {\n        stats::stats_loop(\n            stats_rx,\n            ((image_width as f32 * image_height as f32 * 11.3) as usize + 24) as usize,\n        )\n    });\n    let render_handle = thread::spawn(move || render::render_loop(&outfile, render_rx));\n\n    let color_io_result = color_handle.join().unwrap();\n    let stats_io_result = stats_handle.join().unwrap();\n    let render_io_result = render_handle.join().unwrap();\n\n    color_io_result?;\n    stats_io_result?;\n    render_io_result?;\n\n    Ok(())\n}", "id": 281, "concepts": ["concurrency", "threads", "channels", "RAII", "command-line argument parsing", "binary search", "ray tracing", "image output", "texture sampling", "Monte Carlo sampling", "random number generation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nlet mut match_case_flag = match_case == \"auto\";\n\nif match_case_flag {\n    let lower_case_ch_names: Vec<String> = ch_names.iter().map(|s| s.to_lowercase()).collect();\n    let unique_lower_case_ch_names: HashSet<_> = lower_case_ch_names.iter().collect();\n    let unique_ch_names: HashSet<_> = ch_names.iter().collect();\n\n    if unique_lower_case_ch_names.len() < unique_ch_names.len() {\n        match_case_flag = true;\n    } else {\n        match_case_flag = false;\n    }\n}\n\nlet (ch_names, pick_chs): (Vec<String>, Vec<String>) = if match_case_flag {\n    (ch_names.clone(), pick_chs.clone())\n} else {\n    (\n        ch_names.iter().map(|s| s.to_lowercase()).collect(),\n        pick_chs.iter().map(|s| s.to_lowercase()).collect(),\n    )\n};\n\n// Find indices of the pick channels in ch_names\nlet mut picks = Vec::new();\nfor (index, ch_name) in ch_names.iter().enumerate() {\n    if pick_chs.contains(ch_name) {\n        picks.push(index);\n    }\n}\n\n// Optionally sort the picks based on `ordered`\nif ordered {\n    picks.sort_by_key(|&index| pick_chs.iter().position(|ch| ch == &ch_names[index]));\n}\n\npicks\n}\n\n### Concepts\ncase-insensitive string matching, controlled case matching based on an option, list comprehension\n\n## Example 2\n### Snippet\nstruct Restaurant {\n    name: String,\n    cuisine_type: String,\n    number_served: u32,\n}\n\nimpl Restaurant {\n    fn new(name: &str, cuisine_type: &str) -> Self {\n        Restaurant {\n            name: name.to_string(),\n            cuisine_type: cuisine_type.to_string(),\n            number_served: 0,\n        }\n    }\n\n    fn describe_restaurant(&self) {\n        let msg = format!(\"{} tiene los mejores {}.\", self.name, self.cuisine_type);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn open_restaurant(&self) {\n        let msg = format!(\"{} Est\u00e1 Abierta. \u00a1Adelante! \\n\", self.name);\n        println!(\"\\n{}\", msg);\n    }\n\n    fn set_number_served(&mut self, number_served: u32) {\n        self.number_served = number_served; // Aqu\u00ed establecemos la cantidad de clientes atendidos\n    }\n\n    fn increment_number_served(&mut self, additional_served: u32) {\n        self.number_served += additional_served; // Aqu\u00ed incrementamos la cantidad de clientes atendidos\n    }\n}\n\n### Concepts\nobject-oriented programming, string formatting and manipulation, encapsulation, input validation\n\n## Example 3\n### Snippet\nfn busca_linear_recursiva(array: &[i32], elemento: i32) -> isize {\n    busca_recursiva(array, elemento, -1)\n}\n\nfn busca_recursiva(array: &[i32], elemento: i32, mut i: isize) -> isize {\n    i += 1;\n    if i as usize == array.len() {\n        return -1;\n    }\n    if array[i as usize] == elemento {\n        return i;\n    }\n    busca_recursiva(array, elemento, i)\n}\n\n### Concepts\nlinear search with recursion, default parameter initialization, multiple base cases in recursion\n\n## Example 4\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nfn is_prime(n: i64, prime_list: &Vec<i64>, prime_dict: &mut HashMap<i64, i32>) -> i32 {\n    let isprime = if n >= 2 { 1 } else { 0 };\n    for &prime in prime_list {\n        if prime * prime > n { break; }\n        if n % prime == 0 {\n            return 0;\n        }\n    }\n    if isprime == 1 {\n        prime_dict.insert(n, 1);\n    }\n    isprime\n}\n\nfn prime(x: usize, prime_list: &mut Vec<i64>) -> i64 {\n    let mut lastn = prime_list[prime_list.len() - 1];\n    while prime_list.len() <= x {\n        lastn = lastn + 1;\n    }\n    lastn\n}\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n/// Returns ceil(n / 2^b) without performing any floating-point or division operations.\n/// This is done by right-shifting n by b bits and incrementing the result by 1\n/// if any '1' bits were shifted out.\npub fn ceil_shift(n: i64, b: i32) -> Result<i64, UnsupportedOperandError> {\n    // Check for negative values\n    if n < 0 || b < 0 {\n        return Err(UnsupportedOperandError);\n    }\n    \n    let mask = (1_i64 << b) - 1;\n    \n    Ok(if n & mask != 0 {\n        (n >> b) + 1\n    } else {\n        n >> b\n    })\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 9\n### Snippet\nfn main() {\n    if let Err(err) = Config::new().and_then(|conf| ui::user_menu(conf)) {\n        eprintln!(\"{}\", err);\n        process::exit(1);\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "fn main() {\n    if let Err(err) = Config::new().and_then(|conf| ui::user_menu(conf)) {\n        eprintln!(\"{}\", err);\n        process::exit(1);\n    }\n}", "id": 282, "concepts": ["error handling using the `?` operator", "pattern matching", "result chaining"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nuse std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    fn sum_of_unique(nums: Vec<i32>) -> i32 {\n        let mut counts = HashMap::new();\n        for &num in &nums {\n            *counts.entry(num).or_insert(0) += 1;\n        }\n        counts.iter().filter(|&(_, &v)| v == 1).map(|(&k, _)| k).sum()\n    }\n}\n\n### Concepts\ndictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition\n\n## Example 2\n### Snippet\nfn alternating_characters(s: &str) -> usize {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 0;\n    let chars: Vec<char> = s.chars().collect();\n\n    while j < chars.len() {\n        if chars[j] == chars[i] {\n            while j < chars.len() && chars[j] == chars[i] {\n                j += 1;\n            }\n            count += j - i - 1;\n        }\n        i = j;\n        j += 1;\n    }\n\n    count\n}\n\n### Concepts\n2-pointer technique, conditional loop, string traversal and character comparison, count accumulation\n\n## Example 3\n### Snippet\n/// Creates folds from the given data.\n///\n/// # Arguments\n/// * `data` - The data to fold\n/// * `count` - The number of folds to create\n///\n/// # Returns\n/// A vector of folds\nfn create_folds_list<T: Clone>(data: &[T], count: usize) -> Vec<Vec<T>> {\n    let fold_count = data.len() as f64 / count as f64;\n    let mut folds = Vec::new();\n\n    for fold_index in 0..count {\n        let low = (fold_index as f64 * fold_count).round() as usize;\n        let high = ((fold_index as f64 + 1.0) * fold_count).round() as usize;\n        let fold = data[low..high].to_vec();\n        folds.push(fold);\n    }\n\n    folds\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n    value = int(round((value - prev) * 1e5))\n    value = ~(value << 1) if value < 0 else (value << 1)\n    chunks = _split_into_chunks(value)\n    return (chr(chunk + 63) for chunk in chunks)\ndef _split_into_chunks(value):\n    while value >= 32:  # 2^5, while there are at least 5 bits\n        # first & with 2^5-1, zeros out all the bits other than the first five\n        # then OR with 0x20 if another bit chunk follows\n        yield (value & 31) | 0x20\n        value >>= 5\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nfn decompress(&self) -> Vec<u8> {\n    let source = &self.compressed;\n    if source.is_empty() {\n        return vec![];\n    }\n\n    let mut pos = 0;\n    let mut node = &self.root;\n    let mut res = Vec::new();\n\n    while pos < source.len() {\n        let code = source[pos] as usize;\n        let child = &node.children[code];\n\n        if child.is_leaf {\n            res.push(child.value);\n            node = &self.root;\n        } else {\n            node = child;\n        }\n        pos += 1;\n    }\n\n    res\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n/// Adds asterisks to strings that appear multiple times, so the resulting\n/// list has only unique strings but still the same length, order, and meaning.\n/// For example:\n///     unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']\nfn unify_stringlist(lst: Vec<&str>) -> Vec<String> {\n    assert!(lst.iter().all(|l| l.is_ascii()));\n\n    lst.iter()\n        .enumerate()\n        .map(|(i, &s)| format!(\"{}{}\", s, \"*\".repeat(lst[..i].iter().filter(|&&x| x == s).count())))\n        .collect()\n}\nassert_eq!(unify_stringlist(vec![\"a\", \"b\", \"c\"]), vec![\"a\", \"b\", \"c\"]);\nassert_eq!(unify_stringlist(vec![\"a\", \"a\", \"b\", \"a\", \"c\"]), vec![\"a\", \"a*\", \"b\", \"a**\", \"c\"]);\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n/// http://stackoverflow.com/a/1094933\nfn format_size(mut num: f64) -> String {\n    for unit in [\"bytes\", \"KB\", \"MB\", \"GB\"].iter() {\n        if num < 1024.0 && num > -1024.0 {\n            return format!(\"{:.1}{}\", num, unit);\n        }\n        num /= 1024.0;\n    }\n    format!(\"{:.1}TB\", num)\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\nlet file = File::open(\"cmd.sh\")?;\nlet reader = io::BufReader::new(file);\n\nfor (i, line) in reader.lines().enumerate() {\n    let cmd = line?.trim().to_string();\n    println!(\"{} {}\", i, cmd);\n\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(&cmd)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"{}\", stdout);\n}\n\nOk(())\n\n### Concepts\niterating over file lines, command execution from file input, new line character removal\n\n## Example 9\n### Snippet\nfn read_dir<P: AsRef<Path>>(path: P, recursive: bool) -> io::Result<Vec<DirEntry>> {\n    let path = path.as_ref();\n    let mut entries = Vec::new();\n    for entry in fs::read_dir(path)? {\n        let entry = entry?;\n        let path = entry.path().to_str().unwrap().to_string();\n        let children = if recursive && entry.file_type()?.is_dir() {\n            Some(read_dir(&path, true)?)\n        } else {\n            None\n        };\n        entries.push(DirEntry { path, children });\n    }\n    Ok(entries)\n}\n\n### Concepts", "fingerprint": null, "seed": "fn read_dir<P: AsRef<Path>>(path: P, recursive: bool) -> io::Result<Vec<DirEntry>> {\n    let path = path.as_ref();\n    let mut entries = Vec::new();\n    for entry in fs::read_dir(path)? {\n        let entry = entry?;\n        let path = entry.path().to_str().unwrap().to_string();\n        let children = if recursive && entry.file_type()?.is_dir() {\n            Some(read_dir(&path, true)?)\n        } else {\n            None\n        };\n        entries.push(DirEntry { path, children });\n    }\n    Ok(entries)\n}", "id": 283, "concepts": ["recursion", "file type checking", "directory traversal", "iterating over directory contents with directory traversal"]}
